{
  "units": [
    {
      "id": "unit-1",
      "title": "Arrays",
      "description": "Master the fundamentals of arrays and string manipulation",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "arrays-basics",
          "title": "Basics",
          "description": "Understanding what arrays are and basic concepts",
          "xpReward": 50,
          "questions": [
            {
              "id": "q1",
              "type": "mcq",
              "question": "What is the key characteristic of how arrays store elements in memory?",
              "options": ["Elements are stored in random locations", "Elements are stored in contiguous memory locations", "Elements are stored in separate memory blocks", "Elements are stored in linked memory nodes"],
              "correctAnswer": "Elements are stored in contiguous memory locations",
              "explanation": "Arrays store elements in contiguous (adjacent) memory locations, which enables constant-time access by index and better cache performance.",
              "difficulty": "easy",
              "topic": "arrays"
            },
            {
              "id": "q2",
              "type": "mcq",
              "question": "What is the main advantage of arrays over linked lists?",
              "options": ["Dynamic size", "Faster insertion at beginning", "Random access in O(1) time", "Lower memory usage per element"],
              "correctAnswer": "Random access in O(1) time",
              "explanation": "Arrays provide O(1) random access to elements by index, while linked lists require O(n) traversal to reach a specific element.",
              "difficulty": "easy",
              "topic": "arrays"
            },
            {
              "id": "q3",
              "type": "mcq",
              "question": "What is the difference between static and dynamic arrays?",
              "options": ["Static arrays can change size, dynamic cannot", "Static arrays have fixed size, dynamic can grow/shrink", "Static arrays are faster", "There is no difference"],
              "correctAnswer": "Static arrays have fixed size, dynamic can grow/shrink",
              "explanation": "Static arrays have a fixed size determined at compile time, while dynamic arrays can resize during runtime as needed.",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q4",
              "type": "fillInBlank",
              "question": "In most programming languages, array indexing starts from _____.",
              "correctAnswer": "0",
              "explanation": "Most programming languages use 0-based indexing, where the first element is at index 0, second at index 1, and so on.",
              "difficulty": "easy",
              "topic": "arrays"
            },
            {
              "id": "q5",
              "type": "mcq",
              "question": "Why do arrays have better cache performance compared to linked lists?",
              "options": ["Arrays use less memory", "Arrays have contiguous memory layout", "Arrays are smaller", "Arrays use pointers"],
              "correctAnswer": "Arrays have contiguous memory layout",
              "explanation": "Arrays store elements in contiguous memory, which means accessing nearby elements benefits from CPU cache locality, making sequential access faster.",
              "difficulty": "medium",
              "topic": "arrays"
            }
          ]
        },
        {
          "id": "array-operations",
          "title": "Operations",
          "description": "Understanding time complexity of basic array operations",
          "xpReward": 60,
          "questions": [
            {
              "id": "q6",
              "type": "mcq",
              "question": "What is the time complexity of accessing an element in an array by index?",
              "options": ["O(1)", "O(n)", "O(log n)", "O(n²)"],
              "correctAnswer": "O(1)",
              "explanation": "Array access by index is constant time O(1) because arrays store elements in contiguous memory locations with direct address calculation.",
              "difficulty": "easy",
              "topic": "arrays"
            },
            {
              "id": "q7",
              "type": "mcq",
              "question": "What is the time complexity of inserting an element at the end of a dynamic array?",
              "options": ["O(1)", "O(n)", "O(log n)", "O(1) amortized"],
              "correctAnswer": "O(1) amortized",
              "explanation": "Insertion at the end is O(1) amortized because occasional resizing operations (O(n)) are spread across many insertions.",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q8",
              "type": "mcq",
              "question": "Why is inserting at the beginning of an array O(n)?",
              "options": ["Need to allocate new memory", "Need to shift all existing elements", "Need to search for position", "Need to check bounds"],
              "correctAnswer": "Need to shift all existing elements",
              "explanation": "Inserting at the beginning requires shifting all existing elements one position to the right, making it O(n) operation.",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q9",
              "type": "fillInBlank",
              "question": "The time complexity of deleting an element from the end of an array is _____.",
              "correctAnswer": "O(1)",
              "explanation": "Deleting from the end only requires removing the last element without shifting others, making it O(1).",
              "difficulty": "easy",
              "topic": "arrays"
            },
            {
              "id": "q10",
              "type": "mcq",
              "question": "What is the time complexity of linear search in an unsorted array?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
              "correctAnswer": "O(n)",
              "explanation": "Linear search may need to check every element in the worst case, making it O(n).",
              "difficulty": "easy",
              "topic": "arrays"
            },
            {
              "id": "q11",
              "type": "mcq",
              "question": "What is the time complexity of binary search in a sorted array?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
              "correctAnswer": "O(log n)",
              "explanation": "Binary search repeatedly divides the search space in half, resulting in O(log n) time complexity.",
              "difficulty": "medium",
              "topic": "arrays"
            }
          ]
        },
        {
          "id": "array-properties",
          "title": "Properties",
          "description": "Essential array properties and common operations",
          "xpReward": 55,
          "questions": [
            {
              "id": "q12",
              "type": "fillInBlank",
              "question": "To find the number of elements in an array, you typically use the _____ property.",
              "correctAnswer": "length",
              "explanation": "The 'length' property returns the number of elements in an array and is available in most programming languages.",
              "difficulty": "easy",
              "topic": "arrays"
            },
            {
              "id": "q13",
              "type": "mcq",
              "question": "What happens when you try to access an array element beyond its bounds?",
              "options": ["Returns null", "Throws an exception or undefined behavior", "Returns 0", "Automatically extends the array"],
              "correctAnswer": "Throws an exception or undefined behavior",
              "explanation": "Accessing out-of-bounds indices typically results in an exception (Java), undefined behavior (C/C++), or undefined (JavaScript).",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q14",
              "type": "mcq",
              "question": "When initializing an array with zeros, what is typically the most efficient approach?",
              "options": ["Loop through and set each element", "Use built-in initialization methods", "Copy from another zero array", "Use recursion"],
              "correctAnswer": "Use built-in initialization methods",
              "explanation": "Most languages provide efficient built-in methods for array initialization (like Arrays.fill() or calloc()) that are optimized at the system level.",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q15",
              "type": "mcq", 
              "question": "What is the difference between shallow and deep copying of arrays?",
              "options": ["Shallow copies references, deep copies values", "Shallow is faster, deep is slower", "Shallow copies first half, deep copies all", "No difference"],
              "correctAnswer": "Shallow copies references, deep copies values",
              "explanation": "Shallow copy creates a new array but copies references to objects, while deep copy creates new objects as well.",
              "difficulty": "hard",
              "topic": "arrays"
            },
            {
              "id": "q16",
              "type": "fillInBlank",
              "question": "When comparing two arrays for equality, you typically need to compare both their _____ and corresponding elements.",
              "correctAnswer": "length",
              "explanation": "Array equality requires checking that arrays have the same length and that all corresponding elements are equal.",
              "difficulty": "medium",
              "topic": "arrays"
            }
          ]
        },
        {
          "id": "array-memory",
          "title": "Memory",
          "description": "Understanding how arrays manage memory and resizing",
          "xpReward": 65,
          "questions": [
            {
              "id": "q17",
              "type": "mcq",
              "question": "What is a key limitation of fixed-size arrays?",
              "options": ["Slow access time", "Cannot change size after creation", "Use more memory", "Poor cache performance"],
              "correctAnswer": "Cannot change size after creation",
              "explanation": "Fixed-size arrays have their size determined at creation time and cannot be changed, unlike dynamic arrays.",
              "difficulty": "easy",
              "topic": "arrays"
            },
            {
              "id": "q18",
              "type": "fillInBlank",
              "question": "Dynamic arrays like ArrayList in Java or vector in C++ are also called _____ arrays.",
              "correctAnswer": "resizable",
              "explanation": "Dynamic/resizable arrays can grow and shrink in size during runtime, unlike fixed-size arrays.",
              "difficulty": "easy",
              "topic": "arrays"
            },
            {
              "id": "q19",
              "type": "mcq",
              "question": "When a dynamic array needs to grow beyond its current capacity, what typically happens?",
              "options": ["It extends in place", "A new larger array is allocated and elements are copied", "It throws an error", "It compresses existing elements"],
              "correctAnswer": "A new larger array is allocated and elements are copied",
              "explanation": "Dynamic arrays typically allocate a new, larger array and copy all existing elements when they need to grow beyond capacity.",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q20",
              "type": "mcq",
              "question": "What is a common resizing strategy for dynamic arrays when they need to grow?",
              "options": ["Add one element at a time", "Double the current size", "Add 10 elements", "Triple the size"],
              "correctAnswer": "Double the current size",
              "explanation": "Doubling the size is a common strategy that provides good amortized performance - it balances memory usage with the frequency of expensive resize operations.",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q21",
              "type": "fillInBlank",
              "question": "The process of creating a new larger array and copying elements during resizing is called _____.",
              "correctAnswer": "reallocation",
              "explanation": "Reallocation is the process of allocating new memory space and copying data when an array needs to resize.",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q22",
              "type": "mcq",
              "question": "Why don't dynamic arrays shrink immediately when elements are removed?",
              "options": ["It's impossible to shrink", "To avoid frequent reallocation", "To maintain order", "To save computation time"],
              "correctAnswer": "To avoid frequent reallocation",
              "explanation": "Dynamic arrays typically don't shrink immediately to avoid the overhead of frequent reallocations when elements are added and removed repeatedly.",
              "difficulty": "hard",
              "topic": "arrays"
            }
          ]
        },
        {
          "id": "array-algorithms",
          "title": "Algorithms", 
          "description": "Common algorithms using arrays",
          "xpReward": 75,
          "questions": [
            {
              "id": "q23",
              "type": "mcq",
              "question": "What is the optimal time complexity for finding two numbers in a sorted array that sum to a target?",
              "options": ["O(n²)", "O(n log n)", "O(n)", "O(log n)"],
              "correctAnswer": "O(n)",
              "explanation": "Using two pointers (one at start, one at end) on a sorted array gives O(n) time complexity.",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q24",
              "type": "fillInBlank", 
              "question": "The technique that uses two pointers moving towards each other is called the _____ pointer technique.",
              "correctAnswer": "two",
              "explanation": "Two pointer technique is commonly used for array problems where you need to find pairs or subarrays.",
              "difficulty": "medium",
              "topic": "arrays"
            }
          ]
        },
        {
          "id": "array-advanced",
          "title": "Advanced Topics",
          "description": "Advanced array techniques and optimization problems",
          "xpReward": 85,
          "questions": [
            {
              "id": "q24a",
              "type": "mcq",
              "question": "What is the time complexity of finding the maximum subarray sum using Kadane's algorithm?",
              "options": ["O(n log n)", "O(n²)", "O(n)", "O(1)"],
              "correctAnswer": "O(n)",
              "explanation": "Kadane's algorithm finds the maximum subarray sum in linear time by maintaining running sum and maximum.",
              "difficulty": "hard",
              "topic": "arrays"
            },
            {
              "id": "q24b",
              "type": "mcq",
              "question": "In a sliding window approach for finding maximum sum of k consecutive elements, what is the time complexity?",
              "options": ["O(n*k)", "O(n)", "O(k)", "O(n log k)"],
              "correctAnswer": "O(n)",
              "explanation": "Sliding window maintains a window of k elements and slides it across the array, resulting in O(n) time.",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q24c",
              "type": "fillInBlank",
              "question": "The Boyer-Moore majority vote algorithm finds an element that appears more than _____ times in an array.",
              "correctAnswer": "n/2",
              "explanation": "Boyer-Moore algorithm finds the majority element that appears more than n/2 times in the array.",
              "difficulty": "hard",
              "topic": "arrays"
            },
            {
              "id": "q24d",
              "type": "mcq",
              "question": "What is the space complexity of merging two sorted arrays in-place?",
              "options": ["O(1)", "O(n)", "O(log n)", "O(n log n)"],
              "correctAnswer": "O(1)",
              "explanation": "In-place merging uses constant extra space by rearranging elements within the existing arrays.",
              "difficulty": "hard",
              "topic": "arrays"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-2", 
      "title": "Hash Maps",
      "description": "Master key-value data structures and hashing techniques",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "hashmap-fundamentals",
          "title": "Basics",
          "description": "Understanding hash tables and key-value storage",
          "xpReward": 60,
          "questions": [
            {
              "id": "q25",
              "type": "mcq",
              "question": "What is the primary purpose of a hash map (dictionary)?",
              "options": ["Store elements in order", "Map keys to values for fast lookup", "Sort data automatically", "Compress data"],
              "correctAnswer": "Map keys to values for fast lookup",
              "explanation": "Hash maps are designed to store key-value pairs and provide fast O(1) average-case lookup, insertion, and deletion operations.",
              "difficulty": "easy",
              "topic": "hashmap"
            },
            {
              "id": "q26",
              "type": "fillInBlank",
              "question": "A hash map uses a _____ function to convert keys into array indices.",
              "correctAnswer": "hash",
              "explanation": "A hash function takes a key and converts it into an array index where the corresponding value will be stored.",
              "difficulty": "easy",
              "topic": "hashmap"
            },
            {
              "id": "q27",
              "type": "mcq",
              "question": "What is the average time complexity for lookup in a hash map?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
              "correctAnswer": "O(1)",
              "explanation": "Hash maps provide O(1) average-case time complexity for lookup operations due to direct index access via hashing.",
              "difficulty": "easy",
              "topic": "hashmap"
            },
            {
              "id": "q28",
              "type": "mcq",
              "question": "What happens when two different keys produce the same hash value?",
              "options": ["One key overwrites the other", "A collision occurs", "The hash map breaks", "Keys are merged"],
              "correctAnswer": "A collision occurs",
              "explanation": "When different keys hash to the same index, it's called a collision. Hash maps need strategies to handle collisions.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q29",
              "type": "fillInBlank",
              "question": "Hash maps are also known as hash tables, dictionaries, or _____ arrays.",
              "correctAnswer": "associative",
              "explanation": "Associative arrays associate keys with values, allowing you to look up values using their corresponding keys.",
              "difficulty": "easy",
              "topic": "hashmap"
            }
          ]
        },
        {
          "id": "hash-functions",
          "title": "Functions",
          "description": "Understanding how hash functions work and their characteristics",
          "xpReward": 65,
          "questions": [
            {
              "id": "q30",
              "type": "mcq",
              "question": "What is a key property that a good hash function should have?",
              "options": ["Always return the same value", "Distribute keys uniformly across buckets", "Only work with strings", "Be reversible"],
              "correctAnswer": "Distribute keys uniformly across buckets",
              "explanation": "A good hash function should distribute keys uniformly to minimize collisions and ensure balanced performance.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q31",
              "type": "fillInBlank",
              "question": "A hash function should be _____, meaning the same key always produces the same hash value.",
              "correctAnswer": "deterministic",
              "explanation": "Deterministic behavior ensures that looking up the same key will always check the same location in the hash table.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q32",
              "type": "mcq",
              "question": "What is the 'avalanche effect' in hash functions?",
              "options": ["Hash values increase exponentially", "Small input changes cause large output changes", "Function becomes slower", "Memory usage doubles"],
              "correctAnswer": "Small input changes cause large output changes",
              "explanation": "The avalanche effect means small changes to input should produce significantly different hash values, improving distribution.",
              "difficulty": "hard",
              "topic": "hashmap"
            },
            {
              "id": "q33",
              "type": "mcq",
              "question": "Why should hash functions be fast to compute?",
              "options": ["To save memory", "To maintain O(1) performance", "To reduce collisions", "To improve security"],
              "correctAnswer": "To maintain O(1) performance",
              "explanation": "If hash function computation is slow, it would degrade the overall O(1) performance promise of hash maps.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q34",
              "type": "fillInBlank",
              "question": "The result of applying a hash function to a key is called a hash _____ or hash code.",
              "correctAnswer": "value",
              "explanation": "The hash value or hash code is the numerical result that determines where to store/find the key-value pair.",
              "difficulty": "easy",
              "topic": "hashmap"
            }
          ]
        },
        {
          "id": "collision-handling",
          "title": "Collisions",
          "description": "Methods for handling hash collisions",
          "xpReward": 70,
          "questions": [
            {
              "id": "q35",
              "type": "mcq",
              "question": "What is chaining as a collision resolution method?",
              "options": ["Linking hash functions together", "Storing collided items in linked lists", "Creating hash chains", "Connecting multiple hash maps"],
              "correctAnswer": "Storing collided items in linked lists",
              "explanation": "Chaining handles collisions by maintaining a linked list at each bucket to store all items that hash to the same index.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q36",
              "type": "mcq",
              "question": "What is open addressing in hash tables?",
              "options": ["Tables that can be accessed by anyone", "Finding alternative locations for collided items", "Hash tables without collision handling", "Dynamic resizing of tables"],
              "correctAnswer": "Finding alternative locations for collided items",
              "explanation": "Open addressing resolves collisions by probing for alternative empty slots in the hash table when collisions occur.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q37",
              "type": "fillInBlank",
              "question": "Linear probing is a type of _____ addressing where we check the next sequential slot.",
              "correctAnswer": "open",
              "explanation": "Linear probing is an open addressing technique that checks slots sequentially (i, i+1, i+2, ...) to find an empty position.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q38",
              "type": "mcq",
              "question": "What is a disadvantage of linear probing?",
              "options": ["Uses too much memory", "Creates clustering of elements", "Too slow for large datasets", "Cannot handle string keys"],
              "correctAnswer": "Creates clustering of elements",
              "explanation": "Linear probing can create clusters of consecutive occupied slots, leading to longer probe sequences and degraded performance.",
              "difficulty": "hard",
              "topic": "hashmap"
            },
            {
              "id": "q39",
              "type": "mcq",
              "question": "What is quadratic probing?",
              "options": ["Probing with quadratic hash functions", "Checking slots at quadratic intervals (i²)", "Using four probes maximum", "Squaring the key before hashing"],
              "correctAnswer": "Checking slots at quadratic intervals (i²)",
              "explanation": "Quadratic probing checks slots at quadratic distances (i, i+1², i+2², i+3², ...) to reduce clustering compared to linear probing.",
              "difficulty": "hard",
              "topic": "hashmap"
            }
          ]
        },
        {
          "id": "hashmap-operations",
          "title": "Operations",
          "description": "Core operations and their performance characteristics",
          "xpReward": 55,
          "questions": [
            {
              "id": "q40",
              "type": "mcq",
              "question": "What is the worst-case time complexity for hash map operations?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
              "correctAnswer": "O(n)",
              "explanation": "In the worst case (all keys hash to same bucket), hash map operations degrade to O(n) when using chaining or when the table is full with open addressing.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q41",
              "type": "fillInBlank",
              "question": "The _____ factor is the ratio of the number of stored elements to the size of the hash table.",
              "correctAnswer": "load",
              "explanation": "Load factor = (number of elements) / (table size). It's used to determine when to resize the hash table.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q42",
              "type": "mcq",
              "question": "When should a hash map typically be resized?",
              "options": ["When it's completely full", "When load factor exceeds a threshold (e.g., 0.75)", "Every 100 insertions", "Never"],
              "correctAnswer": "When load factor exceeds a threshold (e.g., 0.75)",
              "explanation": "Hash maps typically resize when load factor exceeds 0.75 to maintain good performance and minimize collisions.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q43",
              "type": "mcq",
              "question": "What happens during hash map resizing?",
              "options": ["Only the table size changes", "All elements are rehashed and moved", "Old elements are deleted", "Table is compressed"],
              "correctAnswer": "All elements are rehashed and moved",
              "explanation": "During resizing, a new larger table is created and all existing elements are rehashed and inserted into new positions.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q44",
              "type": "fillInBlank",
              "question": "Hash map deletion in open addressing often uses _____ deletion to avoid breaking probe sequences.",
              "correctAnswer": "lazy",
              "explanation": "Lazy deletion marks slots as 'deleted' rather than truly empty to maintain probe sequences for other elements.",
              "difficulty": "hard",
              "topic": "hashmap"
            }
          ]
        },
        {
          "id": "hashmap-applications",
          "title": "Applications",
          "description": "Real-world applications and problem-solving with hash maps",
          "xpReward": 60,
          "questions": [
            {
              "id": "q45",
              "type": "mcq",
              "question": "Which problem is best solved using a hash map?",
              "options": ["Finding the maximum element", "Checking if array contains duplicates", "Sorting an array", "Finding array length"],
              "correctAnswer": "Checking if array contains duplicates",
              "explanation": "Hash maps excel at membership testing and duplicate detection with O(1) average lookup time.",
              "difficulty": "easy",
              "topic": "hashmap"
            },
            {
              "id": "q46",
              "type": "fillInBlank",
              "question": "To count the frequency of elements in an array, you would use a hash map where keys are elements and values are their _____.",
              "correctAnswer": "counts",
              "explanation": "Frequency counting maps each unique element to how many times it appears in the dataset.",
              "difficulty": "easy", 
              "topic": "hashmap"
            },
            {
              "id": "q47",
              "type": "mcq",
              "question": "What is a common use case for hash maps in caching?",
              "options": ["Storing cache in order", "Fast key-based cache lookup", "Compressing cached data", "Sorting cache entries"],
              "correctAnswer": "Fast key-based cache lookup",
              "explanation": "Hash maps provide O(1) lookup time, making them ideal for caching where fast retrieval by key is essential.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q48",
              "type": "mcq",
              "question": "How would you find the first non-repeating character in a string using hash maps?",
              "options": ["Count frequency, then find first with count=1", "Sort string first", "Use two hash maps", "Check each character individually"],
              "correctAnswer": "Count frequency, then find first with count=1",
              "explanation": "First pass counts frequency of each character, second pass finds the first character with frequency 1.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q49",
              "type": "fillInBlank",
              "question": "In database systems, hash maps are commonly used to implement _____ joins for fast lookups.",
              "correctAnswer": "hash",
              "explanation": "Hash joins use hash maps to build lookup tables for one relation, then probe with the other relation for matches.",
              "difficulty": "hard",
              "topic": "hashmap"
            }
          ]
        },
        {
          "id": "hashmap-performance",
          "title": "Performance Analysis",
          "description": "Advanced performance considerations and optimization techniques",
          "xpReward": 75,
          "questions": [
            {
              "id": "q49a",
              "type": "mcq",
              "question": "What happens to hash map performance when the load factor approaches 1.0?",
              "options": ["Performance improves", "More collisions occur, degrading performance", "Memory usage decreases", "Hash function becomes faster"],
              "correctAnswer": "More collisions occur, degrading performance",
              "explanation": "As load factor approaches 1.0, the hash table becomes nearly full, leading to more collisions and longer probe sequences.",
              "difficulty": "hard",
              "topic": "hashmap"
            },
            {
              "id": "q49b",
              "type": "fillInBlank",
              "question": "Cuckoo hashing guarantees O(1) worst-case lookup time but may require _____ during insertion.",
              "correctAnswer": "rehashing",
              "explanation": "Cuckoo hashing may need to rehash the entire table if cycles occur during insertion, but guarantees constant lookup time.",
              "difficulty": "hard",
              "topic": "hashmap"
            },
            {
              "id": "q49c",
              "type": "mcq",
              "question": "Which technique can improve cache performance in hash tables?",
              "options": ["Using larger hash codes", "Robin Hood hashing", "Increasing collision rate", "Using more memory"],
              "correctAnswer": "Robin Hood hashing",
              "explanation": "Robin Hood hashing minimizes probe distances and improves cache locality by evicting elements with shorter probe distances.",
              "difficulty": "hard",
              "topic": "hashmap"
            },
            {
              "id": "q49d",
              "type": "mcq",
              "question": "What is the main advantage of consistent hashing in distributed systems?",
              "options": ["Faster lookups", "Minimal data movement when nodes are added/removed", "Better collision resolution", "Lower memory usage"],
              "correctAnswer": "Minimal data movement when nodes are added/removed",
              "explanation": "Consistent hashing distributes keys across nodes such that adding or removing nodes requires minimal redistribution of data.",
              "difficulty": "hard",
              "topic": "hashmap"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-3",
      "title": "Stacks",
      "description": "LIFO data structure for efficient operations",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "stack-basics",
          "title": "Stack Basics",
          "description": "Understanding LIFO principle and basic operations",
          "xpReward": 55,
          "questions": [
            {
              "id": "q50",
              "type": "mcq",
              "question": "What does LIFO stand for in the context of stacks?",
              "options": ["Last In First Out", "Last In Final Out", "Late In Fast Out", "Large In Full Out"],
              "correctAnswer": "Last In First Out",
              "explanation": "LIFO means the last element added to the stack is the first one to be removed.",
              "difficulty": "easy",
              "topic": "stack"
            },
            {
              "id": "q51",
              "type": "fillInBlank",
              "question": "The operation to add an element to the top of a stack is called _____.",
              "correctAnswer": "push",
              "explanation": "Push operation adds an element to the top of the stack.",
              "difficulty": "easy",
              "topic": "stack"
            },
            {
              "id": "q52",
              "type": "mcq",
              "question": "What happens when you try to pop from an empty stack?",
              "options": ["Returns null", "Stack underflow error", "Returns 0", "Creates new element"],
              "correctAnswer": "Stack underflow error",
              "explanation": "Attempting to pop from an empty stack results in a stack underflow error.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q52a",
              "type": "fillInBlank",
              "question": "The operation to remove and return the top element from a stack is called _____.",
              "correctAnswer": "pop",
              "explanation": "Pop operation removes and returns the element at the top of the stack.",
              "difficulty": "easy",
              "topic": "stack"
            },
            {
              "id": "q52b",
              "type": "mcq",
              "question": "What operation allows you to view the top element without removing it?",
              "options": ["push", "pop", "peek", "size"],
              "correctAnswer": "peek",
              "explanation": "Peek (or top) operation returns the top element without removing it from the stack.",
              "difficulty": "easy",
              "topic": "stack"
            },
            {
              "id": "q52c",
              "type": "mcq",
              "question": "What is the time complexity of push and pop operations on a stack?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
              "correctAnswer": "O(1)",
              "explanation": "Both push and pop operations on a stack are O(1) constant time as they only modify the top element.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q52d",
              "type": "fillInBlank",
              "question": "When a stack exceeds its maximum capacity, it results in a stack _____ error.",
              "correctAnswer": "overflow",
              "explanation": "Stack overflow occurs when trying to push elements beyond the stack's capacity limit.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q52e",
              "type": "mcq",
              "question": "Which of these is NOT a typical stack operation?",
              "options": ["push", "pop", "peek", "sort"],
              "correctAnswer": "sort",
              "explanation": "Stacks don't have a built-in sort operation. Basic operations are push, pop, peek, isEmpty, and size.",
              "difficulty": "easy",
              "topic": "stack"
            }
          ]
        },
        {
          "id": "stack-applications",
          "title": "Stack Applications",
          "description": "Real-world uses of stacks",
          "xpReward": 65,
          "questions": [
            {
              "id": "q55",
              "type": "mcq",
              "question": "Which data structure is best for implementing function call management?",
              "options": ["Queue", "Stack", "Array", "Hash Map"],
              "correctAnswer": "Stack",
              "explanation": "Stacks are perfect for function calls due to LIFO - last called function returns first.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q55a",
              "type": "mcq",
              "question": "What is a call stack used for in programming?",
              "options": ["Storing variables", "Managing function calls and returns", "Sorting data", "Memory allocation"],
              "correctAnswer": "Managing function calls and returns",
              "explanation": "The call stack tracks function calls, local variables, and return addresses using LIFO principle.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q55b",
              "type": "fillInBlank",
              "question": "Stacks are commonly used to check for balanced _____ in expressions.",
              "correctAnswer": "parentheses",
              "explanation": "Stacks are ideal for checking balanced parentheses, brackets, and braces in mathematical expressions.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q55c",
              "type": "mcq",
              "question": "How would you use a stack to evaluate a postfix expression?",
              "options": ["Push operators, pop operands", "Push operands, pop when seeing operators", "Push everything in order", "Use two stacks"],
              "correctAnswer": "Push operands, pop when seeing operators",
              "explanation": "In postfix evaluation, push operands onto stack and when you see an operator, pop required operands, compute, and push result back.",
              "difficulty": "hard",
              "topic": "stack"
            },
            {
              "id": "q55d",
              "type": "mcq",
              "question": "Which application uses stack for tracking history?",
              "options": ["Database indexing", "Web browser back button", "File compression", "Network routing"],
              "correctAnswer": "Web browser back button",
              "explanation": "Browser back button uses a stack to track page history - last visited page is first to return to.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q55e",
              "type": "fillInBlank",
              "question": "Undo operations in text editors are typically implemented using a _____.",
              "correctAnswer": "stack",
              "explanation": "Undo functionality uses a stack to store actions in reverse order - last action is first to be undone.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q55f",
              "type": "mcq",
              "question": "In converting infix to postfix notation, what do you do when encountering an opening parenthesis?",
              "options": ["Ignore it", "Push it onto the stack", "Pop from stack", "Add to output"],
              "correctAnswer": "Push it onto the stack",
              "explanation": "Opening parentheses are pushed onto the stack to mark the beginning of a subexpression.",
              "difficulty": "hard",
              "topic": "stack"
            },
            {
              "id": "q55g",
              "type": "mcq",
              "question": "Which sorting algorithm uses a stack internally?",
              "options": ["Bubble sort", "Merge sort", "Quick sort (recursive)", "Selection sort"],
              "correctAnswer": "Quick sort (recursive)",
              "explanation": "Recursive quick sort uses the call stack to manage recursive calls for partitioning subarrays.",
              "difficulty": "hard",
              "topic": "stack"
            },
            {
              "id": "q55h",
              "type": "fillInBlank",
              "question": "Depth-First Search (DFS) traversal can be implemented using a _____ or recursion.",
              "correctAnswer": "stack",
              "explanation": "DFS uses a stack (explicit or implicit via recursion) to explore as deep as possible before backtracking.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "stack-problems",
              "title": "Stack Problems",
              "description": "Classic coding and interview problems involving stacks",
              "xpReward": 75,
              "questions": [
                {
                  "id": "q55n",
                  "type": "mcq",
                  "question": "Which stack-based approach is used to solve the Next Greater Element problem?",
                  "options": ["Use two stacks", "Use a monotonic stack", "Sort the array", "Use recursion"],
                  "correctAnswer": "Use a monotonic stack",
                  "explanation": "A monotonic stack helps efficiently find the next greater element for each item in a single pass.",
                  "difficulty": "hard",
                  "topic": "stack"
                },
                {
                  "id": "q55o",
                  "type": "mcq",
                  "question": "What is the main idea behind the Min Stack problem?",
                  "options": ["Track only the top element", "Track the minimum value at each push", "Sort the stack after each operation", "Use a queue"],
                  "correctAnswer": "Track the minimum value at each push",
                  "explanation": "A Min Stack keeps track of the minimum value at each push to allow O(1) retrieval of the minimum.",
                  "difficulty": "hard",
                  "topic": "stack"
                },
                {
                  "id": "q55p",
                  "type": "mcq",
                  "question": "Which stack-based algorithm is used to find the largest rectangle in a histogram?",
                  "options": ["Monotonic stack", "DFS", "BFS", "Heap"],
                  "correctAnswer": "Monotonic stack",
                  "explanation": "A monotonic stack is used to efficiently compute the largest rectangle in a histogram in O(n) time.",
                  "difficulty": "hard",
                  "topic": "stack"
                }
              ]
            },
            {
              "id": "stack-parsing",
              "title": "Stack in Parsing and Evaluation",
              "description": "Using stacks for parsing and evaluating expressions",
              "xpReward": 70,
              "questions": [
                {
                  "id": "q55q",
                  "type": "mcq",
                  "question": "Which notation is easiest to evaluate using a stack?",
                  "options": ["Infix", "Prefix", "Postfix (Reverse Polish Notation)", "All are equally easy"],
                  "correctAnswer": "Postfix (Reverse Polish Notation)",
                  "explanation": "Postfix expressions can be evaluated in a single left-to-right pass using a stack.",
                  "difficulty": "medium",
                  "topic": "stack"
                },
                {
                  "id": "q55r",
                  "type": "fillInBlank",
                  "question": "Stacks are used to check for balanced _____ in code and expressions.",
                  "correctAnswer": "parentheses",
                  "explanation": "Stacks are ideal for checking balanced parentheses, brackets, and braces in code and mathematical expressions.",
                  "difficulty": "easy",
                  "topic": "stack"
                },
                {
                  "id": "q55s",
                  "type": "mcq",
                  "question": "What is the main advantage of using a stack for parsing nested structures?",
                  "options": ["It sorts the input", "It allows tracking of open/close pairs", "It speeds up multiplication", "It reduces memory usage"],
                  "correctAnswer": "It allows tracking of open/close pairs",
                  "explanation": "Stacks help track open and close pairs (like parentheses) in nested structures, ensuring correct matching.",
                  "difficulty": "medium",
                  "topic": "stack"
                }
              ]
            },
            {
              "id": "stack-recursion",
              "title": "Stack and Recursion",
              "description": "Understanding the relationship between recursion and the call stack",
              "xpReward": 65,
              "questions": [
                {
                  "id": "q55t",
                  "type": "mcq",
                  "question": "What does each recursive function call create on the call stack?",
                  "options": ["A new thread", "A new stack frame", "A new variable", "A new process"],
                  "correctAnswer": "A new stack frame",
                  "explanation": "Each recursive call creates a new stack frame to store local variables and return address.",
                  "difficulty": "medium",
                  "topic": "stack"
                },
                {
                  "id": "q55u",
                  "type": "mcq",
                  "question": "What happens if recursion goes too deep without a base case?",
                  "options": ["Stack overflow", "Infinite loop", "Program runs faster", "Memory leak"],
                  "correctAnswer": "Stack overflow",
                  "explanation": "Without a base case, recursive calls keep adding stack frames until the stack limit is exceeded, causing a stack overflow.",
                  "difficulty": "medium",
                  "topic": "stack"
                },
                {
                  "id": "q55v",
                  "type": "fillInBlank",
                  "question": "The call stack stores local variables and the _____ address for each function call.",
                  "correctAnswer": "return",
                  "explanation": "The return address tells the program where to continue after a function call completes.",
                  "difficulty": "medium",
                  "topic": "stack"
                }
              ]
            },
            {
              "id": "stack-backtracking",
              "title": "Stack in Backtracking",
              "description": "How stacks are used in backtracking algorithms",
              "xpReward": 70,
              "questions": [
                {
                  "id": "q55w",
                  "type": "mcq",
                  "question": "Which data structure is most commonly used to implement backtracking?",
                  "options": ["Queue", "Stack", "Heap", "Array"],
                  "correctAnswer": "Stack",
                  "explanation": "Backtracking algorithms use a stack to keep track of choices and revert to previous states.",
                  "difficulty": "medium",
                  "topic": "stack"
                },
                {
                  "id": "q55x",
                  "type": "mcq",
                  "question": "In maze solving with backtracking, what does the stack store?",
                  "options": ["All possible paths", "Visited cells", "Current path positions", "Maze size"],
                  "correctAnswer": "Current path positions",
                  "explanation": "The stack stores the current path positions so you can backtrack when hitting a dead end.",
                  "difficulty": "medium",
                  "topic": "stack"
                },
                {
                  "id": "q55y",
                  "type": "fillInBlank",
                  "question": "In the N-Queens problem, the stack is used to keep track of the _____ of queens placed so far.",
                  "correctAnswer": "positions",
                  "explanation": "The stack tracks the positions of queens placed so you can backtrack and try new configurations.",
                  "difficulty": "hard",
                  "topic": "stack"
                }
              ]
            }
          ]
        },
        {
          "id": "monotonic-stacks",
          "title": "Monotonic Stacks",
          "description": "Specialized stacks maintaining monotonic order",
          "xpReward": 80,
          "questions": [
            {
              "id": "q55z",
              "type": "mcq",
              "question": "What property does a monotonic increasing stack maintain?",
              "options": ["Elements are in ascending order from bottom to top", "Elements are in descending order from bottom to top", "All elements are equal", "Stack size increases monotonically"],
              "correctAnswer": "Elements are in ascending order from bottom to top",
              "explanation": "A monotonic increasing stack maintains elements in non-decreasing order from bottom to top.",
              "difficulty": "hard",
              "topic": "stack"
            },
            {
              "id": "q55aa",
              "type": "fillInBlank",
              "question": "Monotonic stacks are commonly used to solve the _____ greater element problem efficiently.",
              "correctAnswer": "next",
              "explanation": "Monotonic stacks efficiently find the next greater element for each element in an array.",
              "difficulty": "hard",
              "topic": "stack"
            },
            {
              "id": "q55bb",
              "type": "mcq",
              "question": "What is the time complexity of solving the next greater element problem using a monotonic stack?",
              "options": ["O(n²)", "O(n log n)", "O(n)", "O(1)"],
              "correctAnswer": "O(n)",
              "explanation": "Each element is pushed and popped at most once, resulting in O(n) time complexity.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q55cc",
              "type": "mcq",
              "question": "In the largest rectangle in histogram problem, what does the monotonic stack store?",
              "options": ["Heights of bars", "Areas of rectangles", "Indices of bars", "Width of rectangles"],
              "correctAnswer": "Indices of bars",
              "explanation": "The stack stores indices of bars in increasing order of their heights to efficiently compute areas.",
              "difficulty": "hard",
              "topic": "stack"
            }
          ]
        },
        {
          "id": "stack-optimization",
          "title": "Stack Optimizations",
          "description": "Advanced stack implementations and space optimizations",
          "xpReward": 75,
          "questions": [
            {
              "id": "q55dd",
              "type": "mcq",
              "question": "What is the key idea behind implementing multiple stacks in a single array?",
              "options": ["Use separate arrays for each stack", "Divide array into equal parts", "Use two ends and grow towards middle", "Stack elements randomly"],
              "correctAnswer": "Use two ends and grow towards middle",
              "explanation": "Two stacks can share an array by starting from opposite ends and growing towards each other.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q55ee",
              "type": "fillInBlank",
              "question": "A _____ stack can efficiently return the minimum element in O(1) time.",
              "correctAnswer": "min",
              "explanation": "A min stack maintains the minimum element at each level to provide O(1) minimum retrieval.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q55ff",
              "type": "mcq",
              "question": "How can you implement a stack that supports getMin() in O(1) time and O(1) extra space?",
              "options": ["Use auxiliary stack", "Store differences from minimum", "Sort the stack", "Use heap"],
              "correctAnswer": "Store differences from minimum",
              "explanation": "By storing differences from minimum and updating minimum dynamically, we can achieve O(1) space.",
              "difficulty": "hard",
              "topic": "stack"
            },
            {
              "id": "q55gg",
              "type": "mcq",
              "question": "What is the space complexity of implementing a stack using recursion?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
              "correctAnswer": "O(n)",
              "explanation": "Recursive implementation uses the call stack, which can grow to O(n) in the worst case.",
              "difficulty": "medium",
              "topic": "stack"
            }
          ]
        },
        {
          "id": "expression-evaluation",
          "title": "Expression Evaluation",
          "description": "Advanced expression parsing and evaluation techniques",
          "xpReward": 85,
          "questions": [
            {
              "id": "q55hh",
              "type": "mcq",
              "question": "In the shunting yard algorithm, what determines operator precedence handling?",
              "options": ["Stack size", "Operator associativity and precedence", "Input order", "Output queue"],
              "correctAnswer": "Operator associativity and precedence",
              "explanation": "The shunting yard algorithm uses operator precedence and associativity rules to convert infix to postfix.",
              "difficulty": "hard",
              "topic": "stack"
            },
            {
              "id": "q55ii",
              "type": "fillInBlank",
              "question": "When evaluating a postfix expression, operands are _____ onto the stack and operators _____ operands from the stack.",
              "correctAnswer": "pushed, pop",
              "explanation": "Postfix evaluation pushes operands onto stack and pops them when operators are encountered.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q55jj",
              "type": "mcq",
              "question": "What is the advantage of postfix notation over infix notation for computer evaluation?",
              "options": ["Shorter expressions", "No need for parentheses or precedence rules", "Faster parsing", "Less memory usage"],
              "correctAnswer": "No need for parentheses or precedence rules",
              "explanation": "Postfix notation eliminates the need for parentheses and precedence rules, making evaluation straightforward.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q55kk",
              "type": "mcq",
              "question": "How many stacks are needed to convert infix to prefix notation?",
              "options": ["One", "Two", "Three", "Depends on expression"],
              "correctAnswer": "Two",
              "explanation": "Converting infix to prefix typically requires two stacks: one for operators and one for operands.",
              "difficulty": "hard",
              "topic": "stack"
            }
          ]
        },
        {
          "id": "advanced-stack-problems",
          "title": "Advanced Problems",
          "description": "Complex competitive programming problems using stacks",
          "xpReward": 90,
          "questions": [
            {
              "id": "q55ll",
              "type": "mcq",
              "question": "In the trapping rainwater problem, what does the stack store?",
              "options": ["Water heights", "Indices of bars", "Areas computed", "Heights of bars"],
              "correctAnswer": "Indices of bars",
              "explanation": "The stack stores indices of bars to efficiently compute trapped water between bars.",
              "difficulty": "hard",
              "topic": "stack"
            },
            {
              "id": "q55mm",
              "type": "fillInBlank",
              "question": "The celebrity problem can be solved using a stack in O(_____) time complexity.",
              "correctAnswer": "n",
              "explanation": "The celebrity problem can be solved in O(n) time using a stack to eliminate non-celebrities.",
              "difficulty": "hard",
              "topic": "stack"
            },
            {
              "id": "q55nn",
              "type": "mcq",
              "question": "What is the key insight for solving the valid parentheses with wildcards problem?",
              "options": ["Use recursion", "Track minimum and maximum open brackets", "Sort the string", "Use dynamic programming"],
              "correctAnswer": "Track minimum and maximum open brackets",
              "explanation": "Track the range of possible open brackets considering wildcards can be '(', ')', or any character.",
              "difficulty": "hard",
              "topic": "stack"
            },
            {
              "id": "q55oo",
              "type": "mcq",
              "question": "In the stock span problem, what optimization does a stack provide?",
              "options": ["Faster sorting", "Avoid recalculating previous spans", "Reduce memory usage", "Improve cache performance"],
              "correctAnswer": "Avoid recalculating previous spans",
              "explanation": "Stack maintains decreasing prices and their spans, avoiding redundant calculations for previous days.",
              "difficulty": "hard",
              "topic": "stack"
            }
          ]
        },
        {
          "id": "stack-implementation",
          "title": "Implementation",
          "description": "Different ways to implement stacks and their trade-offs",
          "xpReward": 70,
          "questions": [
            {
              "id": "q55i",
              "type": "mcq",
              "question": "What is the most common way to implement a stack?",
              "options": ["Using arrays", "Using linked lists", "Using hash tables", "Using trees"],
              "correctAnswer": "Using arrays",
              "explanation": "Arrays are the most common implementation due to their simplicity and O(1) access to the top element.",
              "difficulty": "easy",
              "topic": "stack"
            },
            {
              "id": "q55j",
              "type": "mcq",
              "question": "What is an advantage of implementing a stack using a linked list?",
              "options": ["Faster access", "Dynamic size", "Less memory usage", "Better cache performance"],
              "correctAnswer": "Dynamic size",
              "explanation": "Linked list implementation allows the stack to grow and shrink dynamically without size limitations.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q55k",
              "type": "fillInBlank",
              "question": "In array-based stack implementation, the _____ variable keeps track of the top element's index.",
              "correctAnswer": "top",
              "explanation": "A 'top' pointer/index variable maintains the position of the current top element in the array.",
              "difficulty": "easy",
              "topic": "stack"
            },
            {
              "id": "q55l",
              "type": "mcq",
              "question": "What happens to the space complexity when implementing a stack with a linked list vs array?",
              "options": ["Linked list uses less space", "Array uses less space", "Both use same space", "Depends on implementation"],
              "correctAnswer": "Array uses less space",
              "explanation": "Arrays have less overhead per element, while linked lists need extra memory for storing pointers.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q55m",
              "type": "mcq",
              "question": "In a linked list implementation of stack, where should new elements be added?",
              "options": ["At the end", "At the beginning", "In the middle", "Anywhere"],
              "correctAnswer": "At the beginning",
              "explanation": "Adding at the beginning (head) of linked list gives O(1) push and pop operations for stack behavior.",
              "difficulty": "medium",
              "topic": "stack"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-4",
      "title": "Queues",
      "description": "FIFO data structure for efficient operations",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "queue-basics",
          "title": "Queue Basics",
          "description": "Understanding FIFO principle and queue operations",
          "xpReward": 60,
          "questions": [
            {
              "id": "q53",
              "type": "mcq",
              "question": "What does FIFO stand for in the context of queues?",
              "options": ["First In First Out", "Fast In Fast Out", "Final In First Out", "First In Final Out"],
              "correctAnswer": "First In First Out",
              "explanation": "FIFO means the first element added to the queue is the first one to be removed.",
              "difficulty": "easy",
              "topic": "queue"
            },
            {
              "id": "q54",
              "type": "fillInBlank",
              "question": "Adding an element to the rear of a queue is called _____ operation.",
              "correctAnswer": "enqueue",
              "explanation": "Enqueue operation adds an element to the rear/back of the queue.",
              "difficulty": "easy",
              "topic": "queue"
            },
            {
              "id": "q54a",
              "type": "fillInBlank",
              "question": "Removing an element from the front of a queue is called _____ operation.",
              "correctAnswer": "dequeue",
              "explanation": "Dequeue operation removes an element from the front of the queue.",
              "difficulty": "easy",
              "topic": "queue"
            }
          ]
        },
        {
          "id": "queue-applications",
          "title": "Queue Applications",
          "description": "Real-world uses of queues",
          "xpReward": 55,
          "questions": [
            {
              "id": "q54b",
              "type": "mcq",
              "question": "Which scenario best demonstrates queue usage?",
              "options": ["Function call management", "Print job scheduling", "Undo operations", "Expression evaluation"],
              "correctAnswer": "Print job scheduling",
              "explanation": "Print queues process jobs in FIFO order - first submitted, first printed.",
              "difficulty": "medium",
              "topic": "queue"
            },
            {
              "id": "q54c",
              "type": "mcq",
              "question": "What type of queue is used in breadth-first search?",
              "options": ["Priority queue", "Simple queue", "Circular queue", "Double-ended queue"],
              "correctAnswer": "Simple queue",
              "explanation": "BFS uses a simple FIFO queue to visit nodes level by level.",
              "difficulty": "medium",
              "topic": "queue"
            }
          ]
        },
        {
          "id": "queue-implementation",
          "title": "Queue Implementation",
          "description": "Different ways to implement queues and their trade-offs",
          "xpReward": 65,
          "questions": [
            {
              "id": "q54d",
              "type": "mcq",
              "question": "What is the main advantage of implementing a queue using a circular array?",
              "options": ["Faster enqueue operation", "Better memory utilization", "Simpler implementation", "Constant dequeue time"],
              "correctAnswer": "Better memory utilization",
              "explanation": "Circular arrays reuse freed space, avoiding the shifting overhead of linear arrays and memory waste.",
              "difficulty": "medium",
              "topic": "queue"
            },
            {
              "id": "q54e",
              "type": "fillInBlank",
              "question": "In a circular queue implementation, when rear reaches the end of array, it wraps around to _____ if there's space.",
              "correctAnswer": "0",
              "explanation": "Circular queues wrap the rear pointer to index 0 when it reaches the array end, creating a circular behavior.",
              "difficulty": "easy",
              "topic": "queue"
            },
            {
              "id": "q54f",
              "type": "mcq",
              "question": "What is the time complexity of enqueue and dequeue operations in a linked list implementation?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
              "correctAnswer": "O(1)",
              "explanation": "Both operations only involve updating pointers at the ends of the linked list, taking constant time.",
              "difficulty": "medium",
              "topic": "queue"
            },
            {
              "id": "q54g",
              "type": "mcq",
              "question": "What happens when you try to enqueue into a full array-based queue?",
              "options": ["Element is discarded", "Queue overflow error", "Oldest element is removed", "Array is automatically resized"],
              "correctAnswer": "Queue overflow error",
              "explanation": "Attempting to add to a full fixed-size queue results in an overflow error condition.",
              "difficulty": "medium",
              "topic": "queue"
            }
          ]
        },
        {
          "id": "priority-queues",
          "title": "Priority Queues",
          "description": "Queues where elements are served based on priority",
          "xpReward": 70,
          "questions": [
            {
              "id": "q54h",
              "type": "mcq",
              "question": "In a priority queue, which element is removed first?",
              "options": ["First inserted", "Last inserted", "Smallest priority", "Highest priority"],
              "correctAnswer": "Highest priority",
              "explanation": "Priority queues serve elements based on priority level, with highest priority elements served first.",
              "difficulty": "easy",
              "topic": "queue"
            },
            {
              "id": "q54i",
              "type": "fillInBlank",
              "question": "Priority queues are commonly implemented using a _____ data structure.",
              "correctAnswer": "heap",
              "explanation": "Binary heaps provide efficient O(log n) insertion and O(log n) extraction for priority queues.",
              "difficulty": "medium",
              "topic": "queue"
            },
            {
              "id": "q54j",
              "type": "mcq",
              "question": "What is the time complexity of inserting into a priority queue implemented with a binary heap?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
              "correctAnswer": "O(log n)",
              "explanation": "Insertion requires bubbling up the element to maintain heap property, taking O(log n) time.",
              "difficulty": "medium",
              "topic": "queue"
            },
            {
              "id": "q54k",
              "type": "mcq",
              "question": "Which algorithm commonly uses a priority queue for efficient implementation?",
              "options": ["Binary search", "Bubble sort", "Dijkstra's shortest path", "Linear search"],
              "correctAnswer": "Dijkstra's shortest path",
              "explanation": "Dijkstra's algorithm uses a priority queue to efficiently select the next vertex with minimum distance.",
              "difficulty": "medium",
              "topic": "queue"
            }
          ]
        },
        {
          "id": "deque-operations",
          "title": "Double-Ended Queues (Deque)",
          "description": "Queues supporting insertion and deletion at both ends",
          "xpReward": 75,
          "questions": [
            {
              "id": "q54l",
              "type": "mcq",
              "question": "What operations can be performed on both ends of a deque?",
              "options": ["Only insertion", "Only deletion", "Both insertion and deletion", "Only reading"],
              "correctAnswer": "Both insertion and deletion",
              "explanation": "Deques (double-ended queues) allow insertion and deletion at both front and rear ends.",
              "difficulty": "easy",
              "topic": "queue"
            },
            {
              "id": "q54m",
              "type": "fillInBlank",
              "question": "A deque can be used to implement both _____ and _____ data structures efficiently.",
              "correctAnswer": "stack, queue",
              "explanation": "Deques can simulate stacks (using one end) and queues (using both ends) efficiently.",
              "difficulty": "medium",
              "topic": "queue"
            },
            {
              "id": "q54n",
              "type": "mcq",
              "question": "What is the advantage of using a deque for implementing a sliding window maximum problem?",
              "options": ["Constant space usage", "Can remove elements from both ends", "Automatic sorting", "Faster than arrays"],
              "correctAnswer": "Can remove elements from both ends",
              "explanation": "Deques allow efficient removal of elements that fall outside the sliding window from either end.",
              "difficulty": "hard",
              "topic": "queue"
            },
            {
              "id": "q54o",
              "type": "mcq",
              "question": "What is the time complexity of front and rear access operations in a deque?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
              "correctAnswer": "O(1)",
              "explanation": "Well-implemented deques provide constant time access to elements at both ends.",
              "difficulty": "medium",
              "topic": "queue"
            }
          ]
        },
        {
          "id": "advanced-queue-problems",
          "title": "Advanced Queue Problems",
          "description": "Complex problems and optimization techniques using queues",
          "xpReward": 80,
          "questions": [
            {
              "id": "q54p",
              "type": "mcq",
              "question": "In the task scheduling problem, what does a queue help optimize?",
              "options": ["Memory usage", "CPU utilization", "Waiting time and throughput", "Code complexity"],
              "correctAnswer": "Waiting time and throughput",
              "explanation": "Queues in scheduling help manage task order to optimize waiting times and system throughput.",
              "difficulty": "medium",
              "topic": "queue"
            },
            {
              "id": "q54q",
              "type": "fillInBlank",
              "question": "The _____ queue pattern allows multiple consumers to process tasks concurrently.",
              "correctAnswer": "producer-consumer",
              "explanation": "Producer-consumer pattern uses queues to decouple task production from consumption, enabling concurrency.",
              "difficulty": "medium",
              "topic": "queue"
            },
            {
              "id": "q54r",
              "type": "mcq",
              "question": "What is the optimal approach for implementing a queue with O(1) amortized operations using two stacks?",
              "options": ["Always use both stacks", "Transfer all elements on each operation", "Transfer elements only when needed", "Use stacks alternately"],
              "correctAnswer": "Transfer elements only when needed",
              "explanation": "Transfer elements from input stack to output stack only when output stack is empty, achieving amortized O(1).",
              "difficulty": "hard",
              "topic": "queue"
            },
            {
              "id": "q54s",
              "type": "mcq",
              "question": "In a circular buffer implementation, how do you detect if the queue is full vs empty when front equals rear?",
              "options": ["Impossible to detect", "Use a counter variable", "Check next element", "Use different pointers"],
              "correctAnswer": "Use a counter variable",
              "explanation": "A counter tracking the number of elements helps distinguish between full and empty states when pointers are equal.",
              "difficulty": "hard",
              "topic": "queue"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-5",
      "title": "Trees",
      "description": "Hierarchical data structures and tree algorithms",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "binary-trees",
          "title": "Binary Trees",
          "description": "Understanding tree structure and terminology",
          "xpReward": 70,
          "questions": [
            {
              "id": "q56",
              "type": "fillInBlank",
              "question": "In a binary tree, each node can have at most _____ children.",
              "correctAnswer": "two",
              "explanation": "Binary trees are restricted to having at most two children per node: left and right.",
              "difficulty": "easy",
              "topic": "trees"
            },
            {
              "id": "q57",
              "type": "mcq",
              "question": "What is the root of a tree?",
              "options": ["The last node", "The node with no parent", "The deepest node", "Any leaf node"],
              "correctAnswer": "The node with no parent",
              "explanation": "The root is the topmost node in a tree that has no parent node.",
              "difficulty": "easy",
              "topic": "trees"
            },
            {
              "id": "q57a",
              "type": "fillInBlank",
              "question": "Nodes with no children are called _____ nodes.",
              "correctAnswer": "leaf",
              "explanation": "Leaf nodes are terminal nodes that have no children.",
              "difficulty": "easy",
              "topic": "trees"
            }
          ]
        },
        {
          "id": "tree-traversal",
          "title": "Tree Traversal",
          "description": "Methods for visiting all nodes in a tree",
          "xpReward": 75,
          "questions": [
            {
              "id": "q58",
              "type": "mcq",
              "question": "In which traversal do you visit the root before its children?",
              "options": ["Inorder", "Preorder", "Postorder", "Level order"],
              "correctAnswer": "Preorder",
              "explanation": "Preorder traversal visits root first, then left subtree, then right subtree.",
              "difficulty": "medium",
              "topic": "trees"
            },
            {
              "id": "q58a",
              "type": "mcq",
              "question": "Which traversal visits nodes level by level from top to bottom?",
              "options": ["Inorder", "Preorder", "Postorder", "Level order"],
              "correctAnswer": "Level order",
              "explanation": "Level order traversal uses a queue to visit all nodes at each level before moving to the next level.",
              "difficulty": "medium",
              "topic": "trees"
            },
            {
              "id": "q58b",
              "type": "fillInBlank",
              "question": "Inorder traversal of a binary search tree visits nodes in _____ order.",
              "correctAnswer": "sorted",
              "explanation": "Inorder traversal of a BST visits nodes in ascending sorted order.",
              "difficulty": "medium",
              "topic": "trees"
            }
          ]
        },
        {
          "id": "binary-search-trees",
          "title": "Binary Search Trees",
          "description": "Efficient searching and insertion in trees",
          "xpReward": 80,
          "questions": [
            {
              "id": "q58c",
              "type": "mcq",
              "question": "What is the key property of a binary search tree?",
              "options": ["All nodes have two children", "Left child < parent < right child", "Tree is always balanced", "Maximum height is log n"],
              "correctAnswer": "Left child < parent < right child",
              "explanation": "In a BST, all values in the left subtree are less than the parent, and all values in the right subtree are greater.",
              "difficulty": "medium",
              "topic": "trees"
            },
            {
              "id": "q58d",
              "type": "mcq",
              "question": "What is the average time complexity for search in a balanced BST?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
              "correctAnswer": "O(log n)",
              "explanation": "Balanced BSTs allow elimination of half the search space at each step, resulting in O(log n) search time.",
              "difficulty": "medium",
              "topic": "trees"
            }
          ]
        },
        {
          "id": "balanced-trees",
          "title": "Balanced Trees",
          "description": "Self-balancing binary search trees and their properties",
          "xpReward": 85,
          "questions": [
            {
              "id": "q58e",
              "type": "mcq",
              "question": "What is the balance factor in an AVL tree?",
              "options": ["Height of left subtree", "Height of right subtree", "Difference between left and right subtree heights", "Total number of nodes"],
              "correctAnswer": "Difference between left and right subtree heights",
              "explanation": "AVL balance factor is the height difference between left and right subtrees, must be -1, 0, or 1.",
              "difficulty": "medium",
              "topic": "trees"
            },
            {
              "id": "q58f",
              "type": "fillInBlank",
              "question": "In a Red-Black tree, every path from root to leaf contains the same number of _____ nodes.",
              "correctAnswer": "black",
              "explanation": "Red-Black trees maintain the property that all root-to-leaf paths have equal numbers of black nodes.",
              "difficulty": "hard",
              "topic": "trees"
            },
            {
              "id": "q58g",
              "type": "mcq",
              "question": "What rotation is needed when a left-heavy AVL tree becomes more left-heavy?",
              "options": ["Left rotation", "Right rotation", "Left-Right rotation", "Right-Left rotation"],
              "correctAnswer": "Right rotation",
              "explanation": "A right rotation fixes the left-left case in AVL trees by rotating the problematic node to the right.",
              "difficulty": "hard",
              "topic": "trees"
            },
            {
              "id": "q58h",
              "type": "mcq",
              "question": "What is the worst-case time complexity for operations in a balanced BST?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
              "correctAnswer": "O(log n)",
              "explanation": "Balanced trees guarantee O(log n) height, ensuring all operations complete in logarithmic time.",
              "difficulty": "medium",
              "topic": "trees"
            }
          ]
        },
        {
          "id": "tree-algorithms",
          "title": "Tree Algorithms",
          "description": "Advanced algorithms for tree manipulation and analysis",
          "xpReward": 90,
          "questions": [
            {
              "id": "q58i",
              "type": "mcq",
              "question": "What algorithm is used to find the Lowest Common Ancestor (LCA) efficiently?",
              "options": ["DFS", "BFS", "Binary lifting", "Linear search"],
              "correctAnswer": "Binary lifting",
              "explanation": "Binary lifting preprocesses the tree to answer LCA queries in O(log n) time after O(n log n) preprocessing.",
              "difficulty": "hard",
              "topic": "trees"
            },
            {
              "id": "q58j",
              "type": "fillInBlank",
              "question": "Morris traversal achieves tree traversal in O(1) space by temporarily modifying _____ pointers.",
              "correctAnswer": "predecessor",
              "explanation": "Morris traversal uses threading by temporarily modifying predecessor pointers to enable constant space traversal.",
              "difficulty": "hard",
              "topic": "trees"
            },
            {
              "id": "q58k",
              "type": "mcq",
              "question": "What is the time complexity of converting a sorted array to a balanced BST?",
              "options": ["O(n)", "O(n log n)", "O(n²)", "O(log n)"],
              "correctAnswer": "O(n)",
              "explanation": "Each element is visited exactly once during the recursive construction, resulting in O(n) time.",
              "difficulty": "medium",
              "topic": "trees"
            },
            {
              "id": "q58l",
              "type": "mcq",
              "question": "In a tree serialization problem, what traversal uniquely identifies a binary tree structure?",
              "options": ["Preorder only", "Inorder only", "Preorder with null markers", "Level order only"],
              "correctAnswer": "Preorder with null markers",
              "explanation": "Preorder traversal with null markers for missing children can uniquely reconstruct the tree structure.",
              "difficulty": "hard",
              "topic": "trees"
            }
          ]
        },
        {
          "id": "advanced-tree-structures",
          "title": "Advanced Tree Structures",
          "description": "Specialized trees for specific applications",
          "xpReward": 95,
          "questions": [
            {
              "id": "q58m",
              "type": "mcq",
              "question": "What is the main advantage of a Trie (Prefix Tree) over hash maps for string operations?",
              "options": ["Faster insertion", "Prefix-based searches", "Less memory usage", "Better hash function"],
              "correctAnswer": "Prefix-based searches",
              "explanation": "Tries excel at prefix-based operations like autocomplete and finding all words with a given prefix.",
              "difficulty": "medium",
              "topic": "trees"
            },
            {
              "id": "q58n",
              "type": "fillInBlank",
              "question": "A Segment Tree allows range queries and updates in O(_____ ) time.",
              "correctAnswer": "log n",
              "explanation": "Segment trees support both range queries and range updates in O(log n) time complexity.",
              "difficulty": "hard",
              "topic": "trees"
            },
            {
              "id": "q58o",
              "type": "mcq",
              "question": "What type of tree is most efficient for range minimum/maximum queries?",
              "options": ["Binary search tree", "AVL tree", "Segment tree", "B-tree"],
              "correctAnswer": "Segment tree",
              "explanation": "Segment trees are specifically designed for efficient range queries like finding minimum or maximum in a range.",
              "difficulty": "hard",
              "topic": "trees"
            },
            {
              "id": "q58p",
              "type": "mcq",
              "question": "What is the space complexity of a typical Trie storing n strings of average length m?",
              "options": ["O(n)", "O(m)", "O(n*m)", "O(alphabet_size * n * m)"],
              "correctAnswer": "O(alphabet_size * n * m)",
              "explanation": "Trie space depends on alphabet size, number of strings, and their lengths, in worst case O(alphabet_size * n * m).",
              "difficulty": "hard",
              "topic": "trees"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-6",
      "title": "Graphs",
      "description": "Network data structures and graph algorithms",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "graph-basics",
          "title": "Graph Basics",
          "description": "Understanding vertices, edges, and graph types",
          "xpReward": 80,
          "questions": [
            {
              "id": "q59",
              "type": "fillInBlank",
              "question": "A graph consists of _____ (nodes) and edges (connections).",
              "correctAnswer": "vertices",
              "explanation": "Graphs are made up of vertices (nodes) connected by edges.",
              "difficulty": "easy",
              "topic": "graphs"
            },
            {
              "id": "q59a",
              "type": "mcq",
              "question": "What is the difference between directed and undirected graphs?",
              "options": ["Directed graphs are faster", "Directed edges have direction, undirected don't", "Undirected graphs use more memory", "No difference"],
              "correctAnswer": "Directed edges have direction, undirected don't",
              "explanation": "Directed graphs have edges with direction (A→B), while undirected graphs have bidirectional connections (A—B).",
              "difficulty": "medium",
              "topic": "graphs"
            },
            {
              "id": "q59b",
              "type": "fillInBlank",
              "question": "The number of edges connected to a vertex is called its _____.",
              "correctAnswer": "degree",
              "explanation": "The degree of a vertex is the number of edges incident to it.",
              "difficulty": "easy",
              "topic": "graphs"
            }
          ]
        },
        {
          "id": "graph-traversal",
          "title": "Graph Traversal",
          "description": "DFS and BFS algorithms for exploring graphs",
          "xpReward": 85,
          "questions": [
            {
              "id": "q59c",
              "type": "mcq",
              "question": "Which data structure is typically used for DFS (Depth-First Search)?",
              "options": ["Queue", "Stack", "Heap", "Hash Map"],
              "correctAnswer": "Stack",
              "explanation": "DFS uses a stack (or recursion which uses the call stack) to explore as deep as possible before backtracking.",
              "difficulty": "medium",
              "topic": "graphs"
            },
            {
              "id": "q59d",
              "type": "mcq",
              "question": "Which data structure is typically used for BFS (Breadth-First Search)?",
              "options": ["Queue", "Stack", "Heap", "Hash Map"],
              "correctAnswer": "Queue",
              "explanation": "BFS uses a queue to explore all neighbors at the current depth before moving to the next depth level.",
              "difficulty": "medium",
              "topic": "graphs"
            },
            {
              "id": "q59e",
              "type": "fillInBlank",
              "question": "BFS finds the _____ path between two vertices in an unweighted graph.",
              "correctAnswer": "shortest",
              "explanation": "BFS naturally finds the shortest path in unweighted graphs by exploring vertices level by level.",
              "difficulty": "medium",
              "topic": "graphs"
            }
          ]
        },
        {
          "id": "shortest-path",
          "title": "Shortest Path Algorithms",
          "description": "Finding optimal paths in weighted graphs",
          "xpReward": 90,
          "questions": [
            {
              "id": "q59f",
              "type": "mcq",
              "question": "Which algorithm is used for single-source shortest path in graphs with non-negative weights?",
              "options": ["Bellman-Ford", "Dijkstra's", "Floyd-Warshall", "DFS"],
              "correctAnswer": "Dijkstra's",
              "explanation": "Dijkstra's algorithm efficiently finds shortest paths from a single source when all edge weights are non-negative.",
              "difficulty": "medium",
              "topic": "graphs"
            },
            {
              "id": "q59g",
              "type": "fillInBlank",
              "question": "The Bellman-Ford algorithm can detect _____ weight cycles in a graph.",
              "correctAnswer": "negative",
              "explanation": "Bellman-Ford algorithm can detect negative weight cycles while finding shortest paths.",
              "difficulty": "medium",
              "topic": "graphs"
            },
            {
              "id": "q59h",
              "type": "mcq",
              "question": "What is the time complexity of Dijkstra's algorithm using a binary heap?",
              "options": ["O(V²)", "O(E log V)", "O(VE)", "O(V + E)"],
              "correctAnswer": "O(E log V)",
              "explanation": "With a binary heap, Dijkstra's algorithm runs in O(E log V) time where E is edges and V is vertices.",
              "difficulty": "hard",
              "topic": "graphs"
            },
            {
              "id": "q59i",
              "type": "mcq",
              "question": "Which algorithm finds shortest paths between all pairs of vertices?",
              "options": ["Dijkstra's", "Bellman-Ford", "Floyd-Warshall", "BFS"],
              "correctAnswer": "Floyd-Warshall",
              "explanation": "Floyd-Warshall algorithm computes shortest paths between all pairs of vertices in O(V³) time.",
              "difficulty": "medium",
              "topic": "graphs"
            }
          ]
        },
        {
          "id": "minimum-spanning-tree",
          "title": "Minimum Spanning Trees",
          "description": "Finding minimum cost trees that connect all vertices",
          "xpReward": 85,
          "questions": [
            {
              "id": "q59j",
              "type": "mcq",
              "question": "What is the main difference between Kruskal's and Prim's algorithms?",
              "options": ["Time complexity", "Kruskal is edge-based, Prim is vertex-based", "Kruskal works on directed graphs", "Prim requires sorted edges"],
              "correctAnswer": "Kruskal is edge-based, Prim is vertex-based",
              "explanation": "Kruskal's algorithm processes edges in sorted order, while Prim's grows the MST vertex by vertex.",
              "difficulty": "medium",
              "topic": "graphs"
            },
            {
              "id": "q59k",
              "type": "fillInBlank",
              "question": "Kruskal's algorithm uses a _____ data structure to detect cycles efficiently.",
              "correctAnswer": "union-find",
              "explanation": "Union-find (disjoint set) data structure efficiently detects cycles when adding edges in Kruskal's algorithm.",
              "difficulty": "medium",
              "topic": "graphs"
            },
            {
              "id": "q59l",
              "type": "mcq",
              "question": "What is the time complexity of Kruskal's algorithm?",
              "options": ["O(V log V)", "O(E log E)", "O(VE)", "O(V + E)"],
              "correctAnswer": "O(E log E)",
              "explanation": "Kruskal's algorithm complexity is dominated by sorting edges, which takes O(E log E) time.",
              "difficulty": "medium",
              "topic": "graphs"
            },
            {
              "id": "q59m",
              "type": "mcq",
              "question": "A minimum spanning tree of a graph with V vertices has how many edges?",
              "options": ["V", "V-1", "V+1", "2V"],
              "correctAnswer": "V-1",
              "explanation": "Any spanning tree of a connected graph with V vertices must have exactly V-1 edges.",
              "difficulty": "easy",
              "topic": "graphs"
            }
          ]
        },
        {
          "id": "topological-sorting",
          "title": "Topological Sorting",
          "description": "Ordering vertices in directed acyclic graphs",
          "xpReward": 80,
          "questions": [
            {
              "id": "q59n",
              "type": "mcq",
              "question": "Topological sorting is only possible in which type of graphs?",
              "options": ["Undirected graphs", "Directed acyclic graphs (DAG)", "Complete graphs", "Bipartite graphs"],
              "correctAnswer": "Directed acyclic graphs (DAG)",
              "explanation": "Topological sorting is only possible in directed acyclic graphs where no cycles exist.",
              "difficulty": "medium",
              "topic": "graphs"
            },
            {
              "id": "q59o",
              "type": "fillInBlank",
              "question": "In Kahn's algorithm for topological sorting, vertices with _____ in-degree are processed first.",
              "correctAnswer": "zero",
              "explanation": "Kahn's algorithm repeatedly removes vertices with zero in-degree to generate topological order.",
              "difficulty": "medium",
              "topic": "graphs"
            },
            {
              "id": "q59p",
              "type": "mcq",
              "question": "What is a common application of topological sorting?",
              "options": ["Finding shortest paths", "Course scheduling with prerequisites", "Finding cycles", "Graph coloring"],
              "correctAnswer": "Course scheduling with prerequisites",
              "explanation": "Topological sorting is commonly used for scheduling tasks with dependencies, like course prerequisites.",
              "difficulty": "easy",
              "topic": "graphs"
            },
            {
              "id": "q59q",
              "type": "mcq",
              "question": "What happens when Kahn's algorithm cannot find a vertex with zero in-degree?",
              "options": ["Algorithm completes", "Graph has a cycle", "Algorithm restarts", "Need more memory"],
              "correctAnswer": "Graph has a cycle",
              "explanation": "If no vertex with zero in-degree exists during processing, the graph contains a cycle.",
              "difficulty": "medium",
              "topic": "graphs"
            }
          ]
        },
        {
          "id": "advanced-graph-algorithms",
          "title": "Advanced Graph Algorithms",
          "description": "Complex graph problems and specialized algorithms",
          "xpReward": 95,
          "questions": [
            {
              "id": "q59r",
              "type": "mcq",
              "question": "What is the purpose of strongly connected components (SCCs) in directed graphs?",
              "options": ["Find shortest paths", "Identify mutually reachable vertices", "Detect bipartite graphs", "Find minimum cuts"],
              "correctAnswer": "Identify mutually reachable vertices",
              "explanation": "SCCs group vertices that can reach each other through directed paths in both directions.",
              "difficulty": "hard",
              "topic": "graphs"
            },
            {
              "id": "q59s",
              "type": "fillInBlank",
              "question": "Tarjan's algorithm finds strongly connected components using _____ traversal.",
              "correctAnswer": "DFS",
              "explanation": "Tarjan's algorithm uses DFS traversal with low-link values to identify SCCs in a single pass.",
              "difficulty": "hard",
              "topic": "graphs"
            },
            {
              "id": "q59t",
              "type": "mcq",
              "question": "What is the maximum flow problem trying to optimize?",
              "options": ["Minimum path length", "Maximum number of paths", "Maximum flow from source to sink", "Minimum number of edges"],
              "correctAnswer": "Maximum flow from source to sink",
              "explanation": "Maximum flow problem finds the maximum amount of flow that can be sent from source to sink.",
              "difficulty": "medium",
              "topic": "graphs"
            },
            {
              "id": "q59u",
              "type": "mcq",
              "question": "Which algorithm solves the maximum bipartite matching problem efficiently?",
              "options": ["Dijkstra's", "Kruskal's", "Hungarian algorithm", "Bellman-Ford"],
              "correctAnswer": "Hungarian algorithm",
              "explanation": "The Hungarian algorithm efficiently solves maximum bipartite matching and assignment problems.",
              "difficulty": "hard",
              "topic": "graphs"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-7", 
      "title": "Sorting I",
      "description": "Simple O(n²) sorting algorithms",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "bubble-sort",
          "title": "Bubble Sort",
          "description": "Understanding the simplest sorting algorithm",
          "xpReward": 50,
          "questions": [
            {
              "id": "q60",
              "type": "mcq",
              "question": "What is the time complexity of bubble sort?",
              "options": ["O(n)", "O(n log n)", "O(n²)", "O(log n)"],
              "correctAnswer": "O(n²)",
              "explanation": "Bubble sort has O(n²) time complexity due to nested loops comparing adjacent elements.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q60a",
              "type": "fillInBlank",
              "question": "Bubble sort repeatedly compares _____ elements and swaps them if needed.",
              "correctAnswer": "adjacent",
              "explanation": "Bubble sort compares each pair of adjacent elements and swaps them if they are in wrong order.",
              "difficulty": "easy",
              "topic": "sorting"
            }
          ]
        },
        {
          "id": "selection-sort",
          "title": "Selection Sort",
          "description": "Sorting by repeatedly finding the minimum element",
          "xpReward": 55,
          "questions": [
            {
              "id": "q60b",
              "type": "mcq",
              "question": "How does selection sort work?",
              "options": ["Swaps adjacent elements", "Finds minimum and places it at beginning", "Divides array in half", "Uses a pivot element"],
              "correctAnswer": "Finds minimum and places it at beginning",
              "explanation": "Selection sort repeatedly finds the minimum element from unsorted portion and places it at the beginning.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q60c",
              "type": "mcq",
              "question": "What is the time complexity of selection sort?",
              "options": ["O(n)", "O(n log n)", "O(n²)", "O(log n)"],
              "correctAnswer": "O(n²)",
              "explanation": "Selection sort has O(n²) time complexity as it performs nested loops to find minimum elements.",
              "difficulty": "medium",
              "topic": "sorting"
            }
          ]
        },
        {
          "id": "insertion-sort",
          "title": "Insertion Sort", 
          "description": "Building sorted array one element at a time",
          "xpReward": 60,
          "questions": [
            {
              "id": "q60d",
              "type": "mcq",
              "question": "How does insertion sort build the final sorted array?",
              "options": ["By finding minimum elements", "By inserting each element in its correct position", "By swapping adjacent elements", "By dividing the array"],
              "correctAnswer": "By inserting each element in its correct position",
              "explanation": "Insertion sort builds the sorted array by taking each element and inserting it in the correct position among previously sorted elements.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q60e",
              "type": "fillInBlank",
              "question": "Insertion sort is efficient for _____ datasets.",
              "correctAnswer": "small",
              "explanation": "Insertion sort performs well on small datasets due to its simple implementation and low overhead.",
              "difficulty": "easy",
              "topic": "sorting"
            }
          ]
        },
        {
          "id": "sorting-analysis",
          "title": "Sorting Analysis",
          "description": "Comparing simple sorting algorithms and their performance",
          "xpReward": 65,
          "questions": [
            {
              "id": "q60f",
              "type": "mcq",
              "question": "Which simple sorting algorithm has the best best-case time complexity?",
              "options": ["Bubble sort", "Selection sort", "Insertion sort", "All are the same"],
              "correctAnswer": "Insertion sort",
              "explanation": "Insertion sort has O(n) best-case complexity when the array is already sorted, while others remain O(n²).",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q60g",
              "type": "fillInBlank",
              "question": "Selection sort makes exactly _____ swaps for an array of n elements.",
              "correctAnswer": "n-1",
              "explanation": "Selection sort performs exactly n-1 swaps, one for each position except the last.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q60h",
              "type": "mcq",
              "question": "Which sorting algorithm is stable among the simple O(n²) sorts?",
              "options": ["Selection sort", "Bubble sort", "Shell sort", "Heap sort"],
              "correctAnswer": "Bubble sort",
              "explanation": "Bubble sort is stable as it only swaps adjacent elements when they are in wrong order, preserving relative order of equal elements.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q60i",
              "type": "mcq",
              "question": "What is the space complexity of bubble sort?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
              "correctAnswer": "O(1)",
              "explanation": "Bubble sort is an in-place algorithm using only constant extra space for temporary variables.",
              "difficulty": "easy",
              "topic": "sorting"
            }
          ]
        },
        {
          "id": "adaptive-sorting",
          "title": "Adaptive Sorting",
          "description": "Algorithms that perform better on partially sorted data",
          "xpReward": 70,
          "questions": [
            {
              "id": "q60j",
              "type": "mcq",
              "question": "What makes a sorting algorithm adaptive?",
              "options": ["Uses less memory", "Performs better on nearly sorted data", "Works on any data type", "Has stable behavior"],
              "correctAnswer": "Performs better on nearly sorted data",
              "explanation": "Adaptive algorithms take advantage of existing order in the data to perform better than their worst-case complexity.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q60k",
              "type": "fillInBlank",
              "question": "Tim sort is an adaptive sorting algorithm used in Python's built-in _____ function.",
              "correctAnswer": "sort",
              "explanation": "Tim sort is the algorithm behind Python's built-in sort() and sorted() functions.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q60l",
              "type": "mcq",
              "question": "Which simple sorting algorithm adapts best to partially sorted arrays?",
              "options": ["Bubble sort", "Selection sort", "Insertion sort", "Shell sort"],
              "correctAnswer": "Insertion sort",
              "explanation": "Insertion sort performs very well on partially sorted arrays, approaching O(n) time complexity.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q60m",
              "type": "mcq",
              "question": "What optimization can make bubble sort adaptive?",
              "options": ["Use recursion", "Stop early if no swaps occur", "Use binary search", "Sort in reverse"],
              "correctAnswer": "Stop early if no swaps occur",
              "explanation": "If no swaps occur in a complete pass, the array is sorted and the algorithm can terminate early.",
              "difficulty": "medium",
              "topic": "sorting"
            }
          ]
        },
        {
          "id": "counting-sort",
          "title": "Counting Sort",
          "description": "Non-comparison based sorting for specific data ranges",
          "xpReward": 75,
          "questions": [
            {
              "id": "q60n",
              "type": "mcq",
              "question": "What is the time complexity of counting sort?",
              "options": ["O(n log n)", "O(n + k)", "O(n²)", "O(k log n)"],
              "correctAnswer": "O(n + k)",
              "explanation": "Counting sort runs in O(n + k) time where n is the number of elements and k is the range of input.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q60o",
              "type": "fillInBlank",
              "question": "Counting sort works best when the range of possible values (k) is _____ compared to the number of elements (n).",
              "correctAnswer": "small",
              "explanation": "Counting sort is efficient when k (range) is not significantly larger than n (number of elements).",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q60p",
              "type": "mcq",
              "question": "What is the main limitation of counting sort?",
              "options": ["Unstable sorting", "High time complexity", "Requires knowing the range of values", "Uses recursion"],
              "correctAnswer": "Requires knowing the range of values",
              "explanation": "Counting sort needs to know the range of possible input values to create the counting array.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q60q",
              "type": "mcq",
              "question": "Is counting sort a stable sorting algorithm?",
              "options": ["Yes, always", "No, never", "Depends on implementation", "Only for positive numbers"],
              "correctAnswer": "Yes, always",
              "explanation": "Counting sort is stable when implemented correctly, preserving the relative order of equal elements.",
              "difficulty": "medium",
              "topic": "sorting"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-8",
      "title": "Sorting II",
      "description": "Efficient O(n log n) sorting algorithms",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "merge-sort",
          "title": "Merge Sort",
          "description": "Divide and conquer sorting approach",
          "xpReward": 70,
          "questions": [
            {
              "id": "q61",
              "type": "mcq",
              "question": "What is the time complexity of merge sort?",
              "options": ["O(n)", "O(n log n)", "O(n²)", "O(log n)"],
              "correctAnswer": "O(n log n)",
              "explanation": "Merge sort consistently runs in O(n log n) time using divide and conquer.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q61a",
              "type": "mcq",
              "question": "What is the key principle behind merge sort?",
              "options": ["Bubble elements up", "Divide and conquer", "Find pivot element", "Select minimum"],
              "correctAnswer": "Divide and conquer",
              "explanation": "Merge sort divides the array into smaller subarrays, sorts them, then merges them back together.",
              "difficulty": "medium",
              "topic": "sorting"
            }
          ]
        },
        {
          "id": "quick-sort",
          "title": "Quick Sort",
          "description": "Efficient in-place sorting algorithm",
          "xpReward": 75,
          "questions": [
            {
              "id": "q62",
              "type": "fillInBlank",
              "question": "Quick sort uses a _____ element to partition the array.",
              "correctAnswer": "pivot",
              "explanation": "Quick sort selects a pivot element and partitions the array around it.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q62a",
              "type": "mcq",
              "question": "What is the average time complexity of quick sort?",
              "options": ["O(n)", "O(n log n)", "O(n²)", "O(log n)"],
              "correctAnswer": "O(n log n)",
              "explanation": "Quick sort has average case O(n log n) time complexity with good pivot selection.",
              "difficulty": "medium",
              "topic": "sorting"
            }
          ]
        },
        {
          "id": "heap-sort",
          "title": "Heap Sort",
          "description": "Sorting using heap data structure",
          "xpReward": 80,
          "questions": [
            {
              "id": "q62b",
              "type": "mcq",
              "question": "What data structure does heap sort use?",
              "options": ["Stack", "Queue", "Binary heap", "Hash table"],
              "correctAnswer": "Binary heap",
              "explanation": "Heap sort uses a binary heap to efficiently find and remove the maximum/minimum element.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q62c",
              "type": "mcq",
              "question": "What is the time complexity of heap sort?",
              "options": ["O(n)", "O(n log n)", "O(n²)", "O(log n)"],
              "correctAnswer": "O(n log n)",
              "explanation": "Heap sort consistently runs in O(n log n) time for building heap and extracting elements.",
              "difficulty": "medium",
              "topic": "sorting"
            }
          ]
        },
        {
          "id": "divide-conquer-analysis",
          "title": "Divide & Conquer Analysis",
          "description": "Understanding the mathematics behind efficient sorting",
          "xpReward": 85,
          "questions": [
            {
              "id": "q62d",
              "type": "mcq",
              "question": "What is the recurrence relation for merge sort's time complexity?",
              "options": ["T(n) = T(n/2) + O(n)", "T(n) = 2T(n/2) + O(n)", "T(n) = 2T(n/2) + O(1)", "T(n) = T(n-1) + O(n)"],
              "correctAnswer": "T(n) = 2T(n/2) + O(n)",
              "explanation": "Merge sort divides into two halves (2T(n/2)) and merges them in linear time (O(n)).",
              "difficulty": "hard",
              "topic": "sorting"
            },
            {
              "id": "q62e",
              "type": "fillInBlank",
              "question": "The Master Theorem can be used to solve recurrence relations of the form T(n) = aT(n/b) + _____.",
              "correctAnswer": "f(n)",
              "explanation": "Master Theorem solves recurrences T(n) = aT(n/b) + f(n) where f(n) is the work done at each level.",
              "difficulty": "hard",
              "topic": "sorting"
            },
            {
              "id": "q62f",
              "type": "mcq",
              "question": "Why is quicksort's average case O(n log n) but worst case O(n²)?",
              "options": ["Bad implementation", "Poor pivot selection", "Memory limitations", "Compiler optimization"],
              "correctAnswer": "Poor pivot selection",
              "explanation": "If pivot is always the smallest/largest element, quicksort degrades to O(n²) due to unbalanced partitions.",
              "difficulty": "hard",
              "topic": "sorting"
            },
            {
              "id": "q62g",
              "type": "mcq",
              "question": "What makes merge sort consistently O(n log n) regardless of input?",
              "options": ["Always divides evenly", "Uses extra memory", "Better pivot selection", "In-place operation"],
              "correctAnswer": "Always divides evenly",
              "explanation": "Merge sort always divides the array into equal halves, ensuring balanced recursion tree.",
              "difficulty": "medium",
              "topic": "sorting"
            }
          ]
        },
        {
          "id": "hybrid-sorting",
          "title": "Hybrid Sorting Algorithms",
          "description": "Combining multiple sorting techniques for optimal performance",
          "xpReward": 90,
          "questions": [
            {
              "id": "q62h",
              "type": "mcq",
              "question": "What strategy does Introsort (introspective sort) use?",
              "options": ["Always use quicksort", "Start with heapsort", "Switch from quicksort to heapsort if recursion gets too deep", "Randomly choose algorithm"],
              "correctAnswer": "Switch from quicksort to heapsort if recursion gets too deep",
              "explanation": "Introsort begins with quicksort but switches to heapsort when recursion depth exceeds 2*log(n) to avoid O(n²) behavior.",
              "difficulty": "hard",
              "topic": "sorting"
            },
            {
              "id": "q62i",
              "type": "fillInBlank",
              "question": "Timsort combines _____ sort and merge sort to achieve excellent performance on real-world data.",
              "correctAnswer": "insertion",
              "explanation": "Timsort uses insertion sort for small runs and merge sort for combining runs efficiently.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q62j",
              "type": "mcq",
              "question": "When does a hybrid sorting algorithm typically switch to insertion sort?",
              "options": ["Never", "For arrays smaller than 10-50 elements", "Only for sorted arrays", "When memory is low"],
              "correctAnswer": "For arrays smaller than 10-50 elements",
              "explanation": "Insertion sort's low overhead makes it faster than complex algorithms for small subarrays.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q62k",
              "type": "mcq",
              "question": "What is the main advantage of hybrid sorting algorithms?",
              "options": ["Simpler code", "Combine benefits of different algorithms", "Use less memory", "Always stable"],
              "correctAnswer": "Combine benefits of different algorithms",
              "explanation": "Hybrid algorithms leverage strengths of different sorting methods for various input characteristics.",
              "difficulty": "medium",
              "topic": "sorting"
            }
          ]
        },
        {
          "id": "external-sorting",
          "title": "External Sorting",
          "description": "Sorting data that doesn't fit in memory",
          "xpReward": 95,
          "questions": [
            {
              "id": "q62l",
              "type": "mcq",
              "question": "What is the main challenge in external sorting?",
              "options": ["Data doesn't fit in memory", "Slow processors", "Network latency", "Power consumption"],
              "correctAnswer": "Data doesn't fit in memory",
              "explanation": "External sorting deals with datasets too large to fit entirely in RAM, requiring disk-based algorithms.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q62m",
              "type": "fillInBlank",
              "question": "External merge sort divides large files into smaller _____ that can fit in memory.",
              "correctAnswer": "runs",
              "explanation": "External merge sort creates sorted runs that fit in memory, then merges them using k-way merging.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q62n",
              "type": "mcq",
              "question": "What data structure is commonly used in k-way merging for external sorting?",
              "options": ["Stack", "Queue", "Min heap", "Hash table"],
              "correctAnswer": "Min heap",
              "explanation": "A min heap efficiently maintains the smallest elements from k sorted runs during merging.",
              "difficulty": "hard",
              "topic": "sorting"
            },
            {
              "id": "q62o",
              "type": "mcq",
              "question": "Why is disk I/O the bottleneck in external sorting?",
              "options": ["CPU is too fast", "Disk access is much slower than memory", "Network congestion", "Limited bandwidth"],
              "correctAnswer": "Disk access is much slower than memory",
              "explanation": "Disk I/O is orders of magnitude slower than memory access, making it the limiting factor.",
              "difficulty": "easy",
              "topic": "sorting"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-9",
      "title": "Greedy",
      "description": "Making locally optimal choices for global solutions",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "greedy-basics",
          "title": "Basics",
          "description": "Understanding the greedy approach and when to use it",
          "xpReward": 65,
          "questions": [
            {
              "id": "q65",
              "type": "mcq",
              "question": "What is the key principle of greedy algorithms?",
              "options": ["Try all possible solutions", "Make locally optimal choices", "Use dynamic programming", "Divide and conquer"],
              "correctAnswer": "Make locally optimal choices",
              "explanation": "Greedy algorithms make the best local choice at each step, hoping to find a global optimum.",
              "difficulty": "medium",
              "topic": "greedy"
            },
            {
              "id": "q66",
              "type": "fillInBlank",
              "question": "Greedy algorithms don't always guarantee the _____ solution.",
              "correctAnswer": "optimal",
              "explanation": "Greedy algorithms may not always find the globally optimal solution, only locally optimal ones.",
              "difficulty": "medium",
              "topic": "greedy"
            },
            {
              "id": "q67",
              "type": "mcq",
              "question": "What is a key advantage of greedy algorithms?",
              "options": ["Always find optimal solution", "Simple and efficient", "Work for all problems", "Use minimal memory"],
              "correctAnswer": "Simple and efficient",
              "explanation": "Greedy algorithms are typically simple to implement and have good time complexity.",
              "difficulty": "easy",
              "topic": "greedy"
            }
          ]
        },
        {
          "id": "activity-selection",
          "title": "Activity Selection",
          "description": "Classic greedy problem of selecting maximum activities",
          "xpReward": 70,
          "questions": [
            {
              "id": "q68",
              "type": "mcq",
              "question": "In the activity selection problem, what is the greedy choice?",
              "options": ["Select longest activity", "Select activity that starts earliest", "Select activity that finishes earliest", "Select most profitable activity"],
              "correctAnswer": "Select activity that finishes earliest",
              "explanation": "Selecting the activity that finishes earliest leaves maximum room for subsequent activities.",
              "difficulty": "medium",
              "topic": "greedy"
            },
            {
              "id": "q69",
              "type": "fillInBlank",
              "question": "Activity selection problem aims to select maximum number of _____ activities.",
              "correctAnswer": "non-overlapping",
              "explanation": "The goal is to select the maximum number of activities that don't overlap in time.",
              "difficulty": "easy",
              "topic": "greedy"
            }
          ]
        },
        {
          "id": "huffman-coding",
          "title": "Huffman Coding",
          "description": "Optimal prefix-free codes using greedy approach",
          "xpReward": 80,
          "questions": [
            {
              "id": "q70",
              "type": "mcq",
              "question": "What does Huffman coding optimize?",
              "options": ["Memory usage", "Code length based on frequency", "Processing speed", "Security"],
              "correctAnswer": "Code length based on frequency",
              "explanation": "Huffman coding assigns shorter codes to more frequent characters, minimizing total code length.",
              "difficulty": "medium",
              "topic": "greedy"
            },
            {
              "id": "q71",
              "type": "fillInBlank",
              "question": "Huffman coding uses a _____ tree to assign codes to characters.",
              "correctAnswer": "binary",
              "explanation": "Huffman coding builds a binary tree where paths from root to leaves represent character codes.",
              "difficulty": "medium",
              "topic": "greedy"
            }
          ]
        },
        {
          "id": "interval-scheduling",
          "title": "Interval Scheduling",
          "description": "Selecting maximum number of non-overlapping intervals",
          "xpReward": 85,
          "questions": [
            {
              "id": "q69a",
              "type": "mcq",
              "question": "In the interval scheduling problem, what greedy choice leads to an optimal solution?",
              "options": ["Select shortest intervals first", "Select intervals with earliest finish time", "Select intervals with latest start time", "Select intervals with maximum profit"],
              "correctAnswer": "Select intervals with earliest finish time",
              "explanation": "Selecting intervals by earliest finish time leaves the most room for future intervals, proving optimal.",
              "difficulty": "medium",
              "topic": "greedy"
            },
            {
              "id": "q69b",
              "type": "fillInBlank",
              "question": "The interval scheduling algorithm sorts intervals by _____ time and greedily selects compatible intervals.",
              "correctAnswer": "finish",
              "explanation": "Sorting by finish time allows the greedy algorithm to maximize the number of selected intervals.",
              "difficulty": "medium",
              "topic": "greedy"
            },
            {
              "id": "q69c",
              "type": "mcq",
              "question": "What is the time complexity of the interval scheduling algorithm?",
              "options": ["O(n)", "O(n log n)", "O(n²)", "O(2ⁿ)"],
              "correctAnswer": "O(n log n)",
              "explanation": "The algorithm requires O(n log n) time for sorting, followed by O(n) time for greedy selection.",
              "difficulty": "medium",
              "topic": "greedy"
            },
            {
              "id": "q69d",
              "type": "mcq",
              "question": "Which of these problems can be solved optimally using a greedy approach similar to interval scheduling?",
              "options": ["Fractional knapsack", "0/1 knapsack", "Traveling salesman", "Subset sum"],
              "correctAnswer": "Fractional knapsack",
              "explanation": "Fractional knapsack can be solved optimally by greedily selecting items by value-to-weight ratio.",
              "difficulty": "hard",
              "topic": "greedy"
            }
          ]
        },
        {
          "id": "greedy-graph-algorithms",
          "title": "Greedy Graph Algorithms",
          "description": "Minimum spanning trees and shortest paths",
          "xpReward": 90,
          "questions": [
            {
              "id": "q70a",
              "type": "mcq",
              "question": "Which algorithm uses a greedy approach to find minimum spanning trees?",
              "options": ["Bellman-Ford", "Floyd-Warshall", "Kruskal's algorithm", "Topological sort"],
              "correctAnswer": "Kruskal's algorithm",
              "explanation": "Kruskal's algorithm greedily adds the smallest weight edge that doesn't create a cycle.",
              "difficulty": "medium",
              "topic": "greedy"
            },
            {
              "id": "q70b",
              "type": "fillInBlank",
              "question": "Prim's algorithm builds a minimum spanning tree by starting with a vertex and greedily adding the _____ weight edge to the tree.",
              "correctAnswer": "minimum",
              "explanation": "Prim's algorithm maintains a growing tree and adds the minimum weight edge connecting the tree to a new vertex.",
              "difficulty": "medium",
              "topic": "greedy"
            },
            {
              "id": "q70c",
              "type": "mcq",
              "question": "What data structure does Dijkstra's algorithm typically use for efficient implementation?",
              "options": ["Stack", "Queue", "Priority queue", "Hash table"],
              "correctAnswer": "Priority queue",
              "explanation": "Dijkstra's algorithm uses a priority queue to efficiently extract the vertex with minimum distance.",
              "difficulty": "medium",
              "topic": "greedy"
            },
            {
              "id": "q70d",
              "type": "mcq",
              "question": "Why does Dijkstra's algorithm fail with negative edge weights?",
              "options": ["It becomes too slow", "It uses too much memory", "The greedy choice becomes suboptimal", "It cannot handle negative numbers"],
              "correctAnswer": "The greedy choice becomes suboptimal",
              "explanation": "With negative weights, choosing the current shortest path may not lead to the global optimum due to negative cycles.",
              "difficulty": "hard",
              "topic": "greedy"
            }
          ]
        },
        {
          "id": "greedy-optimization",
          "title": "Advanced Greedy Techniques",
          "description": "Huffman coding and exchange arguments",
          "xpReward": 95,
          "questions": [
            {
              "id": "q71a",
              "type": "mcq",
              "question": "What principle does Huffman coding use to create optimal prefix codes?",
              "options": ["Merge least frequent symbols first", "Merge most frequent symbols first", "Merge symbols randomly", "Merge symbols alphabetically"],
              "correctAnswer": "Merge least frequent symbols first",
              "explanation": "Huffman coding greedily merges the two least frequent symbols to minimize expected code length.",
              "difficulty": "hard",
              "topic": "greedy"
            },
            {
              "id": "q71b",
              "type": "fillInBlank",
              "question": "An _____ argument is used to prove that a greedy algorithm produces an optimal solution by showing any optimal solution can be transformed into the greedy solution.",
              "correctAnswer": "exchange",
              "explanation": "Exchange arguments prove optimality by showing that swapping elements in any optimal solution with greedy choices maintains optimality.",
              "difficulty": "hard",
              "topic": "greedy"
            },
            {
              "id": "q71c",
              "type": "mcq",
              "question": "In the coin change problem with standard denominations, why does the greedy algorithm work?",
              "options": ["Coins have equal value", "Denominatations form a canonical system", "There are infinite coins", "Algorithm is always optimal"],
              "correctAnswer": "Denominatations form a canonical system",
              "explanation": "Standard coin systems are canonical, meaning the greedy approach (largest denomination first) always gives minimum coins.",
              "difficulty": "hard",
              "topic": "greedy"
            },
            {
              "id": "q71d",
              "type": "mcq",
              "question": "What makes a problem suitable for a greedy approach?",
              "options": ["It has overlapping subproblems", "It exhibits optimal substructure and greedy choice property", "It can be solved recursively", "It has exponential solutions"],
              "correctAnswer": "It exhibits optimal substructure and greedy choice property",
              "explanation": "Greedy algorithms work when problems have optimal substructure and the greedy choice property holds.",
              "difficulty": "hard",
              "topic": "greedy"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-10",
      "title": "Dynamic Programming",
      "description": "Optimizing recursive problems with memoization",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "dp-basics",
          "title": "Basics",
          "description": "Understanding overlapping subproblems and optimal substructure",
          "xpReward": 80,
          "questions": [
            {
              "id": "q63",
              "type": "mcq",
              "question": "What are the two key properties of dynamic programming problems?",
              "options": ["Fast and efficient", "Overlapping subproblems and optimal substructure", "Recursive and iterative", "Simple and complex"],
              "correctAnswer": "Overlapping subproblems and optimal substructure",
              "explanation": "DP problems must have overlapping subproblems and optimal substructure to benefit from memoization.",
              "difficulty": "hard",
              "topic": "dp"
            }
          ]
        },
        {
          "id": "fibonacci-dp",
          "title": "Fibonacci DP",
          "description": "Classic example of dynamic programming optimization",
          "xpReward": 60,
          "questions": [
            {
              "id": "q64",
              "type": "fillInBlank",
              "question": "Memoized fibonacci reduces time complexity from O(2^n) to O(_____)",
              "correctAnswer": "n",
              "explanation": "Memoization eliminates redundant calculations, reducing time complexity to linear O(n).",
              "difficulty": "medium",
              "topic": "dp"
            }
          ]
        },
        {
          "id": "classic-dp-problems",
          "title": "Classic DP Problems",
          "description": "Longest Common Subsequence and Edit Distance",
          "xpReward": 85,
          "questions": [
            {
              "id": "q74a",
              "type": "mcq",
              "question": "In the Longest Common Subsequence (LCS) problem, what does dp[i][j] typically represent?",
              "options": ["Length of string i up to j", "LCS length of first i chars of string1 and first j chars of string2", "Number of mismatches", "Total string length"],
              "correctAnswer": "LCS length of first i chars of string1 and first j chars of string2",
              "explanation": "The DP table stores the length of the LCS for prefixes of both input strings.",
              "difficulty": "medium",
              "topic": "dynamic_programming"
            },
            {
              "id": "q74b",
              "type": "fillInBlank",
              "question": "The edit distance between two strings is the minimum number of _____, insertions, and deletions needed to transform one string into another.",
              "correctAnswer": "substitutions",
              "explanation": "Edit distance (Levenshtein distance) counts substitutions, insertions, and deletions as basic operations.",
              "difficulty": "medium",
              "topic": "dynamic_programming"
            },
            {
              "id": "q74c",
              "type": "mcq",
              "question": "What is the time complexity of the standard DP solution for LCS of two strings of length m and n?",
              "options": ["O(m)", "O(n)", "O(m*n)", "O(m^n)"],
              "correctAnswer": "O(m*n)",
              "explanation": "The DP table has m*n entries, and each entry takes constant time to compute.",
              "difficulty": "medium",
              "topic": "dynamic_programming"
            },
            {
              "id": "q74d",
              "type": "mcq",
              "question": "Which problem is equivalent to finding the minimum edit distance?",
              "options": ["Longest path problem", "Shortest path in a grid", "Maximum flow", "Traveling salesman"],
              "correctAnswer": "Shortest path in a grid",
              "explanation": "Edit distance can be viewed as finding the shortest path in a grid where moves represent edit operations.",
              "difficulty": "hard",
              "topic": "dynamic_programming"
            }
          ]
        },
        {
          "id": "knapsack-variants",
          "title": "Knapsack Problem Variants",
          "description": "0/1 knapsack, unbounded knapsack, and variations",
          "xpReward": 90,
          "questions": [
            {
              "id": "q75a",
              "type": "mcq",
              "question": "What's the key difference between 0/1 knapsack and unbounded knapsack?",
              "options": ["Weight constraints", "Number of items available", "Profit calculation", "Algorithm complexity"],
              "correctAnswer": "Number of items available",
              "explanation": "In 0/1 knapsack each item can be used at most once, while unbounded knapsack allows unlimited use of each item.",
              "difficulty": "medium",
              "topic": "dynamic_programming"
            },
            {
              "id": "q75b",
              "type": "fillInBlank",
              "question": "In the 0/1 knapsack problem, for each item we make a _____ choice: include it or exclude it.",
              "correctAnswer": "binary",
              "explanation": "The name '0/1 knapsack' comes from the binary choice of taking 0 or 1 copy of each item.",
              "difficulty": "easy",
              "topic": "dynamic_programming"
            },
            {
              "id": "q75c",
              "type": "mcq",
              "question": "What is the space complexity of the standard DP solution for 0/1 knapsack with n items and capacity W?",
              "options": ["O(n)", "O(W)", "O(n*W)", "O(2^n)"],
              "correctAnswer": "O(n*W)",
              "explanation": "The DP table has dimensions n×W to store the maximum value for each item and capacity combination.",
              "difficulty": "medium",
              "topic": "dynamic_programming"
            },
            {
              "id": "q75d",
              "type": "mcq",
              "question": "Which optimization can reduce the space complexity of 0/1 knapsack to O(W)?",
              "options": ["Memoization", "Rolling array technique", "Greedy approach", "Binary search"],
              "correctAnswer": "Rolling array technique",
              "explanation": "Since we only need the previous row to compute the current row, we can use two 1D arrays instead of a 2D table.",
              "difficulty": "hard",
              "topic": "dynamic_programming"
            }
          ]
        },
        {
          "id": "dp-optimization",
          "title": "DP Optimization Techniques",
          "description": "Memoization, bottom-up vs top-down, and space optimization",
          "xpReward": 95,
          "questions": [
            {
              "id": "q76a",
              "type": "mcq",
              "question": "What is the main advantage of memoization over naive recursion?",
              "options": ["Simpler code", "Less memory usage", "Avoids recomputing subproblems", "Faster base case handling"],
              "correctAnswer": "Avoids recomputing subproblems",
              "explanation": "Memoization stores results of subproblems to avoid redundant computations in recursive solutions.",
              "difficulty": "medium",
              "topic": "dynamic_programming"
            },
            {
              "id": "q76b",
              "type": "fillInBlank",
              "question": "A _____ approach builds solutions from the smallest subproblems up to the original problem.",
              "correctAnswer": "bottom-up",
              "explanation": "Bottom-up DP starts with base cases and iteratively builds larger solutions, avoiding recursion overhead.",
              "difficulty": "easy",
              "topic": "dynamic_programming"
            },
            {
              "id": "q76c",
              "type": "mcq",
              "question": "When might top-down DP with memoization be preferred over bottom-up DP?",
              "options": ["When memory is limited", "When only some subproblems are needed", "When base cases are complex", "When recursion is forbidden"],
              "correctAnswer": "When only some subproblems are needed",
              "explanation": "Top-down DP only computes needed subproblems, while bottom-up typically computes all possible subproblems.",
              "difficulty": "hard",
              "topic": "dynamic_programming"
            },
            {
              "id": "q76d",
              "type": "mcq",
              "question": "What technique can help when the DP state space is too large for a standard table?",
              "options": ["State compression", "Greedy approximation", "Random sampling", "Recursive backtracking"],
              "correctAnswer": "State compression",
              "explanation": "State compression reduces the dimensions of the DP table by representing states more efficiently.",
              "difficulty": "hard",
              "topic": "dynamic_programming"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-11",
      "title": "Linked Lists",
      "description": "Dynamic linear data structures with pointer-based connections",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "linked-list-basics",
          "title": "Basics",
          "description": "Understanding nodes, pointers, and basic operations",
          "xpReward": 60,
          "questions": [
            {
              "id": "q72",
              "type": "mcq",
              "question": "What are the two main components of a linked list node?",
              "options": ["Data and index", "Data and next pointer", "Value and size", "Key and value"],
              "correctAnswer": "Data and next pointer",
              "explanation": "Each node contains data (the actual value) and a next pointer (reference to the next node).",
              "difficulty": "easy",
              "topic": "linked-lists"
            },
            {
              "id": "q73",
              "type": "fillInBlank",
              "question": "The first node in a linked list is called the _____ node.",
              "correctAnswer": "head",
              "explanation": "The head node is the starting point of the linked list and is referenced by the head pointer.",
              "difficulty": "easy",
              "topic": "linked-lists"
            },
            {
              "id": "q74",
              "type": "mcq",
              "question": "What is the time complexity of inserting at the beginning of a linked list?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
              "correctAnswer": "O(1)",
              "explanation": "Inserting at the beginning only requires updating the head pointer and the new node's next pointer.",
              "difficulty": "medium",
              "topic": "linked-lists"
            }
          ]
        },
        {
          "id": "linked-list-types",
          "title": "Types",
          "description": "Singly, doubly, and circular linked lists",
          "xpReward": 65,
          "questions": [
            {
              "id": "q75",
              "type": "mcq",
              "question": "What additional pointer does a doubly linked list node have?",
              "options": ["Parent pointer", "Previous pointer", "Child pointer", "Root pointer"],
              "correctAnswer": "Previous pointer",
              "explanation": "Doubly linked lists have both next and previous pointers, allowing bidirectional traversal.",
              "difficulty": "medium",
              "topic": "linked-lists"
            },
            {
              "id": "q76",
              "type": "fillInBlank",
              "question": "In a circular linked list, the last node's next pointer points to the _____ node.",
              "correctAnswer": "head",
              "explanation": "Circular linked lists form a loop where the last node points back to the first node.",
              "difficulty": "medium",
              "topic": "linked-lists"
            }
          ]
        },
        {
          "id": "doubly-linked-lists",
          "title": "Doubly Linked Lists",
          "description": "Bidirectional traversal and operations",
          "xpReward": 75,
          "questions": [
            {
              "id": "q78a",
              "type": "mcq",
              "question": "What additional pointer does a doubly linked list node have compared to singly linked list?",
              "options": ["Next pointer", "Previous pointer", "Head pointer", "Tail pointer"],
              "correctAnswer": "Previous pointer",
              "explanation": "Doubly linked list nodes have both next and previous pointers, allowing bidirectional traversal.",
              "difficulty": "easy",
              "topic": "linked_lists"
            },
            {
              "id": "q78b",
              "type": "fillInBlank",
              "question": "The main advantage of doubly linked lists is _____ traversal in both directions.",
              "correctAnswer": "efficient",
              "explanation": "Doubly linked lists allow efficient traversal backward and forward without restarting from the head.",
              "difficulty": "easy",
              "topic": "linked_lists"
            },
            {
              "id": "q78c",
              "type": "mcq",
              "question": "What is the time complexity of deleting a node when you have a direct reference to it in a doubly linked list?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
              "correctAnswer": "O(1)",
              "explanation": "With both next and previous pointers, we can update adjacent nodes directly without traversing the list.",
              "difficulty": "medium",
              "topic": "linked_lists"
            },
            {
              "id": "q78d",
              "type": "mcq",
              "question": "What is the main disadvantage of doubly linked lists compared to singly linked lists?",
              "options": ["Slower insertion", "Higher memory overhead", "No backward traversal", "Complex deletion"],
              "correctAnswer": "Higher memory overhead",
              "explanation": "Each node requires an additional pointer, increasing memory usage compared to singly linked lists.",
              "difficulty": "medium",
              "topic": "linked_lists"
            }
          ]
        },
        {
          "id": "circular-linked-lists",
          "title": "Circular Linked Lists",
          "description": "Lists where the last node points to the first",
          "xpReward": 80,
          "questions": [
            {
              "id": "q79a",
              "type": "mcq",
              "question": "In a circular linked list, what does the last node point to?",
              "options": ["NULL", "The first node", "The previous node", "A sentinel node"],
              "correctAnswer": "The first node",
              "explanation": "In circular linked lists, the last node's next pointer points back to the first node, forming a cycle.",
              "difficulty": "easy",
              "topic": "linked_lists"
            },
            {
              "id": "q79b",
              "type": "fillInBlank",
              "question": "The main challenge in traversing circular linked lists is avoiding _____ loops.",
              "correctAnswer": "infinite",
              "explanation": "Since there's no NULL terminator, traversal must track the starting point to avoid infinite loops.",
              "difficulty": "medium",
              "topic": "linked_lists"
            },
            {
              "id": "q79c",
              "type": "mcq",
              "question": "What is a practical application of circular linked lists?",
              "options": ["Binary search", "Hash tables", "Round-robin scheduling", "Stack implementation"],
              "correctAnswer": "Round-robin scheduling",
              "explanation": "Circular lists naturally represent cyclic processes like round-robin CPU scheduling where processes are served in rotation.",
              "difficulty": "medium",
              "topic": "linked_lists"
            },
            {
              "id": "q79d",
              "type": "mcq",
              "question": "How can you detect if a linked list is circular?",
              "options": ["Count nodes", "Floyd's cycle detection algorithm", "Check for NULL", "Use recursion"],
              "correctAnswer": "Floyd's cycle detection algorithm",
              "explanation": "Floyd's algorithm (tortoise and hare) uses two pointers moving at different speeds to detect cycles efficiently.",
              "difficulty": "hard",
              "topic": "linked_lists"
            }
          ]
        },
        {
          "id": "skip-lists",
          "title": "Skip Lists",
          "description": "Probabilistic data structure for fast search",
          "xpReward": 90,
          "questions": [
            {
              "id": "q80a",
              "type": "mcq",
              "question": "What is the expected time complexity for search in a skip list?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
              "correctAnswer": "O(log n)",
              "explanation": "Skip lists provide probabilistic O(log n) search time by maintaining multiple levels of linked lists.",
              "difficulty": "medium",
              "topic": "linked_lists"
            },
            {
              "id": "q80b",
              "type": "fillInBlank",
              "question": "Skip lists use _____ to determine how many levels a new node should appear in.",
              "correctAnswer": "randomization",
              "explanation": "Skip lists use random coin flips to determine node height, creating a probabilistically balanced structure.",
              "difficulty": "medium",
              "topic": "linked_lists"
            },
            {
              "id": "q80c",
              "type": "mcq",
              "question": "What advantage do skip lists have over balanced binary search trees?",
              "options": ["Better worst-case guarantees", "Simpler implementation", "Less memory usage", "Faster best-case search"],
              "correctAnswer": "Simpler implementation",
              "explanation": "Skip lists avoid complex rebalancing operations needed in balanced trees, while providing similar expected performance.",
              "difficulty": "hard",
              "topic": "linked_lists"
            },
            {
              "id": "q80d",
              "type": "mcq",
              "question": "In a skip list, what is the probability that a node appears in level k+1 given it appears in level k?",
              "options": ["0.25", "0.5", "0.75", "1.0"],
              "correctAnswer": "0.5",
              "explanation": "Typically, skip lists use p=0.5, meaning each level has roughly half the nodes of the level below it.",
              "difficulty": "hard",
              "topic": "linked_lists"
            }
          ]
        },
        {
          "id": "linked-list-applications",
          "title": "Advanced Applications",
          "description": "Real-world uses and implementation techniques",
          "xpReward": 85,
          "questions": [
            {
              "id": "q81a",
              "type": "mcq",
              "question": "Which data structure commonly uses linked lists in its implementation?",
              "options": ["Array", "Hash table with chaining", "Binary search tree", "Heap"],
              "correctAnswer": "Hash table with chaining",
              "explanation": "Hash tables often use linked lists to handle collisions by chaining multiple elements in the same bucket.",
              "difficulty": "medium",
              "topic": "linked_lists"
            },
            {
              "id": "q81b",
              "type": "fillInBlank",
              "question": "Memory _____ lists are used by operating systems to track free memory blocks.",
              "correctAnswer": "free",
              "explanation": "Operating systems maintain free lists to efficiently allocate and deallocate variable-sized memory blocks.",
              "difficulty": "medium",
              "topic": "linked_lists"
            },
            {
              "id": "q81c",
              "type": "mcq",
              "question": "What technique helps improve cache performance when working with linked lists?",
              "options": ["Use smaller nodes", "Store multiple elements per node", "Use circular lists", "Avoid pointers"],
              "correctAnswer": "Store multiple elements per node",
              "explanation": "Unrolled linked lists store multiple elements per node, improving cache locality and reducing pointer overhead.",
              "difficulty": "hard",
              "topic": "linked_lists"
            },
            {
              "id": "q81d",
              "type": "mcq",
              "question": "In which scenario would linked lists be preferred over dynamic arrays?",
              "options": ["Random access needed", "Memory is limited", "Frequent insertions/deletions at arbitrary positions", "Cache performance is critical"],
              "correctAnswer": "Frequent insertions/deletions at arbitrary positions",
              "explanation": "Linked lists excel when the position of insertions/deletions is known and random access is not required.",
              "difficulty": "medium",
              "topic": "linked_lists"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-12",
      "title": "Heaps",
      "description": "Complete binary trees with heap property for priority operations",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "heap-basics",
          "title": "Basics",
          "description": "Understanding heap property and binary heap structure",
          "xpReward": 70,
          "questions": [
            {
              "id": "q77",
              "type": "mcq",
              "question": "What is the heap property for a max heap?",
              "options": ["Parent ≤ children", "Parent ≥ children", "Left child ≤ right child", "All nodes are equal"],
              "correctAnswer": "Parent ≥ children",
              "explanation": "In a max heap, every parent node is greater than or equal to its children.",
              "difficulty": "medium",
              "topic": "heaps"
            },
            {
              "id": "q78",
              "type": "fillInBlank",
              "question": "The time complexity of inserting an element into a binary heap is O(_____)",
              "correctAnswer": "log n",
              "explanation": "Insertion requires bubbling up the element, which takes O(log n) time in the worst case.",
              "difficulty": "medium",
              "topic": "heaps"
            },
            {
              "id": "q79",
              "type": "mcq",
              "question": "What operation extracts the maximum element from a max heap?",
              "options": ["peek", "extract-max", "heapify", "build-heap"],
              "correctAnswer": "extract-max",
              "explanation": "Extract-max removes and returns the maximum element (root) from a max heap.",
              "difficulty": "easy",
              "topic": "heaps"
            }
          ]
        },
        {
          "id": "priority-queues",
          "title": "Priority Queues",
          "description": "Using heaps to implement priority queues",
          "xpReward": 75,
          "questions": [
            {
              "id": "q80",
              "type": "mcq",
              "question": "What data structure is commonly used to implement a priority queue?",
              "options": ["Array", "Stack", "Binary heap", "Hash table"],
              "correctAnswer": "Binary heap",
              "explanation": "Binary heaps provide efficient O(log n) insertion and O(log n) extraction of highest priority elements.",
              "difficulty": "medium",
              "topic": "heaps"
            },
            {
              "id": "q81",
              "type": "fillInBlank",
              "question": "In a priority queue, elements are served based on their _____, not insertion order.",
              "correctAnswer": "priority",
              "explanation": "Priority queues serve elements based on priority level rather than FIFO or LIFO order.",
              "difficulty": "easy",
              "topic": "heaps"
            }
          ]
        },
        {
          "id": "heap-construction",
          "title": "Building Heaps",
          "description": "Different methods to construct heaps from arrays",
          "xpReward": 80,
          "questions": [
            {
              "id": "q82a",
              "type": "mcq",
              "question": "What is the time complexity of building a heap from an unsorted array using the heapify approach?",
              "options": ["O(n)", "O(n log n)", "O(n²)", "O(log n)"],
              "correctAnswer": "O(n)",
              "explanation": "Bottom-up heapify (Floyd's method) builds a heap in O(n) time by starting from non-leaf nodes and working upward.",
              "difficulty": "medium",
              "topic": "heaps"
            },
            {
              "id": "q82b",
              "type": "fillInBlank",
              "question": "When building a heap using repeated insertions, the time complexity is _____ .",
              "correctAnswer": "O(n log n)",
              "explanation": "Inserting n elements one by one into a heap takes O(log n) time per insertion, totaling O(n log n).",
              "difficulty": "medium",
              "topic": "heaps"
            },
            {
              "id": "q82c",
              "type": "mcq",
              "question": "In the heapify process, which nodes need to be processed?",
              "options": ["All nodes", "Only leaf nodes", "Only non-leaf nodes", "Only the root"],
              "correctAnswer": "Only non-leaf nodes",
              "explanation": "Leaf nodes are already valid heaps, so heapify only processes non-leaf nodes from bottom to top.",
              "difficulty": "medium",
              "topic": "heaps"
            },
            {
              "id": "q82d",
              "type": "mcq",
              "question": "What is the index of the last non-leaf node in a heap array of size n?",
              "options": ["n/2", "⌊n/2⌋", "⌊n/2⌋ - 1", "n - 1"],
              "correctAnswer": "⌊n/2⌋ - 1",
              "explanation": "In a 0-indexed array, the last non-leaf node is at index ⌊n/2⌋ - 1, which is the parent of the last element.",
              "difficulty": "hard",
              "topic": "heaps"
            }
          ]
        },
        {
          "id": "heapsort-analysis",
          "title": "Heapsort Algorithm",
          "description": "In-place sorting using heap properties",
          "xpReward": 85,
          "questions": [
            {
              "id": "q83a",
              "type": "mcq",
              "question": "What is the time complexity of heapsort in all cases?",
              "options": ["O(n)", "O(n log n)", "O(n²)", "O(2ⁿ)"],
              "correctAnswer": "O(n log n)",
              "explanation": "Heapsort consistently performs in O(n log n) time regardless of input distribution, making it a reliable sorting algorithm.",
              "difficulty": "medium",
              "topic": "heaps"
            },
            {
              "id": "q83b",
              "type": "fillInBlank",
              "question": "Heapsort is an _____ sorting algorithm, meaning it sorts without using extra space.",
              "correctAnswer": "in-place",
              "explanation": "Heapsort rearranges elements within the original array without requiring additional memory proportional to input size.",
              "difficulty": "easy",
              "topic": "heaps"
            },
            {
              "id": "q83c",
              "type": "mcq",
              "question": "What happens after extracting the maximum element in heapsort?",
              "options": ["The heap shrinks by one", "A new heap is created", "All elements are reordered", "The algorithm terminates"],
              "correctAnswer": "The heap shrinks by one",
              "explanation": "After extracting the maximum, the heap size is reduced by one and the heap property is restored for the remaining elements.",
              "difficulty": "medium",
              "topic": "heaps"
            },
            {
              "id": "q83d",
              "type": "mcq",
              "question": "How does heapsort compare to quicksort in terms of worst-case performance?",
              "options": ["Heapsort is worse", "They're the same", "Heapsort is better", "It depends on input"],
              "correctAnswer": "Heapsort is better",
              "explanation": "Heapsort guarantees O(n log n) worst-case time, while quicksort has O(n²) worst-case performance.",
              "difficulty": "medium",
              "topic": "heaps"
            }
          ]
        },
        {
          "id": "heap-variants",
          "title": "Heap Variants",
          "description": "Binomial heaps, Fibonacci heaps, and other variants",
          "xpReward": 95,
          "questions": [
            {
              "id": "q84a",
              "type": "mcq",
              "question": "What advantage do Fibonacci heaps have over binary heaps?",
              "options": ["Faster search", "Better decrease-key operation", "Less memory usage", "Simpler implementation"],
              "correctAnswer": "Better decrease-key operation",
              "explanation": "Fibonacci heaps support decrease-key in O(1) amortized time, while binary heaps require O(log n).",
              "difficulty": "hard",
              "topic": "heaps"
            },
            {
              "id": "q84b",
              "type": "fillInBlank",
              "question": "A _____ heap is a set of heap-ordered trees where each tree is a perfect binary tree.",
              "correctAnswer": "binomial",
              "explanation": "Binomial heaps consist of binomial trees, which are heap-ordered and have specific structural properties.",
              "difficulty": "hard",
              "topic": "heaps"
            },
            {
              "id": "q84c",
              "type": "mcq",
              "question": "Which heap variant is commonly used in Dijkstra's algorithm implementation?",
              "options": ["Binary heap", "Fibonacci heap", "Binomial heap", "Ternary heap"],
              "correctAnswer": "Fibonacci heap",
              "explanation": "Fibonacci heaps are preferred in Dijkstra's algorithm due to their efficient decrease-key operation needed for distance updates.",
              "difficulty": "hard",
              "topic": "heaps"
            },
            {
              "id": "q84d",
              "type": "mcq",
              "question": "What is a d-ary heap?",
              "options": ["A heap with d elements", "A heap where each node has d children", "A heap with depth d", "A heap storing d-dimensional data"],
              "correctAnswer": "A heap where each node has d children",
              "explanation": "A d-ary heap generalizes binary heaps by allowing each node to have up to d children instead of just 2.",
              "difficulty": "medium",
              "topic": "heaps"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-13",
      "title": "Recursion",
      "description": "Functions that call themselves to solve problems",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "recursion-basics",
          "title": "Basics",
          "description": "Understanding base cases and recursive calls",
          "xpReward": 55,
          "questions": [
            {
              "id": "q82",
              "type": "mcq",
              "question": "What are the two essential components of a recursive function?",
              "options": ["Loop and condition", "Base case and recursive case", "Input and output", "Start and end"],
              "correctAnswer": "Base case and recursive case",
              "explanation": "Every recursive function needs a base case (stopping condition) and a recursive case (calling itself).",
              "difficulty": "medium",
              "topic": "recursion"
            },
            {
              "id": "q83",
              "type": "fillInBlank",
              "question": "The _____ case prevents infinite recursion by providing a stopping condition.",
              "correctAnswer": "base",
              "explanation": "The base case defines when the recursion should stop and return a value without making further recursive calls.",
              "difficulty": "easy",
              "topic": "recursion"
            },
            {
              "id": "q84",
              "type": "mcq",
              "question": "What happens if a recursive function lacks a proper base case?",
              "options": ["It runs faster", "It causes infinite recursion", "It returns null", "It becomes iterative"],
              "correctAnswer": "It causes infinite recursion",
              "explanation": "Without a base case, the function will call itself indefinitely, leading to stack overflow.",
              "difficulty": "medium",
              "topic": "recursion"
            }
          ]
        },
        {
          "id": "recursion-examples",
          "title": "Classic Examples",
          "description": "Factorial, Fibonacci, and tree traversal",
          "xpReward": 65,
          "questions": [
            {
              "id": "q85",
              "type": "mcq",
              "question": "What is the base case for calculating factorial recursively?",
              "options": ["n = 0 or n = 1", "n = 2", "n < 0", "n > 10"],
              "correctAnswer": "n = 0 or n = 1",
              "explanation": "Factorial of 0 and 1 is 1, which serves as the base case for recursive factorial calculation.",
              "difficulty": "easy",
              "topic": "recursion"
            },
            {
              "id": "q86",
              "type": "fillInBlank",
              "question": "Tree traversal algorithms like preorder and inorder are naturally implemented using _____.",
              "correctAnswer": "recursion",
              "explanation": "Tree traversals naturally use recursion to visit nodes in a systematic order.",
              "difficulty": "medium",
              "topic": "recursion"
            }
          ]
        },
        {
          "id": "tail-recursion",
          "title": "Tail Recursion",
          "description": "Optimizing recursive calls for better performance",
          "xpReward": 75,
          "questions": [
            {
              "id": "q86a",
              "type": "mcq",
              "question": "What is a tail recursive function?",
              "options": ["A function that calls itself last", "A function with recursion at the end of the code", "A function where recursive call is the last operation", "A function that returns its tail"],
              "correctAnswer": "A function where recursive call is the last operation",
              "explanation": "In tail recursion, the recursive call is the final operation, allowing for optimization by reusing the stack frame.",
              "difficulty": "medium",
              "topic": "recursion"
            },
            {
              "id": "q86b",
              "type": "fillInBlank",
              "question": "Tail recursion can be optimized into _____ by compilers, eliminating stack overflow risk.",
              "correctAnswer": "iteration",
              "explanation": "Tail call optimization converts tail recursive functions into iterative loops, using constant stack space.",
              "difficulty": "medium",
              "topic": "recursion"
            },
            {
              "id": "q86c",
              "type": "mcq",
              "question": "Which version of factorial is tail recursive?",
              "options": ["fact(n) = n * fact(n-1)", "fact(n, acc) = fact(n-1, n*acc)", "Both versions", "Neither version"],
              "correctAnswer": "fact(n, acc) = fact(n-1, n*acc)",
              "explanation": "The second version uses an accumulator and makes the recursive call the last operation, making it tail recursive.",
              "difficulty": "hard",
              "topic": "recursion"
            },
            {
              "id": "q86d",
              "type": "mcq",
              "question": "What is the main benefit of tail recursion optimization?",
              "options": ["Faster execution", "Less memory usage", "Simpler code", "Better readability"],
              "correctAnswer": "Less memory usage",
              "explanation": "Tail recursion optimization reduces stack space usage from O(n) to O(1) by reusing stack frames.",
              "difficulty": "medium",
              "topic": "recursion"
            }
          ]
        },
        {
          "id": "tree-recursion",
          "title": "Tree Recursion",
          "description": "Multiple recursive calls and their analysis",
          "xpReward": 85,
          "questions": [
            {
              "id": "q87a",
              "type": "mcq",
              "question": "What characterizes tree recursion?",
              "options": ["It works on trees only", "It makes multiple recursive calls", "It has tree-like structure", "It's always inefficient"],
              "correctAnswer": "It makes multiple recursive calls",
              "explanation": "Tree recursion involves making multiple recursive calls from a single function call, creating a tree-like call structure.",
              "difficulty": "medium",
              "topic": "recursion"
            },
            {
              "id": "q87b",
              "type": "fillInBlank",
              "question": "The naive Fibonacci implementation has _____ time complexity due to redundant calculations.",
              "correctAnswer": "exponential",
              "explanation": "Naive Fibonacci has O(2^n) complexity because it recalculates the same values multiple times.",
              "difficulty": "medium",
              "topic": "recursion"
            },
            {
              "id": "q87c",
              "type": "mcq",
              "question": "How can we optimize tree recursive algorithms like Fibonacci?",
              "options": ["Use iteration only", "Add memoization", "Avoid base cases", "Use more recursive calls"],
              "correctAnswer": "Add memoization",
              "explanation": "Memoization stores previously computed results, reducing exponential time complexity to polynomial.",
              "difficulty": "medium",
              "topic": "recursion"
            },
            {
              "id": "q87d",
              "type": "mcq",
              "question": "Which of these is an example of tree recursion?",
              "options": ["Linear search", "Binary search", "Merge sort", "Quick sort"],
              "correctAnswer": "Merge sort",
              "explanation": "Merge sort makes two recursive calls (left and right halves), exemplifying tree recursion structure.",
              "difficulty": "medium",
              "topic": "recursion"
            }
          ]
        },
        {
          "id": "recursion-vs-iteration",
          "title": "Recursion vs Iteration",
          "description": "Comparing recursive and iterative approaches",
          "xpReward": 80,
          "questions": [
            {
              "id": "q88a",
              "type": "mcq",
              "question": "What is a main advantage of recursion over iteration?",
              "options": ["Always faster", "Less memory usage", "More intuitive for some problems", "Better performance"],
              "correctAnswer": "More intuitive for some problems",
              "explanation": "Recursion naturally models problems with recursive structure like trees and divide-and-conquer algorithms.",
              "difficulty": "medium",
              "topic": "recursion"
            },
            {
              "id": "q88b",
              "type": "fillInBlank",
              "question": "Recursion uses the _____ to store function call information, while iteration typically uses less memory.",
              "correctAnswer": "stack",
              "explanation": "Each recursive call adds a frame to the call stack, which can lead to stack overflow for deep recursion.",
              "difficulty": "easy",
              "topic": "recursion"
            },
            {
              "id": "q88c",
              "type": "mcq",
              "question": "When might iteration be preferred over recursion?",
              "options": ["When working with trees", "When memory is limited", "When code clarity matters", "When using functional programming"],
              "correctAnswer": "When memory is limited",
              "explanation": "Iteration typically uses less memory than recursion since it doesn't need to maintain a call stack.",
              "difficulty": "medium",
              "topic": "recursion"
            },
            {
              "id": "q88d",
              "type": "mcq",
              "question": "Any recursive algorithm can be converted to:",
              "options": ["A greedy algorithm", "An iterative algorithm", "A dynamic programming solution", "A divide-and-conquer approach"],
              "correctAnswer": "An iterative algorithm",
              "explanation": "Any recursive algorithm can be converted to iteration using explicit stack management, though it may be more complex.",
              "difficulty": "hard",
              "topic": "recursion"
            }
          ]
        },
        {
          "id": "advanced-recursion",
          "title": "Advanced Recursive Techniques",
          "description": "Mutual recursion, continuation passing, and optimization",
          "xpReward": 95,
          "questions": [
            {
              "id": "q89a",
              "type": "mcq",
              "question": "What is mutual recursion?",
              "options": ["Two functions calling each other", "Multiple base cases", "Recursive data structures", "Parallel recursion"],
              "correctAnswer": "Two functions calling each other",
              "explanation": "Mutual recursion occurs when two or more functions call each other recursively to solve a problem.",
              "difficulty": "hard",
              "topic": "recursion"
            },
            {
              "id": "q89b",
              "type": "fillInBlank",
              "question": "_____ passing style (CPS) is a functional programming technique where functions never return but pass results to continuation functions.",
              "correctAnswer": "Continuation",
              "explanation": "Continuation passing style transforms recursion by explicitly passing what to do next as a function parameter.",
              "difficulty": "hard",
              "topic": "recursion"
            },
            {
              "id": "q89c",
              "type": "mcq",
              "question": "Which technique can convert any recursion to tail recursion?",
              "options": ["Memoization", "Continuation passing style", "Loop unrolling", "Dynamic programming"],
              "correctAnswer": "Continuation passing style",
              "explanation": "CPS can transform any recursive function into tail-recursive form by explicitly managing continuations.",
              "difficulty": "hard",
              "topic": "recursion"
            },
            {
              "id": "q89d",
              "type": "mcq",
              "question": "What is trampolining in the context of recursion?",
              "options": ["Jumping between functions", "Converting recursion to iteration", "Optimizing tail calls", "Eliminating stack overflow"],
              "correctAnswer": "Eliminating stack overflow",
              "explanation": "Trampolining is a technique to eliminate stack overflow by converting recursive calls into a loop with function objects.",
              "difficulty": "hard",
              "topic": "recursion"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-14",
      "title": "Searching",
      "description": "Algorithms for finding elements in data structures",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "linear-search",
          "title": "Linear Search",
          "description": "Sequential searching through elements",
          "xpReward": 45,
          "questions": [
            {
              "id": "q87",
              "type": "mcq",
              "question": "What is the time complexity of linear search?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
              "correctAnswer": "O(n)",
              "explanation": "Linear search checks each element sequentially, taking O(n) time in the worst case.",
              "difficulty": "easy",
              "topic": "searching"
            },
            {
              "id": "q88",
              "type": "fillInBlank",
              "question": "Linear search works on both _____ and unsorted arrays.",
              "correctAnswer": "sorted",
              "explanation": "Linear search doesn't require any ordering and works on both sorted and unsorted data.",
              "difficulty": "easy",
              "topic": "searching"
            }
          ]
        },
        {
          "id": "binary-search",
          "title": "Binary Search",
          "description": "Efficient searching in sorted arrays",
          "xpReward": 65,
          "questions": [
            {
              "id": "q89",
              "type": "mcq",
              "question": "What is the prerequisite for binary search?",
              "options": ["Array must be large", "Array must be sorted", "Array must have unique elements", "Array must be numeric"],
              "correctAnswer": "Array must be sorted",
              "explanation": "Binary search requires the array to be sorted to eliminate half the search space at each step.",
              "difficulty": "medium",
              "topic": "searching"
            },
            {
              "id": "q90",
              "type": "mcq",
              "question": "What is the time complexity of binary search?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
              "correctAnswer": "O(log n)",
              "explanation": "Binary search halves the search space at each step, resulting in O(log n) time complexity.",
              "difficulty": "medium",
              "topic": "searching"
            },
            {
              "id": "q91",
              "type": "fillInBlank",
              "question": "Binary search compares the target with the _____ element to decide which half to search.",
              "correctAnswer": "middle",
              "explanation": "Binary search finds the middle element and compares it with the target to eliminate half the array.",
              "difficulty": "easy",
              "topic": "searching"
            }
          ]
        },
        {
          "id": "advanced-binary-search",
          "title": "Binary Search Variants",
          "description": "Lower bound, upper bound, and search space applications",
          "xpReward": 85,
          "questions": [
            {
              "id": "q91a",
              "type": "mcq",
              "question": "What does lower_bound function find in a sorted array?",
              "options": ["The smallest element", "First element >= target", "Last element < target", "Any occurrence of target"],
              "correctAnswer": "First element >= target",
              "explanation": "Lower bound finds the first position where the target could be inserted while maintaining sorted order.",
              "difficulty": "medium",
              "topic": "searching"
            },
            {
              "id": "q91b",
              "type": "fillInBlank",
              "question": "Upper bound finds the first element _____ than the target value.",
              "correctAnswer": "greater",
              "explanation": "Upper bound returns an iterator to the first element that is greater than the search value.",
              "difficulty": "medium",
              "topic": "searching"
            },
            {
              "id": "q91c",
              "type": "mcq",
              "question": "Binary search can be applied to problems where:",
              "options": ["Data is always sorted", "Search space is monotonic", "There are duplicates", "Array is circular"],
              "correctAnswer": "Search space is monotonic",
              "explanation": "Binary search works on any monotonic function, not just sorted arrays - the key is the property that splits the search space.",
              "difficulty": "hard",
              "topic": "searching"
            },
            {
              "id": "q91d",
              "type": "mcq",
              "question": "Which problem can be solved using binary search on the answer?",
              "options": ["Finding maximum in array", "Square root calculation", "Array sorting", "Graph traversal"],
              "correctAnswer": "Square root calculation",
              "explanation": "Finding square root can use binary search by searching for the answer in the range [0, x] where x*x ≤ target.",
              "difficulty": "hard",
              "topic": "searching"
            }
          ]
        },
        {
          "id": "hash-based-searching",
          "title": "Hash-Based Search",
          "description": "Hash tables and collision resolution for fast lookups",
          "xpReward": 80,
          "questions": [
            {
              "id": "q92a",
              "type": "mcq",
              "question": "What is the average time complexity of search in a well-designed hash table?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
              "correctAnswer": "O(1)",
              "explanation": "Hash tables provide O(1) average case search time through direct indexing using hash functions.",
              "difficulty": "easy",
              "topic": "searching"
            },
            {
              "id": "q92b",
              "type": "fillInBlank",
              "question": "When multiple keys hash to the same location, this is called a _____.",
              "correctAnswer": "collision",
              "explanation": "Hash collisions occur when different keys produce the same hash value, requiring resolution strategies.",
              "difficulty": "easy",
              "topic": "searching"
            },
            {
              "id": "q92c",
              "type": "mcq",
              "question": "Which collision resolution technique uses a secondary hash function?",
              "options": ["Chaining", "Linear probing", "Double hashing", "Quadratic probing"],
              "correctAnswer": "Double hashing",
              "explanation": "Double hashing uses a second hash function to determine the step size for probing when a collision occurs.",
              "difficulty": "medium",
              "topic": "searching"
            },
            {
              "id": "q92d",
              "type": "mcq",
              "question": "What is the main disadvantage of open addressing compared to chaining?",
              "options": ["Higher memory usage", "Clustering problems", "Complex implementation", "Poor cache performance"],
              "correctAnswer": "Clustering problems",
              "explanation": "Open addressing can suffer from clustering where consecutive occupied slots make future insertions slower.",
              "difficulty": "hard",
              "topic": "searching"
            }
          ]
        },
        {
          "id": "string-searching",
          "title": "String Search Algorithms",
          "description": "Pattern matching and substring search techniques",
          "xpReward": 90,
          "questions": [
            {
              "id": "q93a",
              "type": "mcq",
              "question": "What is the time complexity of the naive string matching algorithm?",
              "options": ["O(n)", "O(m)", "O(n*m)", "O(n+m)"],
              "correctAnswer": "O(n*m)",
              "explanation": "Naive string matching compares the pattern at each position in the text, leading to O(n*m) worst-case time.",
              "difficulty": "medium",
              "topic": "searching"
            },
            {
              "id": "q93b",
              "type": "fillInBlank",
              "question": "The KMP algorithm uses a _____ function to avoid redundant comparisons during pattern matching.",
              "correctAnswer": "failure",
              "explanation": "KMP preprocessing computes a failure function that determines how far to shift the pattern on mismatches.",
              "difficulty": "hard",
              "topic": "searching"
            },
            {
              "id": "q93c",
              "type": "mcq",
              "question": "Which string searching algorithm has O(n+m) time complexity in the worst case?",
              "options": ["Naive algorithm", "KMP algorithm", "Boyer-Moore", "Rabin-Karp"],
              "correctAnswer": "KMP algorithm",
              "explanation": "KMP (Knuth-Morris-Pratt) guarantees O(n+m) time by never backtracking in the text.",
              "difficulty": "medium",
              "topic": "searching"
            },
            {
              "id": "q93d",
              "type": "mcq",
              "question": "What technique does the Boyer-Moore algorithm use to improve average-case performance?",
              "options": ["Preprocessing the text", "Comparing from right to left", "Using multiple hash functions", "Building suffix trees"],
              "correctAnswer": "Comparing from right to left",
              "explanation": "Boyer-Moore compares the pattern from right to left and uses good suffix and bad character heuristics to skip positions.",
              "difficulty": "hard",
              "topic": "searching"
            }
          ]
        },
        {
          "id": "advanced-search-structures",
          "title": "Advanced Search Structures",
          "description": "Tries, suffix trees, and specialized search data structures",
          "xpReward": 95,
          "questions": [
            {
              "id": "q94a",
              "type": "mcq",
              "question": "What is the primary advantage of a trie over a hash table for string storage?",
              "options": ["Better memory usage", "Prefix-based operations", "Faster individual lookups", "Simpler implementation"],
              "correctAnswer": "Prefix-based operations",
              "explanation": "Tries excel at prefix-based operations like autocomplete and longest common prefix, which are difficult with hash tables.",
              "difficulty": "medium",
              "topic": "searching"
            },
            {
              "id": "q94b",
              "type": "fillInBlank",
              "question": "A _____ tree contains all suffixes of a string and enables linear-time substring search.",
              "correctAnswer": "suffix",
              "explanation": "Suffix trees store all suffixes of a string in a compressed trie, enabling fast pattern matching queries.",
              "difficulty": "hard",
              "topic": "searching"
            },
            {
              "id": "q94c",
              "type": "mcq",
              "question": "What is the space complexity of a standard trie storing n strings with total length m?",
              "options": ["O(n)", "O(m)", "O(n*m)", "O(m²)"],
              "correctAnswer": "O(m)",
              "explanation": "A trie uses O(m) space where m is the total length of all stored strings, as each character is stored once per path.",
              "difficulty": "hard",
              "topic": "searching"
            },
            {
              "id": "q94d",
              "type": "mcq",
              "question": "Which data structure would be most efficient for range queries on a 2D grid?",
              "options": ["Hash table", "Binary search tree", "Quadtree", "Linked list"],
              "correctAnswer": "Quadtree",
              "explanation": "Quadtrees recursively partition 2D space into quadrants, making them efficient for spatial range queries.",
              "difficulty": "hard",
              "topic": "searching"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-15",
      "title": "Big O Notation",
      "description": "Analyzing algorithm efficiency and complexity",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "time-complexity",
          "title": "Time Complexity",
          "description": "Understanding how algorithms scale with input size",
          "xpReward": 70,
          "questions": [
            {
              "id": "q92",
              "type": "mcq",
              "question": "What does Big O notation describe?",
              "options": ["Best case performance", "Average case performance", "Worst case performance", "Space usage only"],
              "correctAnswer": "Worst case performance",
              "explanation": "Big O notation describes the upper bound or worst-case time complexity of an algorithm.",
              "difficulty": "medium",
              "topic": "complexity"
            },
            {
              "id": "q93",
              "type": "fillInBlank",
              "question": "An algorithm that accesses a single array element has _____ time complexity.",
              "correctAnswer": "O(1)",
              "explanation": "Constant time O(1) means the operation takes the same time regardless of input size.",
              "difficulty": "easy",
              "topic": "complexity"
            },
            {
              "id": "q94",
              "type": "mcq",
              "question": "Which time complexity is better: O(n) or O(log n)?",
              "options": ["O(n)", "O(log n)", "They're the same", "Depends on input"],
              "correctAnswer": "O(log n)",
              "explanation": "O(log n) grows much slower than O(n), making it more efficient for large inputs.",
              "difficulty": "medium",
              "topic": "complexity"
            }
          ]
        },
        {
          "id": "space-complexity",
          "title": "Space Complexity",
          "description": "Analyzing memory usage of algorithms",
          "xpReward": 60,
          "questions": [
            {
              "id": "q95",
              "type": "mcq",
              "question": "What does space complexity measure?",
              "options": ["Execution time", "Memory usage", "Code length", "CPU cycles"],
              "correctAnswer": "Memory usage",
              "explanation": "Space complexity measures how much additional memory an algorithm uses relative to input size.",
              "difficulty": "easy",
              "topic": "complexity"
            },
            {
              "id": "q96",
              "type": "fillInBlank",
              "question": "An algorithm that uses a fixed amount of extra memory has _____ space complexity.",
              "correctAnswer": "O(1)",
              "explanation": "Constant space O(1) means the algorithm uses the same amount of extra memory regardless of input size.",
              "difficulty": "medium",
              "topic": "complexity"
            }
          ]
        },
        {
          "id": "common-complexities",
          "title": "Common Time Complexities",
          "description": "Recognizing and comparing different complexity classes",
          "xpReward": 75,
          "questions": [
            {
              "id": "q97a",
              "type": "mcq",
              "question": "Which complexity is typical for divide-and-conquer algorithms like merge sort?",
              "options": ["O(n)", "O(n log n)", "O(n²)", "O(2ⁿ)"],
              "correctAnswer": "O(n log n)",
              "explanation": "Divide-and-conquer algorithms that split the problem in half typically have O(n log n) complexity.",
              "difficulty": "medium",
              "topic": "big_o"
            },
            {
              "id": "q97b",
              "type": "fillInBlank",
              "question": "Bubble sort has _____ time complexity in the worst case.",
              "correctAnswer": "O(n²)",
              "explanation": "Bubble sort compares each element with every other element, resulting in quadratic time complexity.",
              "difficulty": "medium",
              "topic": "big_o"
            },
            {
              "id": "q97c",
              "type": "mcq",
              "question": "Which complexity grows fastest?",
              "options": ["O(n²)", "O(n log n)", "O(2ⁿ)", "O(n³)"],
              "correctAnswer": "O(2ⁿ)",
              "explanation": "Exponential complexity O(2ⁿ) grows much faster than polynomial complexities like O(n³).",
              "difficulty": "medium",
              "topic": "big_o"
            },
            {
              "id": "q97d",
              "type": "mcq",
              "question": "Binary search on a sorted array has which time complexity?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
              "correctAnswer": "O(log n)",
              "explanation": "Binary search eliminates half the search space at each step, resulting in logarithmic time complexity.",
              "difficulty": "easy",
              "topic": "big_o"
            }
          ]
        },
        {
          "id": "amortized-analysis",
          "title": "Amortized Analysis",
          "description": "Average case analysis over sequences of operations",
          "xpReward": 85,
          "questions": [
            {
              "id": "q98a",
              "type": "mcq",
              "question": "What does amortized analysis study?",
              "options": ["Single operation worst-case", "Average time over sequence of operations", "Memory usage patterns", "Algorithm correctness"],
              "correctAnswer": "Average time over sequence of operations",
              "explanation": "Amortized analysis considers the average performance per operation over a worst-case sequence of operations.",
              "difficulty": "medium",
              "topic": "big_o"
            },
            {
              "id": "q98b",
              "type": "fillInBlank",
              "question": "Dynamic array resizing has _____ amortized time per insertion even though individual operations may be expensive.",
              "correctAnswer": "O(1)",
              "explanation": "Although resizing takes O(n) time, it happens infrequently enough that the amortized cost per insertion is O(1).",
              "difficulty": "hard",
              "topic": "big_o"
            },
            {
              "id": "q98c",
              "type": "mcq",
              "question": "Which method is used to prove amortized bounds?",
              "options": ["Mathematical induction", "Potential method", "Substitution method", "Master theorem"],
              "correctAnswer": "Potential method",
              "explanation": "The potential method assigns a potential function to data structure states to analyze amortized costs.",
              "difficulty": "hard",
              "topic": "big_o"
            },
            {
              "id": "q98d",
              "type": "mcq",
              "question": "In the accounting method for amortized analysis, what represents 'credit'?",
              "options": ["Time saved", "Extra work done", "Memory allocated", "Operations completed"],
              "correctAnswer": "Extra work done",
              "explanation": "The accounting method assigns credits for extra work that can be used to pay for expensive operations later.",
              "difficulty": "hard",
              "topic": "big_o"
            }
          ]
        },
        {
          "id": "algorithm-analysis",
          "title": "Practical Algorithm Analysis",
          "description": "Analyzing real algorithms and their complexities",
          "xpReward": 80,
          "questions": [
            {
              "id": "q99a",
              "type": "mcq",
              "question": "What is the time complexity of finding the maximum element in an unsorted array?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
              "correctAnswer": "O(n)",
              "explanation": "Finding the maximum requires examining every element at least once, giving linear time complexity.",
              "difficulty": "easy",
              "topic": "big_o"
            },
            {
              "id": "q99b",
              "type": "fillInBlank",
              "question": "Matrix multiplication using the naive algorithm has _____ time complexity.",
              "correctAnswer": "O(n³)",
              "explanation": "Naive matrix multiplication requires three nested loops, each running n times, resulting in cubic complexity.",
              "difficulty": "medium",
              "topic": "big_o"
            },
            {
              "id": "q99c",
              "type": "mcq",
              "question": "When analyzing nested loops, what should you do?",
              "options": ["Add the complexities", "Multiply the complexities", "Take the maximum", "Take the minimum"],
              "correctAnswer": "Multiply the complexities",
              "explanation": "Nested loops multiply their complexities since the inner loop runs completely for each iteration of the outer loop.",
              "difficulty": "medium",
              "topic": "big_o"
            },
            {
              "id": "q99d",
              "type": "mcq",
              "question": "Which factor affects time complexity analysis?",
              "options": ["Programming language", "Input size", "Computer speed", "Operating system"],
              "correctAnswer": "Input size",
              "explanation": "Time complexity analysis focuses on how performance scales with input size, independent of hardware or software environment.",
              "difficulty": "medium",
              "topic": "big_o"
            }
          ]
        },
        {
          "id": "complexity-theory",
          "title": "Complexity Theory Basics",
          "description": "P, NP, and computational complexity classes",
          "xpReward": 90,
          "questions": [
            {
              "id": "q100a",
              "type": "mcq",
              "question": "What characterizes the complexity class P?",
              "options": ["Problems solvable in polynomial time", "Problems with polynomial space", "Undecidable problems", "NP-complete problems"],
              "correctAnswer": "Problems solvable in polynomial time",
              "explanation": "Class P contains decision problems that can be solved by a deterministic algorithm in polynomial time.",
              "difficulty": "hard",
              "topic": "big_o"
            },
            {
              "id": "q100b",
              "type": "fillInBlank",
              "question": "Class _____ contains problems whose solutions can be verified in polynomial time.",
              "correctAnswer": "NP",
              "explanation": "NP (Nondeterministic Polynomial time) problems have solutions that can be verified quickly, even if finding them is hard.",
              "difficulty": "hard",
              "topic": "big_o"
            },
            {
              "id": "q100c",
              "type": "mcq",
              "question": "What makes a problem NP-complete?",
              "options": ["It's in P", "It's in NP and NP-hard", "It's undecidable", "It requires exponential space"],
              "correctAnswer": "It's in NP and NP-hard",
              "explanation": "NP-complete problems are in NP (verifiable in polynomial time) and NP-hard (at least as hard as any NP problem).",
              "difficulty": "hard",
              "topic": "big_o"
            },
            {
              "id": "q100d",
              "type": "mcq",
              "question": "Which of these is a famous NP-complete problem?",
              "options": ["Sorting", "Binary search", "Traveling salesman problem", "Matrix multiplication"],
              "correctAnswer": "Traveling salesman problem",
              "explanation": "TSP is one of the classic NP-complete problems, where finding the optimal tour is computationally difficult.",
              "difficulty": "medium",
              "topic": "big_o"
            }
          ]
        }
      ]
    }
  ]
}