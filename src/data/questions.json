{
  "units": [
    {
      "id": "unit-1",
      "title": "Arrays",
      "description": "Master the fundamentals of arrays and string manipulation",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "arrays-basics",
          "title": "Basics",
          "description": "Understanding what arrays are and basic concepts",
          "xpReward": 50,
          "questions": [
            {
              "id": "q1",
              "type": "mcq",
              "question": "What is the key characteristic of how arrays store elements in memory?",
              "options": ["Elements are stored with pointers to the next element", "Elements are stored in contiguous memory locations", "Elements are stored on the heap in separate objects", "Elements are organized in a tree structure for fast search"],
              "correctAnswer": "Elements are stored in contiguous memory locations",
              "explanation": "Arrays store elements in contiguous (adjacent) memory locations, which enables constant-time access by index and better cache performance.",
              "difficulty": "easy",
              "topic": "arrays"
            },
            {
              "id": "q2",
              "type": "mcq",
              "question": "What is the main advantage of arrays over linked lists?",
              "options": ["Dynamic size", "Faster insertion at beginning", "Random access in O(1) time", "Lower memory usage per element"],
              "correctAnswer": "Random access in O(1) time",
              "explanation": "Arrays provide O(1) random access to elements by index, while linked lists require O(n) traversal to reach a specific element.",
              "difficulty": "easy",
              "topic": "arrays"
            },
            {
              "id": "q3",
              "type": "mcq",
              "question": "What is the difference between static and dynamic arrays?",
              "options": ["Static arrays can change size, dynamic cannot", "Static arrays have fixed size, dynamic can grow/shrink", "Static arrays are faster", "There is no difference"],
              "correctAnswer": "Static arrays have fixed size, dynamic can grow/shrink",
              "explanation": "Static arrays have a fixed size determined at compile time, while dynamic arrays can resize during runtime as needed.",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q4",
              "type": "mcq",
              "question": "What happens when you access an array index that equals the array length?",
              "options": ["Returns the last element", "Returns the first element", "Causes an index out of bounds error", "Automatically extends the array"],
              "correctAnswer": "Causes an index out of bounds error",
              "explanation": "In most programming languages, accessing index[length] when valid indices are 0 to length-1 results in an out of bounds error.",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q5",
              "type": "mcq",
              "question": "Why do arrays have better cache performance compared to linked lists?",
              "options": ["Arrays use less memory", "Arrays have contiguous memory layout", "Arrays are smaller", "Arrays use pointers"],
              "correctAnswer": "Arrays have contiguous memory layout",
              "explanation": "Arrays store elements in contiguous memory, which means accessing nearby elements benefits from CPU cache locality, making sequential access faster.",
              "difficulty": "medium",
              "topic": "arrays"
            }
          ]
        },
        {
          "id": "array-operations",
          "title": "Operations",
          "description": "Understanding time complexity of basic array operations",
          "xpReward": 60,
          "questions": [
            {
              "id": "q6",
              "type": "mcq",
              "question": "What is the time complexity of accessing an element in an array by index?",
              "options": ["O(1)", "O(n)", "O(log n)", "O(n²)"],
              "correctAnswer": "O(1)",
              "explanation": "Array access by index is constant time O(1) because arrays store elements in contiguous memory locations with direct address calculation.",
              "difficulty": "easy",
              "topic": "arrays"
            },
            {
              "id": "q7",
              "type": "mcq",
              "question": "What is the time complexity of inserting an element at the end of a dynamic array?",
              "options": ["O(1)", "O(n)", "O(log n)", "O(1) amortized"],
              "correctAnswer": "O(1) amortized",
              "explanation": "Insertion at the end is O(1) amortized because occasional resizing operations (O(n)) are spread across many insertions.",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q8",
              "type": "mcq",
              "question": "Why is inserting at the beginning of an array O(n)?",
              "options": ["Need to allocate new memory", "Need to shift all existing elements", "Need to search for position", "Need to check bounds"],
              "correctAnswer": "Need to shift all existing elements",
              "explanation": "Inserting at the beginning requires shifting all existing elements one position to the right, making it O(n) operation.",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q9",
              "type": "fillInBlank",
              "question": "The time complexity of deleting an element from the end of an array is _____.",
              "acceptedAnswers": ["O(1)", "o(1)", "O( 1 )", "O(1)", "constant", "Constant", "CONSTANT"],
              "explanation": "Deleting from the end only requires removing the last element without shifting others, making it O(1).",
              "difficulty": "easy",
              "topic": "arrays"
            },
            {
              "id": "q10",
              "type": "mcq",
              "question": "What is the time complexity of linear search in an unsorted array?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
              "correctAnswer": "O(n)",
              "explanation": "Linear search may need to check every element in the worst case, making it O(n).",
              "difficulty": "easy",
              "topic": "arrays"
            },
            {
              "id": "q11",
              "type": "mcq",
              "question": "What is the time complexity of binary search in a sorted array?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
              "correctAnswer": "O(log n)",
              "explanation": "Binary search repeatedly divides the search space in half, resulting in O(log n) time complexity.",
              "difficulty": "medium",
              "topic": "arrays"
            }
          ]
        },
        {
          "id": "array-properties",
          "title": "Properties",
          "description": "Essential array properties and common operations",
          "xpReward": 55,
          "questions": [
            {
              "id": "q12",
              "type": "fillInBlank",
              "question": "To find the number of elements in an array, you typically use the _____ property.",
              "acceptedAnswers": ["length", "Length", "LENGTH", "size", "Size", "SIZE", "count", "Count", "COUNT"],
              "explanation": "The 'length' property returns the number of elements in an array and is available in most programming languages.",
              "difficulty": "easy",
              "topic": "arrays"
            },
            {
              "id": "q13",
              "type": "mcq",
              "question": "What happens when you try to access an array element beyond its bounds?",
              "options": ["Returns null", "Throws an exception or undefined behavior", "Returns 0", "Automatically extends the array"],
              "correctAnswer": "Throws an exception or undefined behavior",
              "explanation": "Accessing out-of-bounds indices typically results in an exception (Java), undefined behavior (C/C++), or undefined (JavaScript).",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q14",
              "type": "mcq",
              "question": "When initializing an array with zeros, what is typically the most efficient approach?",
              "options": ["Loop through and set each element", "Use built-in initialization methods", "Copy from another zero array", "Use recursion"],
              "correctAnswer": "Use built-in initialization methods",
              "explanation": "Most languages provide efficient built-in methods for array initialization (like Arrays.fill() or calloc()) that are optimized at the system level.",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q15",
              "type": "mcq", 
              "question": "What is the difference between shallow and deep copying of arrays?",
              "options": ["Shallow copies references, deep copies values", "Shallow is faster, deep is slower", "Shallow copies first half, deep copies all", "No difference"],
              "correctAnswer": "Shallow copies references, deep copies values",
              "explanation": "Shallow copy creates a new array but copies references to objects, while deep copy creates new objects as well.",
              "difficulty": "hard",
              "topic": "arrays"
            },
            {
              "id": "q16",
              "type": "fillInBlank",
              "question": "When comparing two arrays for equality, you typically need to compare both their _____ and corresponding elements.",
              "acceptedAnswers": ["length", "Length", "LENGTH", "size", "Size", "SIZE", "lengths", "Lengths", "LENGTHS", "sizes", "Sizes", "SIZES"],
              "explanation": "Array equality requires checking that arrays have the same length and that all corresponding elements are equal.",
              "difficulty": "medium",
              "topic": "arrays"
            }
          ]
        },
        {
          "id": "array-memory",
          "title": "Memory",
          "description": "Understanding how arrays manage memory and resizing",
          "xpReward": 65,
          "questions": [
            {
              "id": "q17",
              "type": "mcq",
              "question": "What is a key limitation of fixed-size arrays?",
              "options": ["Slow access time", "Cannot change size after creation", "Use more memory", "Poor cache performance"],
              "correctAnswer": "Cannot change size after creation",
              "explanation": "Fixed-size arrays have their size determined at creation time and cannot be changed, unlike dynamic arrays.",
              "difficulty": "easy",
              "topic": "arrays"
            },
            {
              "id": "q18",
              "type": "fillInBlank",
              "question": "Dynamic arrays like ArrayList in Java or vector in C++ are also called _____ arrays.",
              "acceptedAnswers": ["resizable", "Resizable", "RESIZABLE", "dynamic", "Dynamic", "DYNAMIC", "growable", "Growable", "GROWABLE"],
              "explanation": "Dynamic/resizable arrays can grow and shrink in size during runtime, unlike fixed-size arrays.",
              "difficulty": "easy",
              "topic": "arrays"
            },
            {
              "id": "q19",
              "type": "mcq",
              "question": "When a dynamic array needs to grow beyond its current capacity, what typically happens?",
              "options": ["It extends in place", "A new larger array is allocated and elements are copied", "It throws an error", "It compresses existing elements"],
              "correctAnswer": "A new larger array is allocated and elements are copied",
              "explanation": "Dynamic arrays typically allocate a new, larger array and copy all existing elements when they need to grow beyond capacity.",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q20",
              "type": "mcq",
              "question": "What is a common resizing strategy for dynamic arrays when they need to grow?",
              "options": ["Add one element at a time", "Double the current size", "Add 10 elements", "Triple the size"],
              "correctAnswer": "Double the current size",
              "explanation": "Doubling the size is a common strategy that provides good amortized performance - it balances memory usage with the frequency of expensive resize operations.",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q21",
              "type": "fillInBlank",
              "question": "The process of creating a new larger array and copying elements during resizing is called _____.",
              "acceptedAnswers": ["reallocation", "Reallocation", "REALLOCATION", "reallocating", "Reallocating", "REALLOCATING", "resizing", "Resizing", "RESIZING"],
              "explanation": "Reallocation is the process of allocating new memory space and copying data when an array needs to resize.",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q22",
              "type": "mcq",
              "question": "Why don't dynamic arrays shrink immediately when elements are removed?",
              "options": ["It's impossible to shrink", "To avoid frequent reallocation", "To maintain order", "To save computation time"],
              "correctAnswer": "To avoid frequent reallocation",
              "explanation": "Dynamic arrays typically don't shrink immediately to avoid the overhead of frequent reallocations when elements are added and removed repeatedly.",
              "difficulty": "hard",
              "topic": "arrays"
            }
          ]
        },
        {
          "id": "array-algorithms",
          "title": "Algorithms", 
          "description": "Common algorithms using arrays",
          "xpReward": 75,
          "questions": [
            {
              "id": "q23",
              "type": "mcq",
              "question": "What is the optimal time complexity for finding two numbers in a sorted array that sum to a target?",
              "options": ["O(n²)", "O(n log n)", "O(n)", "O(log n)"],
              "correctAnswer": "O(n)",
              "explanation": "Using two pointers (one at start, one at end) on a sorted array gives O(n) time complexity.",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q24",
              "type": "fillInBlank", 
              "question": "The technique that uses two pointers moving towards each other is called the _____ pointer technique.",
              "acceptedAnswers": ["two", "Two", "TWO", "2", "dual", "Dual", "DUAL", "double", "Double", "DOUBLE"],
              "explanation": "Two pointer technique is commonly used for array problems where you need to find pairs or subarrays.",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q24e",
              "type": "codeCompletion",
              "question": "Complete the function to find the maximum element in an array:",
              "codeTemplate": "function findMax(arr) {\n  let max = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (______) {\n      max = arr[i];\n    }\n  }\n  return max;\n}",
              "blanks": [
                {
                  "position": "______",
                  "acceptedAnswers": ["arr[i] > max", "max < arr[i]", "arr[i] > max", "max < arr[i]"],
                  "explanation": "We update max when the current element is greater than the current maximum."
                }
              ],
              "difficulty": "easy",
              "topic": "arrays"
            },
            {
              "id": "q24f",
              "type": "dragAndDrop",
              "question": "Arrange these steps of bubble sort in the correct order:",
              "items": [
                "Start with the first element",
                "Compare adjacent elements",
                "Swap if they are in wrong order",
                "Move to next pair",
                "Repeat until no swaps needed"
              ],
              "correctOrder": [0, 1, 2, 3, 4],
              "explanation": "Bubble sort systematically compares adjacent elements and swaps them if needed, repeating until the array is sorted.",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q24g",
              "type": "interactiveVisualization",
              "question": "Click the array elements in the order they would be accessed during binary search to find the value 7:",
              "visualizationData": {
                "array": [1, 3, 5, 7, 9, 11, 13, 15],
                "target": 7,
                "type": "binarySearch"
              },
                                            "correctSequence": [3, 1, 2],
               "explanation": "Binary search checks the middle element (9), then the left half middle (3), then finds 7.",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q24h",
              "type": "codeOutput",
              "question": "What will this code output?",
              "code": "let arr = [1, 2, 3, 4, 5];\nlet result = [];\nfor (let i = arr.length - 1; i >= 0; i--) {\n  result.push(arr[i]);\n}\nconsole.log(result);",
              "options": ["[1, 2, 3, 4, 5]", "[5, 4, 3, 2, 1]", "[5, 4, 3, 2, 1, 1, 2, 3, 4, 5]", "Error"],
              "correctAnswer": "[5, 4, 3, 2, 1]",
              "explanation": "The loop iterates backwards through the array, pushing elements to result in reverse order.",
              "difficulty": "easy",
              "topic": "arrays"
            },
            {
              "id": "q24i",
              "type": "algorithmTrace",
              "question": "Trace through the insertion sort algorithm step by step:",
              "initialArray": [5, 2, 8, 1, 9],
              "steps": [
                { "step": 1, "array": [2, 5, 8, 1, 9], "explanation": "Insert 2 in correct position" },
                { "step": 2, "array": [2, 5, 8, 1, 9], "explanation": "8 is already in correct position" },
                { "step": 3, "array": [1, 2, 5, 8, 9], "explanation": "Insert 1 at the beginning" },
                { "step": 4, "array": [1, 2, 5, 8, 9], "explanation": "Insert 9 at the end" }
              ],
              "userTask": "Select the correct array state after each step",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q24j",
              "type": "interactiveDebugging",
              "question": "Find and fix the bug in this binary search implementation:",
              "buggyCode": "function binarySearch(arr, target) {\n  let left = 0;\n  let right = arr.length;\n  \n  while (left < right) {\n    let mid = Math.floor((left + right) / 2);\n    \n    if (arr[mid] === target) {\n      return mid;\n    } else if (arr[mid] < target) {\n      left = mid;\n    } else {\n      right = mid;\n    }\n  }\n  \n  return -1;\n}",
              "bugs": [
                {
                  "line": 3,
                  "issue": "Should be arr.length - 1",
                  "explanation": "Right boundary should be the last valid index"
                },
                {
                  "line": 10,
                  "issue": "Should be mid + 1",
                  "explanation": "Need to move left boundary past mid to avoid infinite loop"
                }
              ],
              "difficulty": "hard",
              "topic": "arrays"
            },
            {
              "id": "q24k",
              "type": "performanceComparison",
              "question": "Compare the time complexities of these array operations:",
              "operations": [
                { "name": "Linear Search", "complexity": "O(n)" },
                { "name": "Binary Search", "complexity": "O(log n)" },
                { "name": "Array Access", "complexity": "O(1)" },
                { "name": "Insertion at End", "complexity": "O(1)" }
              ],
              "userTask": "Rank from fastest to slowest",
                                            "correctRanking": [2, 1, 3, 0],
               "explanation": "O(1) operations are fastest, followed by O(log n), then O(n).",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q24l",
              "type": "memoryLayout",
              "question": "How would this array be laid out in memory?",
              "array": [10, 20, 30, 40],
              "visualizationData": {
                "baseAddress": 1000,
                "elementSize": 4,
                "type": "integer"
              },
              "userTask": "Click on the correct memory addresses",
              "correctAddresses": [1000, 1004, 1008, 1012],
              "explanation": "Arrays store elements in contiguous memory locations, each integer taking 4 bytes.",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q24m",
              "type": "interactiveAnimation",
              "question": "Control the animation to show how merge sort divides and conquers:",
              "animationData": {
                "array": [8, 3, 1, 6, 4, 7, 2, 5],
                "algorithm": "mergeSort",
                "controls": ["play", "pause", "step", "reset", "speed"]
              },
              "challenges": [
                "Pause when the array is fully divided",
                "Step through the merge process",
                "Identify when the first merge happens"
              ],
              "explanation": "Merge sort recursively divides the array, then merges sorted subarrays.",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q24n",
              "type": "buildDataStructure",
              "question": "Build a 2D array representation of a matrix:",
              "task": "Create a 3x3 matrix with values 1-9",
              "constraints": {
                "rows": 3,
                "cols": 3,
                "startValue": 1
              },
              "targetStructure": [
                [1, 2, 3],
                [4, 5, 6],
                [7, 8, 9]
              ],
              "tools": ["drag", "input", "generate"],
              "explanation": "2D arrays represent matrices where each element is accessed by row and column indices.",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q24o",
              "type": "complexityAnalysis",
              "question": "Analyze the time complexity of this nested loop:",
              "code": "for (let i = 0; i < n; i++) {\n  for (let j = i; j < n; j++) {\n    // O(1) operation\n  }\n}",
              "analysisSteps": [
                { "step": "Outer loop runs n times", "complexity": "O(n)" },
                { "step": "Inner loop runs n-i times", "complexity": "O(n-i)" },
                { "step": "Total iterations", "complexity": "O(n²)" }
              ],
              "userTask": "Select the correct complexity for each step",
              "explanation": "The inner loop runs fewer times as i increases, but the total is still O(n²).",
              "difficulty": "hard",
              "topic": "arrays"
            }
          ]
        },
        {
          "id": "array-advanced",
          "title": "Advanced Topics",
          "description": "Advanced array techniques and optimization problems",
          "xpReward": 85,
          "questions": [
            {
              "id": "q24a",
              "type": "mcq",
              "question": "What is the time complexity of finding the maximum subarray sum using Kadane's algorithm?",
              "options": ["O(n log n)", "O(n²)", "O(n)", "O(1)"],
              "correctAnswer": "O(n)",
              "explanation": "Kadane's algorithm finds the maximum subarray sum in linear time by maintaining running sum and maximum.",
              "difficulty": "hard",
              "topic": "arrays"
            },
            {
              "id": "q24b",
              "type": "mcq",
              "question": "In a sliding window approach for finding maximum sum of k consecutive elements, what is the time complexity?",
              "options": ["O(n*k)", "O(n)", "O(k)", "O(n log k)"],
              "correctAnswer": "O(n)",
              "explanation": "Sliding window maintains a window of k elements and slides it across the array, resulting in O(n) time.",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q24c",
              "type": "fillInBlank",
              "question": "The Boyer-Moore majority vote algorithm finds an element that appears more than _____ times in an array.",
              "acceptedAnswers": ["n/2", "n / 2", "n/two", "n / two", "half", "Half", "HALF"],
              "explanation": "Boyer-Moore algorithm finds the majority element that appears more than n/2 times in the array.",
              "difficulty": "hard",
              "topic": "arrays"
            },
            {
              "id": "q24d",
              "type": "mcq",
              "question": "What is the space complexity of merging two sorted arrays in-place?",
              "options": ["O(1)", "O(n)", "O(log n)", "O(n log n)"],
              "correctAnswer": "O(1)",
              "explanation": "In-place merging uses constant extra space by rearranging elements within the existing arrays.",
              "difficulty": "hard",
              "topic": "arrays"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-2", 
      "title": "Hash Maps",
      "description": "Master key-value data structures and hashing techniques",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "hashmap-fundamentals",
          "title": "Basics",
          "description": "Understanding hash tables and key-value storage",
          "xpReward": 60,
          "questions": [
            {
              "id": "q25",
              "type": "mcq",
              "question": "What is the primary purpose of a hash map (dictionary)?",
              "options": ["Store elements in order", "Map keys to values for fast lookup", "Sort data automatically", "Compress data"],
              "correctAnswer": "Map keys to values for fast lookup",
              "explanation": "Hash maps are designed to store key-value pairs and provide fast O(1) average-case lookup, insertion, and deletion operations.",
              "difficulty": "easy",
              "topic": "hashmap"
            },
            {
              "id": "q26",
              "type": "fillInBlank",
              "question": "A hash map uses a _____ function to convert keys into array indices.",
              "acceptedAnswers": ["hash", "Hash", "HASH", "hashing", "Hashing", "HASHING"],
              "explanation": "A hash function takes a key and converts it into an array index where the corresponding value will be stored.",
              "difficulty": "easy",
              "topic": "hashmap"
            },
            {
              "id": "q27",
              "type": "mcq",
              "question": "What is the average time complexity for lookup in a hash map?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
              "correctAnswer": "O(1)",
              "explanation": "Hash maps provide O(1) average-case time complexity for lookup operations due to direct index access via hashing.",
              "difficulty": "easy",
              "topic": "hashmap"
            },
            {
              "id": "q28",
              "type": "mcq",
              "question": "What happens when two different keys produce the same hash value?",
              "options": ["One key overwrites the other", "A collision occurs", "The hash map breaks", "Keys are merged"],
              "correctAnswer": "A collision occurs",
              "explanation": "When different keys hash to the same index, it's called a collision. Hash maps need strategies to handle collisions.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q29",
              "type": "fillInBlank",
              "question": "Hash maps are also known as hash tables, dictionaries, or _____ arrays.",
              "acceptedAnswers": ["associative", "Associative", "ASSOCIATIVE", "associative-array", "Associative-Array", "ASSOCIATIVE-ARRAY"],
              "explanation": "Associative arrays associate keys with values, allowing you to look up values using their corresponding keys.",
              "difficulty": "easy",
              "topic": "hashmap"
            }
          ]
        },
        {
          "id": "hash-functions",
          "title": "Functions",
          "description": "Understanding how hash functions work and their characteristics",
          "xpReward": 65,
          "questions": [
            {
              "id": "q30",
              "type": "mcq",
              "question": "What is a key property that a good hash function should have?",
              "options": ["Always return the same value", "Distribute keys uniformly across buckets", "Only work with strings", "Be reversible"],
              "correctAnswer": "Distribute keys uniformly across buckets",
              "explanation": "A good hash function should distribute keys uniformly to minimize collisions and ensure balanced performance.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q31",
              "type": "fillInBlank",
              "question": "A hash function should be _____, meaning the same key always produces the same hash value.",
              "acceptedAnswers": ["deterministic", "Deterministic", "DETERMINISTIC", "deterministic-function", "Deterministic-Function", "DETERMINISTIC-FUNCTION"],
              "explanation": "Deterministic behavior ensures that looking up the same key will always check the same location in the hash table.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q32",
              "type": "mcq",
              "question": "What is the 'avalanche effect' in hash functions?",
              "options": ["Hash values increase exponentially", "Small input changes cause large output changes", "Function becomes slower", "Memory usage doubles"],
              "correctAnswer": "Small input changes cause large output changes",
              "explanation": "The avalanche effect means small changes to input should produce significantly different hash values, improving distribution.",
              "difficulty": "hard",
              "topic": "hashmap"
            },
            {
              "id": "q33",
              "type": "mcq",
              "question": "Why should hash functions be fast to compute?",
              "options": ["To save memory", "To maintain O(1) performance", "To reduce collisions", "To improve security"],
              "correctAnswer": "To maintain O(1) performance",
              "explanation": "If hash function computation is slow, it would degrade the overall O(1) performance promise of hash maps.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q34",
              "type": "fillInBlank",
              "question": "The result of applying a hash function to a key is called a hash _____ or hash code.",
              "acceptedAnswers": ["value", "Value", "VALUE", "hash-code", "HashCode", "HASH-CODE"],
              "explanation": "The hash value or hash code is the numerical result that determines where to store/find the key-value pair.",
              "difficulty": "easy",
              "topic": "hashmap"
            }
          ]
        },
        {
          "id": "collision-handling",
          "title": "Collisions",
          "description": "Methods for handling hash collisions",
          "xpReward": 70,
          "questions": [
            {
              "id": "q35",
              "type": "mcq",
              "question": "What is chaining as a collision resolution method?",
              "options": ["Linking hash functions together", "Storing collided items in linked lists", "Creating hash chains", "Connecting multiple hash maps"],
              "correctAnswer": "Storing collided items in linked lists",
              "explanation": "Chaining handles collisions by maintaining a linked list at each bucket to store all items that hash to the same index.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q36",
              "type": "mcq",
              "question": "What is open addressing in hash tables?",
              "options": ["Tables that can be accessed by anyone", "Finding alternative locations for collided items", "Hash tables without collision handling", "Dynamic resizing of tables"],
              "correctAnswer": "Finding alternative locations for collided items",
              "explanation": "Open addressing resolves collisions by probing for alternative empty slots in the hash table when collisions occur.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q37",
              "type": "fillInBlank",
              "question": "Linear probing is a type of _____ addressing where we check the next sequential slot.",
              "acceptedAnswers": ["open", "Open", "OPEN", "linear-probing", "Linear-Probing", "LINEAR-PROBING", "sequential", "Sequential", "SEQUENTIAL"],
              "explanation": "Linear probing is an open addressing technique that checks slots sequentially (i, i+1, i+2, ...) to find an empty position.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q38",
              "type": "mcq",
              "question": "What is a disadvantage of linear probing?",
              "options": ["Uses too much memory", "Creates clustering of elements", "Too slow for large datasets", "Cannot handle string keys"],
              "correctAnswer": "Creates clustering of elements",
              "explanation": "Linear probing can create clusters of consecutive occupied slots, leading to longer probe sequences and degraded performance.",
              "difficulty": "hard",
              "topic": "hashmap"
            },
            {
              "id": "q39",
              "type": "mcq",
              "question": "What is quadratic probing?",
              "options": ["Probing with quadratic hash functions", "Checking slots at quadratic intervals (i²)", "Using four probes maximum", "Squaring the key before hashing"],
              "correctAnswer": "Checking slots at quadratic intervals (i²)",
              "explanation": "Quadratic probing checks slots at quadratic distances (i, i+1², i+2², i+3², ...) to reduce clustering compared to linear probing.",
              "difficulty": "hard",
              "topic": "hashmap"
            }
          ]
        },
        {
          "id": "hashmap-operations",
          "title": "Operations",
          "description": "Core operations and their performance characteristics",
          "xpReward": 55,
          "questions": [
            {
              "id": "q40",
              "type": "mcq",
              "question": "What is the worst-case time complexity for hash map operations?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
              "correctAnswer": "O(n)",
              "explanation": "In the worst case (all keys hash to same bucket), hash map operations degrade to O(n) when using chaining or when the table is full with open addressing.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q41",
              "type": "fillInBlank",
              "question": "The _____ factor is the ratio of the number of stored elements to the size of the hash table.",
              "acceptedAnswers": ["load", "Load", "LOAD", "load-factor", "Load-Factor", "LOAD-FACTOR", "load-factor-ratio", "Load-Factor-Ratio", "LOAD-FACTOR-RATIO"],
              "explanation": "Load factor = (number of elements) / (table size). It's used to determine when to resize the hash table.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q42",
              "type": "mcq",
              "question": "When should a hash map typically be resized?",
              "options": ["When it's completely full", "When load factor exceeds a threshold (e.g., 0.75)", "Every 100 insertions", "Never"],
              "correctAnswer": "When load factor exceeds a threshold (e.g., 0.75)",
              "explanation": "Hash maps typically resize when load factor exceeds 0.75 to maintain good performance and minimize collisions.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q43",
              "type": "mcq",
              "question": "What happens during hash map resizing?",
              "options": ["Only the table size changes", "All elements are rehashed and moved", "Old elements are deleted", "Table is compressed"],
              "correctAnswer": "All elements are rehashed and moved",
              "explanation": "During resizing, a new larger table is created and all existing elements are rehashed and inserted into new positions.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q44",
              "type": "fillInBlank",
              "question": "Hash map deletion in open addressing often uses _____ deletion to avoid breaking probe sequences.",
              "acceptedAnswers": ["lazy", "Lazy", "LAZY", "lazy-deletion", "Lazy-Deletion", "LAZY-DELETION", "deletion", "Deletion", "DELETION"],
              "explanation": "Lazy deletion marks slots as 'deleted' rather than truly empty to maintain probe sequences for other elements.",
              "difficulty": "hard",
              "topic": "hashmap"
            }
          ]
        },
        {
          "id": "hashmap-applications",
          "title": "Applications",
          "description": "Real-world applications and problem-solving with hash maps",
          "xpReward": 60,
          "questions": [
            {
              "id": "q45",
              "type": "mcq",
              "question": "Which problem is best solved using a hash map?",
              "options": ["Finding the maximum element", "Checking if array contains duplicates", "Sorting an array", "Finding array length"],
              "correctAnswer": "Checking if array contains duplicates",
              "explanation": "Hash maps excel at membership testing and duplicate detection with O(1) average lookup time.",
              "difficulty": "easy",
              "topic": "hashmap"
            },
            {
              "id": "q46",
              "type": "fillInBlank",
              "question": "To count the frequency of elements in an array, you would use a hash map where keys are elements and values are their _____.",
              "acceptedAnswers": ["counts", "Counts", "COUNTS", "frequency", "Frequency", "FREQUENCY", "count", "Count", "COUNT"],
              "explanation": "Frequency counting maps each unique element to how many times it appears in the dataset.",
              "difficulty": "easy", 
              "topic": "hashmap"
            },
            {
              "id": "q47",
              "type": "mcq",
              "question": "What is a common use case for hash maps in caching?",
              "options": ["Storing cache in order", "Fast key-based cache lookup", "Compressing cached data", "Sorting cache entries"],
              "correctAnswer": "Fast key-based cache lookup",
              "explanation": "Hash maps provide O(1) lookup time, making them ideal for caching where fast retrieval by key is essential.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q48",
              "type": "mcq",
              "question": "How would you find the first non-repeating character in a string using hash maps?",
              "options": ["Count frequency, then find first with count=1", "Sort string first", "Use two hash maps", "Check each character individually"],
              "correctAnswer": "Count frequency, then find first with count=1",
              "explanation": "First pass counts frequency of each character, second pass finds the first character with frequency 1.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q49",
              "type": "fillInBlank",
              "question": "In database systems, hash maps are commonly used to implement _____ joins for fast lookups.",
              "acceptedAnswers": ["hash", "Hash", "HASH", "hash-join", "Hash-Join", "HASH-JOIN", "hash-joins", "Hash-Joins", "HASH-JOINS"],
              "explanation": "Hash joins use hash maps to build lookup tables for one relation, then probe with the other relation for matches.",
              "difficulty": "hard",
              "topic": "hashmap"
            }
          ]
        },
        {
          "id": "hashmap-performance",
          "title": "Performance Analysis",
          "description": "Advanced performance considerations and optimization techniques",
          "xpReward": 75,
          "questions": [
            {
              "id": "q49a",
              "type": "mcq",
              "question": "What happens to hash map performance when the load factor approaches 1.0?",
              "options": ["Performance improves", "More collisions occur, degrading performance", "Memory usage decreases", "Hash function becomes faster"],
              "correctAnswer": "More collisions occur, degrading performance",
              "explanation": "As load factor approaches 1.0, the hash table becomes nearly full, leading to more collisions and longer probe sequences.",
              "difficulty": "hard",
              "topic": "hashmap"
            },
            {
              "id": "q49b",
              "type": "fillInBlank",
              "question": "Cuckoo hashing guarantees O(1) worst-case lookup time but may require _____ during insertion.",
              "acceptedAnswers": ["rehashing", "Rehashing", "REHASHING", "rehashing-on-insert", "Rehashing-On-Insert", "REHASHING-ON-INSERT", "rehashing-on-insert-only", "Rehashing-On-Insert-Only", "REHASHING-ON-INSERT-ONLY"],
              "explanation": "Cuckoo hashing may need to rehash the entire table if cycles occur during insertion, but guarantees constant lookup time.",
              "difficulty": "hard",
              "topic": "hashmap"
            },
            {
              "id": "q49c",
              "type": "mcq",
              "question": "Which technique can improve cache performance in hash tables?",
              "options": ["Using larger hash codes", "Robin Hood hashing", "Increasing collision rate", "Using more memory"],
              "correctAnswer": "Robin Hood hashing",
              "explanation": "Robin Hood hashing minimizes probe distances and improves cache locality by evicting elements with shorter probe distances.",
              "difficulty": "hard",
              "topic": "hashmap"
            },
            {
              "id": "q49d",
              "type": "mcq",
              "question": "What is the main advantage of consistent hashing in distributed systems?",
              "options": ["Faster lookups", "Minimal data movement when nodes are added/removed", "Better collision resolution", "Lower memory usage"],
              "correctAnswer": "Minimal data movement when nodes are added/removed",
              "explanation": "Consistent hashing distributes keys across nodes such that adding or removing nodes requires minimal redistribution of data.",
              "difficulty": "hard",
              "topic": "hashmap"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-3",
      "title": "Stacks",
      "description": "LIFO data structure for efficient operations",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "stack-basics",
          "title": "Basics",
          "description": "Understanding LIFO principle and basic operations",
          "xpReward": 55,
          "questions": [
            {
              "id": "q50",
              "type": "mcq",
              "question": "What does LIFO stand for in the context of stacks?",
              "options": ["Last In First Out", "Layered Input First Output", "List Insertion File Output", "Local-In-First-Out"],
              "correctAnswer": "Last In First Out",
              "explanation": "LIFO means the last element added to the stack is the first one to be removed.",
              "difficulty": "easy",
              "topic": "stack"
            },
            {
              "id": "q51",
              "type": "mcq",
              "question": "What is the primary characteristic that distinguishes stack behavior from queue behavior?",
              "options": ["Stacks are faster than queues", "Stacks reverse the order of elements during processing", "Stacks use less memory than queues", "Stacks only work with integers"],
              "correctAnswer": "Stacks reverse the order of elements during processing",
              "explanation": "Stacks follow LIFO (Last In First Out), which inherently reverses the order of elements compared to their insertion order, while queues maintain FIFO order.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q52",
              "type": "mcq",
              "question": "What happens when you try to pop from an empty stack?",
              "options": ["Returns null", "Stack underflow error", "Returns 0", "Creates new element"],
              "correctAnswer": "Stack underflow error",
              "explanation": "Attempting to pop from an empty stack results in a stack underflow error.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q52a",
              "type": "mcq",
              "question": "In what scenario would you choose a stack over an array for temporary storage?",
              "options": ["When you need random access to elements", "When you need to access elements in reverse order of insertion", "When you need to sort the elements", "When you need to search for specific values"],
              "correctAnswer": "When you need to access elements in reverse order of insertion",
              "explanation": "Stacks are ideal when you need to access elements in reverse order of their insertion, such as in undo operations or expression evaluation.",
              "difficulty": "hard",
              "topic": "stack"
            },
            {
              "id": "q52b",
              "type": "mcq",
              "question": "What operation allows you to view the top element without removing it?",
              "options": ["push", "pop", "peek", "size"],
              "correctAnswer": "peek",
              "explanation": "Peek (or top) operation returns the top element without removing it from the stack.",
              "difficulty": "easy",
              "topic": "stack"
            },
            {
              "id": "q52c",
              "type": "mcq",
              "question": "What is the time complexity of push and pop operations on a stack?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
              "correctAnswer": "O(1)",
              "explanation": "Both push and pop operations on a stack are O(1) constant time as they only modify the top element.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q52d",
              "type": "mcq",
              "question": "Which limitation becomes critical when implementing a stack using a fixed-size array?",
              "options": ["Cannot access middle elements", "Risk of stack overflow when capacity is exceeded", "Cannot determine current size", "Slower access time"],
              "correctAnswer": "Risk of stack overflow when capacity is exceeded",
              "explanation": "Fixed-size array implementations face the risk of stack overflow when trying to push elements beyond the allocated capacity.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q52e",
              "type": "mcq",
              "question": "Which of these is NOT a typical stack operation?",
              "options": ["push", "pop", "peek", "sort"],
              "correctAnswer": "sort",
              "explanation": "Stacks don't have a built-in sort operation. Basic operations are push, pop, peek, isEmpty, and size.",
              "difficulty": "easy",
              "topic": "stack"
            }
          ]
        },
        {
          "id": "stack-applications",
          "title": "Stack Applications",
          "description": "Real-world uses of stacks",
          "xpReward": 65,
          "questions": [
            {
              "id": "q55",
              "type": "mcq",
              "question": "Which data structure is best for implementing function call management?",
              "options": ["Queue", "Stack", "Array", "Hash Map"],
              "correctAnswer": "Stack",
              "explanation": "Stacks are perfect for function calls due to LIFO - last called function returns first.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q55a",
              "type": "mcq",
              "question": "What is a call stack used for in programming?",
              "options": ["Storing variables", "Managing function calls and returns", "Sorting data", "Memory allocation"],
              "correctAnswer": "Managing function calls and returns",
              "explanation": "The call stack tracks function calls, local variables, and return addresses using LIFO principle.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q55b",
              "type": "fillInBlank",
              "question": "Stacks are commonly used to check for balanced _____ in expressions.",
              "acceptedAnswers": ["parentheses", "Parentheses", "PARENTHESES", "brackets", "Brackets", "BRACKETS", "braces", "Braces", "BRACES"],
              "explanation": "Stacks are ideal for checking balanced parentheses, brackets, and braces in mathematical expressions.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q55c",
              "type": "mcq",
              "question": "How would you use a stack to evaluate a postfix expression?",
              "options": ["Push operators, pop operands", "Push operands, pop when seeing operators", "Push everything in order", "Use two stacks"],
              "correctAnswer": "Push operands, pop when seeing operators",
              "explanation": "In postfix evaluation, push operands onto stack and when you see an operator, pop required operands, compute, and push result back.",
              "difficulty": "hard",
              "topic": "stack"
            },
            {
              "id": "q55d",
              "type": "mcq",
              "question": "Which application uses stack for tracking history?",
              "options": ["Database indexing", "Web browser back button", "File compression", "Network routing"],
              "correctAnswer": "Web browser back button",
              "explanation": "Browser back button uses a stack to track page history - last visited page is first to return to.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q55e",
              "type": "fillInBlank",
              "question": "Undo operations in text editors are typically implemented using a _____.",
              "acceptedAnswers": ["stack", "Stack", "STACK", "stack-based", "Stack-Based", "STACK-BASED", "stack-based-undo", "Stack-Based-Undo", "STACK-BASED-UNDO"],
              "explanation": "Undo functionality uses a stack to store actions in reverse order - last action is first to be undone.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q55f",
              "type": "mcq",
              "question": "In converting infix to postfix notation, what do you do when encountering an opening parenthesis?",
              "options": ["Ignore it", "Push it onto the stack", "Pop from stack", "Add to output"],
              "correctAnswer": "Push it onto the stack",
              "explanation": "Opening parentheses are pushed onto the stack to mark the beginning of a subexpression.",
              "difficulty": "hard",
              "topic": "stack"
            },
            {
              "id": "q55g",
              "type": "mcq",
              "question": "Which sorting algorithm uses a stack internally?",
              "options": ["Bubble sort", "Merge sort", "Quick sort (recursive)", "Selection sort"],
              "correctAnswer": "Quick sort (recursive)",
              "explanation": "Recursive quick sort uses the call stack to manage recursive calls for partitioning subarrays.",
              "difficulty": "hard",
              "topic": "stack"
            },
            {
              "id": "q55h",
              "type": "fillInBlank",
              "question": "Depth-First Search (DFS) traversal can be implemented using a _____ or recursion.",
              "acceptedAnswers": ["stack", "Stack", "STACK", "stack-based", "Stack-Based", "STACK-BASED", "stack-based-dfs", "Stack-Based-DFS", "STACK-BASED-DFS"],
              "explanation": "DFS uses a stack (explicit or implicit via recursion) to explore as deep as possible before backtracking.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "stack-problems",
              "title": "Stack Problems",
              "description": "Classic coding and interview problems involving stacks",
              "xpReward": 75,
              "questions": [
                {
                  "id": "q55n",
                  "type": "mcq",
                  "question": "Which stack-based approach is used to solve the Next Greater Element problem?",
                  "options": ["Use two stacks", "Use a monotonic stack", "Sort the array", "Use recursion"],
                  "correctAnswer": "Use a monotonic stack",
                  "explanation": "A monotonic stack helps efficiently find the next greater element for each item in a single pass.",
                  "difficulty": "hard",
                  "topic": "stack"
                },
                {
                  "id": "q55o",
                  "type": "mcq",
                  "question": "What is the main idea behind the Min Stack problem?",
                  "options": ["Track only the top element", "Track the minimum value at each push", "Sort the stack after each operation", "Use a queue"],
                  "correctAnswer": "Track the minimum value at each push",
                  "explanation": "A Min Stack keeps track of the minimum value at each push to allow O(1) retrieval of the minimum.",
                  "difficulty": "hard",
                  "topic": "stack"
                },
                {
                  "id": "q55p",
                  "type": "mcq",
                  "question": "Which stack-based algorithm is used to find the largest rectangle in a histogram?",
                  "options": ["Monotonic stack", "DFS", "BFS", "Heap"],
                  "correctAnswer": "Monotonic stack",
                  "explanation": "A monotonic stack is used to efficiently compute the largest rectangle in a histogram in O(n) time.",
                  "difficulty": "hard",
                  "topic": "stack"
                }
              ]
            },
            {
              "id": "stack-parsing",
              "title": "Stack in Parsing and Evaluation",
              "description": "Using stacks for parsing and evaluating expressions",
              "xpReward": 70,
              "questions": [
                {
                  "id": "q55q",
                  "type": "mcq",
                  "question": "Which notation is easiest to evaluate using a stack?",
                  "options": ["Infix", "Prefix", "Postfix (Reverse Polish Notation)", "All are equally easy"],
                  "correctAnswer": "Postfix (Reverse Polish Notation)",
                  "explanation": "Postfix expressions can be evaluated in a single left-to-right pass using a stack.",
                  "difficulty": "medium",
                  "topic": "stack"
                },
                {
                  "id": "q55r",
                  "type": "mcq",
                  "question": "In the Shunting-yard algorithm for converting infix to postfix notation, what is the purpose of the operator stack?",
                  "options": [
                    "To store operands temporarily",
                    "To hold operators and manage precedence",
                    "To reverse the input expression",
                    "To count the number of operators"
                  ],
                  "correctAnswer": "To hold operators and manage precedence",
                  "explanation": "The Shunting-yard algorithm uses an operator stack to manage operator precedence and associativity rules, ensuring correct conversion from infix to postfix notation.",
                  "difficulty": "hard",
                  "topic": "stack"
                },
                {
                  "id": "q55s",
                  "type": "mcq",
                  "question": "What is the main advantage of using a stack for parsing nested structures?",
                  "options": ["It sorts the input", "It allows tracking of open/close pairs", "It speeds up multiplication", "It reduces memory usage"],
                  "correctAnswer": "It allows tracking of open/close pairs",
                  "explanation": "Stacks help track open and close pairs (like parentheses) in nested structures, ensuring correct matching.",
                  "difficulty": "medium",
                  "topic": "stack"
                }
              ]
            },
            {
              "id": "stack-recursion",
              "title": "Stack and Recursion",
              "description": "Understanding the relationship between recursion and the call stack",
              "xpReward": 65,
              "questions": [
                {
                  "id": "q55t",
                  "type": "mcq",
                  "question": "What does each recursive function call create on the call stack?",
                  "options": ["A new thread", "A new stack frame", "A new variable", "A new process"],
                  "correctAnswer": "A new stack frame",
                  "explanation": "Each recursive call creates a new stack frame to store local variables and return address.",
                  "difficulty": "medium",
                  "topic": "stack"
                },
                {
                  "id": "q55u",
                  "type": "mcq",
                  "question": "What happens if recursion goes too deep without a base case?",
                  "options": ["Stack overflow", "Infinite loop", "Program runs faster", "Memory leak"],
                  "correctAnswer": "Stack overflow",
                  "explanation": "Without a base case, recursive calls keep adding stack frames until the stack limit is exceeded, causing a stack overflow.",
                  "difficulty": "medium",
                  "topic": "stack"
                },
                {
                  "id": "q55v",
                  "type": "fillInBlank",
                  "question": "The call stack stores local variables and the _____ address for each function call.",
                  "acceptedAnswers": ["return", "Return", "RETURN", "return-address", "Return-Address", "RETURN-ADDRESS", "return-address-pointer", "Return-Address-Pointer", "RETURN-ADDRESS-POINTER"],
                  "explanation": "The return address tells the program where to continue after a function call completes.",
                  "difficulty": "medium",
                  "topic": "stack"
                }
              ]
            },
            {
              "id": "stack-backtracking",
              "title": "Stack in Backtracking",
              "description": "How stacks are used in backtracking algorithms",
              "xpReward": 70,
              "questions": [
                {
                  "id": "q55w",
                  "type": "mcq",
                  "question": "Which data structure is most commonly used to implement backtracking?",
                  "options": ["Queue", "Stack", "Heap", "Array"],
                  "correctAnswer": "Stack",
                  "explanation": "Backtracking algorithms use a stack to keep track of choices and revert to previous states.",
                  "difficulty": "medium",
                  "topic": "stack"
                },
                {
                  "id": "q55x",
                  "type": "mcq",
                  "question": "In maze solving with backtracking, what does the stack store?",
                  "options": ["All possible paths", "Visited cells", "Current path positions", "Maze size"],
                  "correctAnswer": "Current path positions",
                  "explanation": "The stack stores the current path positions so you can backtrack when hitting a dead end.",
                  "difficulty": "medium",
                  "topic": "stack"
                },
                {
                  "id": "q55y",
                  "type": "fillInBlank",
                  "question": "In the N-Queens problem, the stack is used to keep track of the _____ of queens placed so far.",
                  "acceptedAnswers": ["positions", "Positions", "POSITIONS", "queen-positions", "Queen-Positions", "QUEEN-POSITIONS", "queen-position", "Queen-Position", "QUEEN-POSITION"],
                  "explanation": "The stack tracks the positions of queens placed so you can backtrack and try new configurations.",
                  "difficulty": "hard",
                  "topic": "stack"
                }
              ]
            }
          ]
        },
        {
          "id": "monotonic-stacks",
          "title": "Monotonic Stacks",
          "description": "Specialized stacks maintaining monotonic order",
          "xpReward": 80,
          "questions": [
            {
              "id": "q55z",
              "type": "mcq",
              "question": "What property does a monotonic increasing stack maintain?",
              "options": ["Elements are in ascending order from bottom to top", "Elements are in descending order from bottom to top", "All elements are equal", "Stack size increases monotonically"],
              "correctAnswer": "Elements are in ascending order from bottom to top",
              "explanation": "A monotonic increasing stack maintains elements in non-decreasing order from bottom to top.",
              "difficulty": "hard",
              "topic": "stack"
            },
            {
              "id": "q55aa",
              "type": "fillInBlank",
              "question": "Monotonic stacks are commonly used to solve the _____ greater element problem efficiently.",
              "acceptedAnswers": ["next", "Next", "NEXT", "next-greater", "Next-Greater", "NEXT-GREATER", "next-greater-element", "Next-Greater-Element", "NEXT-GREATER-ELEMENT"],
              "explanation": "Monotonic stacks efficiently find the next greater element for each element in an array.",
              "difficulty": "hard",
              "topic": "stack"
            },
            {
              "id": "q55bb",
              "type": "mcq",
              "question": "What is the time complexity of solving the next greater element problem using a monotonic stack?",
              "options": ["O(n²)", "O(n log n)", "O(n)", "O(1)"],
              "correctAnswer": "O(n)",
              "explanation": "Each element is pushed and popped at most once, resulting in O(n) time complexity.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q55cc",
              "type": "mcq",
              "question": "In the largest rectangle in histogram problem, what does the monotonic stack store?",
              "options": ["Heights of bars", "Areas of rectangles", "Indices of bars", "Width of rectangles"],
              "correctAnswer": "Indices of bars",
              "explanation": "The stack stores indices of bars in increasing order of their heights to efficiently compute areas.",
              "difficulty": "hard",
              "topic": "stack"
            }
          ]
        },
        {
          "id": "stack-optimization",
          "title": "Stack Optimizations",
          "description": "Advanced stack implementations and space optimizations",
          "xpReward": 75,
          "questions": [
            {
              "id": "q55dd",
              "type": "mcq",
              "question": "What is the key idea behind implementing multiple stacks in a single array?",
              "options": ["Use separate arrays for each stack", "Divide array into equal parts", "Use two ends and grow towards middle", "Stack elements randomly"],
              "correctAnswer": "Use two ends and grow towards middle",
              "explanation": "Two stacks can share an array by starting from opposite ends and growing towards each other.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q55ee",
              "type": "fillInBlank",
              "question": "A _____ stack can efficiently return the minimum element in O(1) time.",
              "acceptedAnswers": ["min", "Min", "MIN", "min-stack", "Min-Stack", "MIN-STACK", "min-stack-top", "Min-Stack-Top", "MIN-STACK-TOP"],
              "explanation": "A min stack maintains the minimum element at each level to provide O(1) minimum retrieval.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q55ff",
              "type": "mcq",
              "question": "How can you implement a stack that supports getMin() in O(1) time and O(1) extra space?",
              "options": ["Use auxiliary stack", "Store differences from minimum", "Sort the stack", "Use heap"],
              "correctAnswer": "Store differences from minimum",
              "explanation": "By storing differences from minimum and updating minimum dynamically, we can achieve O(1) space.",
              "difficulty": "hard",
              "topic": "stack"
            },
            {
              "id": "q55gg",
              "type": "mcq",
              "question": "What is the space complexity of implementing a stack using recursion?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
              "correctAnswer": "O(n)",
              "explanation": "Recursive implementation uses the call stack, which can grow to O(n) in the worst case.",
              "difficulty": "medium",
              "topic": "stack"
            }
          ]
        },
        {
          "id": "expression-evaluation",
          "title": "Expression Evaluation",
          "description": "Advanced expression parsing and evaluation techniques",
          "xpReward": 85,
          "questions": [
            {
              "id": "q55hh",
              "type": "mcq",
              "question": "In the shunting yard algorithm, what determines operator precedence handling?",
              "options": ["Stack size", "Operator associativity and precedence", "Input order", "Output queue"],
              "correctAnswer": "Operator associativity and precedence",
              "explanation": "The shunting yard algorithm uses operator precedence and associativity rules to convert infix to postfix.",
              "difficulty": "hard",
              "topic": "stack"
            },
            {
              "id": "q55ii",
              "type": "fillInBlank",
              "question": "When evaluating a postfix expression, operands are _____ onto the stack and operators _____ operands from the stack.",
              "acceptedAnswers": ["pushed, pop", "Pushed, Pop", "PUSHED, POP", "pushed-onto-stack, pop-from-stack", "Pushed-Onto-Stack, Pop-From-Stack", "PUSHED-ONTO-STACK, POP-FROM-STACK", "push-onto-stack, pop-from-stack", "Push-Onto-Stack, Pop-From-Stack", "PUSH-ONTO-STACK, POP-FROM-STACK"],
              "explanation": "Postfix evaluation pushes operands onto stack and pops them when operators are encountered.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q55jj",
              "type": "mcq",
              "question": "What is the advantage of postfix notation over infix notation for computer evaluation?",
              "options": ["Shorter expressions", "No need for parentheses or precedence rules", "Faster parsing", "Less memory usage"],
              "correctAnswer": "No need for parentheses or precedence rules",
              "explanation": "Postfix notation eliminates the need for parentheses and precedence rules, making evaluation straightforward.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q55kk",
              "type": "mcq",
              "question": "How many stacks are needed to convert infix to prefix notation?",
              "options": ["One", "Two", "Three", "Depends on expression"],
              "correctAnswer": "Two",
              "explanation": "Converting infix to prefix typically requires two stacks: one for operators and one for operands.",
              "difficulty": "hard",
              "topic": "stack"
            }
          ]
        },
        {
          "id": "advanced-stack-problems",
          "title": "Advanced Problems",
          "description": "Complex competitive programming problems using stacks",
          "xpReward": 90,
          "questions": [
            {
              "id": "q55ll",
              "type": "mcq",
              "question": "In the trapping rainwater problem, what does the stack store?",
              "options": ["Water heights", "Indices of bars", "Areas computed", "Heights of bars"],
              "correctAnswer": "Indices of bars",
              "explanation": "The stack stores indices of bars to efficiently compute trapped water between bars.",
              "difficulty": "hard",
              "topic": "stack"
            },
            {
              "id": "q55mm",
              "type": "fillInBlank",
              "question": "The celebrity problem can be solved using a stack in O(_____) time complexity.",
              "acceptedAnswers": ["n", "N", "N", "n-celebrities", "N-Celebrities", "N-CELEBRITIES", "n-celebrity", "N-Celebrity", "N-CELEBRITY"],
              "explanation": "The celebrity problem can be solved in O(n) time using a stack to eliminate non-celebrities.",
              "difficulty": "hard",
              "topic": "stack"
            },
            {
              "id": "q55nn",
              "type": "mcq",
              "question": "What is the key insight for solving the valid parentheses with wildcards problem?",
              "options": ["Use recursion", "Track minimum and maximum open brackets", "Sort the string", "Use dynamic programming"],
              "correctAnswer": "Track minimum and maximum open brackets",
              "explanation": "Track the range of possible open brackets considering wildcards can be '(', ')', or any character.",
              "difficulty": "hard",
              "topic": "stack"
            },
            {
              "id": "q55oo",
              "type": "mcq",
              "question": "In the stock span problem, what optimization does a stack provide?",
              "options": ["Faster sorting", "Avoid recalculating previous spans", "Reduce memory usage", "Improve cache performance"],
              "correctAnswer": "Avoid recalculating previous spans",
              "explanation": "Stack maintains decreasing prices and their spans, avoiding redundant calculations for previous days.",
              "difficulty": "hard",
              "topic": "stack"
            }
          ]
        },
        {
          "id": "stack-implementation",
          "title": "Implementation",
          "description": "Different ways to implement stacks and their trade-offs",
          "xpReward": 70,
          "questions": [
            {
              "id": "q55i",
              "type": "mcq",
              "question": "What is the most common way to implement a stack?",
              "options": ["Using arrays", "Using linked lists", "Using hash tables", "Using trees"],
              "correctAnswer": "Using arrays",
              "explanation": "Arrays are the most common implementation due to their simplicity and O(1) access to the top element.",
              "difficulty": "easy",
              "topic": "stack"
            },
            {
              "id": "q55j",
              "type": "mcq",
              "question": "What is an advantage of implementing a stack using a linked list?",
              "options": ["Faster access", "Dynamic size", "Less memory usage", "Better cache performance"],
              "correctAnswer": "Dynamic size",
              "explanation": "Linked list implementation allows the stack to grow and shrink dynamically without size limitations.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q55k",
              "type": "fillInBlank",
              "question": "In array-based stack implementation, the _____ variable keeps track of the top element's index.",
              "acceptedAnswers": ["top", "Top", "TOP", "stack-top", "Stack-Top", "STACK-TOP", "stack-top-index", "Stack-Top-Index", "STACK-TOP-INDEX"],
              "explanation": "A 'top' pointer/index variable maintains the position of the current top element in the array.",
              "difficulty": "easy",
              "topic": "stack"
            },
            {
              "id": "q55l",
              "type": "mcq",
              "question": "What happens to the space complexity when implementing a stack with a linked list vs array?",
              "options": ["Linked list uses less space", "Array uses less space", "Both use same space", "Depends on implementation"],
              "correctAnswer": "Array uses less space",
              "explanation": "Arrays have less overhead per element, while linked lists need extra memory for storing pointers.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q55m",
              "type": "mcq",
              "question": "In a linked list implementation of stack, where should new elements be added?",
              "options": ["At the end", "At the beginning", "In the middle", "Anywhere"],
              "correctAnswer": "At the beginning",
              "explanation": "Adding at the beginning (head) of linked list gives O(1) push and pop operations for stack behavior.",
              "difficulty": "medium",
              "topic": "stack"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-4",
      "title": "Queues",
      "description": "FIFO data structure for efficient operations",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "queue-basics",
          "title": "Basics",
          "description": "Understanding FIFO principle and queue operations",
          "xpReward": 60,
          "questions": [
            {
              "id": "q53",
              "type": "mcq",
              "question": "What does FIFO stand for in the context of queues?",
              "options": ["First In First Out", "Fast In Fast Out", "Final In First Out", "First In Final Out"],
              "correctAnswer": "First In First Out",
              "explanation": "FIFO means the first element added to the queue is the first one to be removed.",
              "difficulty": "easy",
              "topic": "queue"
            },
            {
              "id": "q54",
              "type": "mcq",
              "question": "What is the key difference between enqueue and dequeue operations in terms of queue positions?",
              "options": ["Enqueue adds to front, dequeue removes from front", "Enqueue adds to rear, dequeue removes from front", "Both operations work on the same end", "Enqueue adds to middle, dequeue removes from ends"],
              "correctAnswer": "Enqueue adds to rear, dequeue removes from front",
              "explanation": "Enqueue adds elements to the rear (back) of the queue, while dequeue removes elements from the front, maintaining FIFO order.",
              "difficulty": "medium",
              "topic": "queue"
            },
            {
              "id": "q54a",
              "type": "mcq",
              "question": "In a circular queue implementation, what advantage does it provide over a linear queue?",
              "options": ["Faster access to elements", "Eliminates wasted space from dequeued elements", "Supports unlimited size", "Automatic sorting of elements"],
              "correctAnswer": "Eliminates wasted space from dequeued elements",
              "explanation": "Circular queues reuse space freed by dequeued elements, preventing the 'false full' condition that occurs in linear queues.",
              "difficulty": "hard",
              "topic": "queue"
            }
          ]
        },
        {
          "id": "queue-applications",
          "title": "Queue Applications",
          "description": "Real-world uses of queues",
          "xpReward": 55,
          "questions": [
            {
              "id": "q54b",
              "type": "mcq",
              "question": "Which scenario best demonstrates queue usage?",
              "options": ["Function call management", "Print job scheduling", "Undo operations", "Expression evaluation"],
              "correctAnswer": "Print job scheduling",
              "explanation": "Print queues process jobs in FIFO order - first submitted, first printed.",
              "difficulty": "medium",
              "topic": "queue"
            },
            {
              "id": "q54c",
              "type": "mcq",
              "question": "What type of queue is used in breadth-first search?",
              "options": ["Priority queue", "Simple queue", "Circular queue", "Double-ended queue"],
              "correctAnswer": "Simple queue",
              "explanation": "BFS uses a simple FIFO queue to visit nodes level by level.",
              "difficulty": "medium",
              "topic": "queue"
            }
          ]
        },
        {
          "id": "queue-implementation",
          "title": "Queue Implementation",
          "description": "Different ways to implement queues and their trade-offs",
          "xpReward": 65,
          "questions": [
            {
              "id": "q54d",
              "type": "mcq",
              "question": "What is the main advantage of implementing a queue using a circular array?",
              "options": ["Faster enqueue operation", "Better memory utilization", "Simpler implementation", "Constant dequeue time"],
              "correctAnswer": "Better memory utilization",
              "explanation": "Circular arrays reuse freed space, avoiding the shifting overhead of linear arrays and memory waste.",
              "difficulty": "medium",
              "topic": "queue"
            },
            {
              "id": "q54e",
              "type": "fillInBlank",
              "question": "In a circular queue implementation, when rear reaches the end of array, it wraps around to _____ if there's space.",
              "acceptedAnswers": ["0", "0", "ZERO", "rear-index-wraps-around", "Rear-Index-Wraps-Around", "REAR-INDEX-WRAPS-AROUND", "rear-index-wraps-to-zero", "Rear-Index-Wraps-To-Zero", "REAR-INDEX-WRAPS-TO-ZERO"],
              "explanation": "Circular queues wrap the rear pointer to index 0 when it reaches the array end, creating a circular behavior.",
              "difficulty": "easy",
              "topic": "queue"
            },
            {
              "id": "q54f",
              "type": "mcq",
              "question": "What is the time complexity of enqueue and dequeue operations in a linked list implementation?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
              "correctAnswer": "O(1)",
              "explanation": "Both operations only involve updating pointers at the ends of the linked list, taking constant time.",
              "difficulty": "medium",
              "topic": "queue"
            },
            {
              "id": "q54g",
              "type": "mcq",
              "question": "What happens when you try to enqueue into a full array-based queue?",
              "options": ["Element is discarded", "Queue overflow error", "Oldest element is removed", "Array is automatically resized"],
              "correctAnswer": "Queue overflow error",
              "explanation": "Attempting to add to a full fixed-size queue results in an overflow error condition.",
              "difficulty": "medium",
              "topic": "queue"
            }
          ]
        },
        {
          "id": "priority-queues",
          "title": "Priority Queues",
          "description": "Queues where elements are served based on priority",
          "xpReward": 70,
          "questions": [
            {
              "id": "q54h",
              "type": "mcq",
              "question": "In a priority queue, which element is removed first?",
              "options": ["First inserted", "Last inserted", "Smallest priority", "Highest priority"],
              "correctAnswer": "Highest priority",
              "explanation": "Priority queues serve elements based on priority level, with highest priority elements served first.",
              "difficulty": "easy",
              "topic": "queue"
            },
            {
              "id": "q54i",
              "type": "fillInBlank",
              "question": "Priority queues are commonly implemented using a _____ data structure.",
              "acceptedAnswers": ["heap", "Heap", "HEAP", "priority-queue", "Priority-Queue", "PRIORITY-QUEUE", "priority-queue-heap", "Priority-Queue-Heap", "PRIORITY-QUEUE-HEAP"],
              "explanation": "Binary heaps provide efficient O(log n) insertion and O(log n) extraction for priority queues.",
              "difficulty": "medium",
              "topic": "queue"
            },
            {
              "id": "q54j",
              "type": "mcq",
              "question": "What is the time complexity of inserting into a priority queue implemented with a binary heap?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
              "correctAnswer": "O(log n)",
              "explanation": "Insertion requires bubbling up the element to maintain heap property, taking O(log n) time.",
              "difficulty": "medium",
              "topic": "queue"
            },
            {
              "id": "q54k",
              "type": "mcq",
              "question": "Which algorithm commonly uses a priority queue for efficient implementation?",
              "options": ["Binary search", "Bubble sort", "Dijkstra's shortest path", "Linear search"],
              "correctAnswer": "Dijkstra's shortest path",
              "explanation": "Dijkstra's algorithm uses a priority queue to efficiently select the next vertex with minimum distance.",
              "difficulty": "medium",
              "topic": "queue"
            }
          ]
        },
        {
          "id": "deque-operations",
          "title": "Double-Ended Queues (Deque)",
          "description": "Queues supporting insertion and deletion at both ends",
          "xpReward": 75,
          "questions": [
            {
              "id": "q54l",
              "type": "mcq",
              "question": "What operations can be performed on both ends of a deque?",
              "options": ["Only insertion", "Only deletion", "Both insertion and deletion", "Only reading"],
              "correctAnswer": "Both insertion and deletion",
              "explanation": "Deques (double-ended queues) allow insertion and deletion at both front and rear ends.",
              "difficulty": "easy",
              "topic": "queue"
            },
            {
              "id": "q54m",
              "type": "fillInBlank",
              "question": "A deque can be used to implement both _____ and _____ data structures efficiently.",
              "acceptedAnswers": ["stack, queue", "Stack, Queue", "STACK, QUEUE", "stack-queue", "Stack-Queue", "STACK-QUEUE", "stack-and-queue", "Stack-And-Queue", "STACK-AND-QUEUE"],
              "explanation": "Deques can simulate stacks (using one end) and queues (using both ends) efficiently.",
              "difficulty": "medium",
              "topic": "queue"
            },
            {
              "id": "q54n",
              "type": "mcq",
              "question": "What is the advantage of using a deque for implementing a sliding window maximum problem?",
              "options": ["Constant space usage", "Can remove elements from both ends", "Automatic sorting", "Faster than arrays"],
              "correctAnswer": "Can remove elements from both ends",
              "explanation": "Deques allow efficient removal of elements that fall outside the sliding window from either end.",
              "difficulty": "hard",
              "topic": "queue"
            },
            {
              "id": "q54o",
              "type": "mcq",
              "question": "What is the time complexity of front and rear access operations in a deque?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
              "correctAnswer": "O(1)",
              "explanation": "Well-implemented deques provide constant time access to elements at both ends.",
              "difficulty": "medium",
              "topic": "queue"
            }
          ]
        },
        {
          "id": "advanced-queue-problems",
          "title": "Advanced Queue Problems",
          "description": "Complex problems and optimization techniques using queues",
          "xpReward": 80,
          "questions": [
            {
              "id": "q54p",
              "type": "mcq",
              "question": "In the task scheduling problem, what does a queue help optimize?",
              "options": ["Memory usage", "CPU utilization", "Waiting time and throughput", "Code complexity"],
              "correctAnswer": "Waiting time and throughput",
              "explanation": "Queues in scheduling help manage task order to optimize waiting times and system throughput.",
              "difficulty": "medium",
              "topic": "queue"
            },
            {
              "id": "q54q",
              "type": "fillInBlank",
              "question": "The _____ queue pattern allows multiple consumers to process tasks concurrently.",
              "acceptedAnswers": ["producer-consumer", "Producer-Consumer", "PRODUCER-CONSUMER", "producer-consumer-pattern", "Producer-Consumer-Pattern", "PRODUCER-CONSUMER-PATTERN", "producer-consumer-queue", "Producer-Consumer-Queue", "PRODUCER-CONSUMER-QUEUE"],
              "explanation": "Producer-consumer pattern uses queues to decouple task production from consumption, enabling concurrency.",
              "difficulty": "medium",
              "topic": "queue"
            },
            {
              "id": "q54r",
              "type": "mcq",
              "question": "What is the optimal approach for implementing a queue with O(1) amortized operations using two stacks?",
              "options": ["Always use both stacks", "Transfer all elements on each operation", "Transfer elements only when needed", "Use stacks alternately"],
              "correctAnswer": "Transfer elements only when needed",
              "explanation": "Transfer elements from input stack to output stack only when output stack is empty, achieving amortized O(1).",
              "difficulty": "hard",
              "topic": "queue"
            },
            {
              "id": "q54s",
              "type": "mcq",
              "question": "In a circular buffer implementation, how do you detect if the queue is full vs empty when front equals rear?",
              "options": ["Impossible to detect", "Use a counter variable", "Check next element", "Use different pointers"],
              "correctAnswer": "Use a counter variable",
              "explanation": "A counter tracking the number of elements helps distinguish between full and empty states when pointers are equal.",
              "difficulty": "hard",
              "topic": "queue"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-5",
      "title": "Trees",
      "description": "Hierarchical data structures and tree algorithms",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "binary-trees",
          "title": "Basics",
          "description": "Understanding tree structure and terminology",
          "xpReward": 70,
          "questions": [
            {
              "id": "q56",
              "type": "mcq",
              "question": "What distinguishes a binary tree from other tree structures?",
              "options": ["Each node must have exactly two children", "Each node has at most two children", "Each node has at least two children", "Each node has two parent nodes"],
              "correctAnswer": "Each node has at most two children",
              "explanation": "Binary trees are characterized by the constraint that each node can have at most two children, typically called left and right child.",
              "difficulty": "medium",
              "topic": "trees"
            },
            {
              "id": "q57",
              "type": "mcq",
              "question": "What is the root of a tree?",
              "options": ["The last node", "The node with no parent", "The deepest node", "Any leaf node"],
              "correctAnswer": "The node with no parent",
              "explanation": "The root is the topmost node in a tree that has no parent node.",
              "difficulty": "easy",
              "topic": "trees"
            },
            {
              "id": "q57a",
              "type": "mcq",
              "question": "What is the relationship between leaf nodes and internal nodes in a tree?",
              "options": ["Leaf nodes are parents of internal nodes", "Internal nodes have children, leaf nodes don't", "Leaf nodes are always deeper than internal nodes", "Internal nodes store data, leaf nodes don't"],
              "correctAnswer": "Internal nodes have children, leaf nodes don't",
              "explanation": "Internal nodes have at least one child, while leaf nodes have no children, making them terminal nodes in the tree structure.",
              "difficulty": "medium",
              "topic": "trees"
            }
          ]
        },
        {
          "id": "tree-traversal",
          "title": "Tree Traversal",
          "description": "Methods for visiting all nodes in a tree",
          "xpReward": 75,
          "questions": [
            {
              "id": "q58",
              "type": "mcq",
              "question": "In which traversal do you visit the root before its children?",
              "options": ["Inorder", "Preorder", "Postorder", "Level order"],
              "correctAnswer": "Preorder",
              "explanation": "Preorder traversal visits root first, then left subtree, then right subtree.",
              "difficulty": "medium",
              "topic": "trees"
            },
            {
              "id": "q58a",
              "type": "mcq",
              "question": "Which traversal visits nodes level by level from top to bottom?",
              "options": ["Inorder", "Preorder", "Postorder", "Level order"],
              "correctAnswer": "Level order",
              "explanation": "Level order traversal uses a queue to visit all nodes at each level before moving to the next level.",
              "difficulty": "medium",
              "topic": "trees"
            },
            {
              "id": "q58b",
              "type": "fillInBlank",
              "question": "Inorder traversal of a binary search tree visits nodes in _____ order.",
              "acceptedAnswers": ["sorted", "Sorted", "SORTED", "ascending", "Ascending", "ASCENDING", "in-order", "In-Order", "IN-ORDER"],
              "explanation": "Inorder traversal of a BST visits nodes in ascending sorted order.",
              "difficulty": "medium",
              "topic": "trees"
            }
          ]
        },
        {
          "id": "binary-search-trees",
          "title": "Binary Search Trees",
          "description": "Efficient searching and insertion in trees",
          "xpReward": 80,
          "questions": [
            {
              "id": "q58c",
              "type": "mcq",
              "question": "What is the key property of a binary search tree?",
              "options": ["All nodes have two children", "Left child < parent < right child", "Tree is always balanced", "Maximum height is log n"],
              "correctAnswer": "Left child < parent < right child",
              "explanation": "In a BST, all values in the left subtree are less than the parent, and all values in the right subtree are greater.",
              "difficulty": "medium",
              "topic": "trees"
            },
            {
              "id": "q58d",
              "type": "mcq",
              "question": "What is the average time complexity for search in a balanced BST?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
              "correctAnswer": "O(log n)",
              "explanation": "Balanced BSTs allow elimination of half the search space at each step, resulting in O(log n) search time.",
              "difficulty": "medium",
              "topic": "trees"
            }
          ]
        },
        {
          "id": "balanced-trees",
          "title": "Balanced Trees",
          "description": "Self-balancing binary search trees and their properties",
          "xpReward": 85,
          "questions": [
            {
              "id": "q58e",
              "type": "mcq",
              "question": "What is the balance factor in an AVL tree?",
              "options": ["Height of left subtree", "Height of right subtree", "Difference between left and right subtree heights", "Total number of nodes"],
              "correctAnswer": "Difference between left and right subtree heights",
              "explanation": "AVL balance factor is the height difference between left and right subtrees, must be -1, 0, or 1.",
              "difficulty": "medium",
              "topic": "trees"
            },
            {
              "id": "q58f",
              "type": "fillInBlank",
              "question": "In a Red-Black tree, every path from root to leaf contains the same number of _____ nodes.",
              "acceptedAnswers": ["black", "Black", "BLACK", "red", "Red", "RED", "black-nodes", "Black-Nodes", "BLACK-NODES"],
              "explanation": "Red-Black trees maintain the property that all root-to-leaf paths have equal numbers of black nodes.",
              "difficulty": "hard",
              "topic": "trees"
            },
            {
              "id": "q58g",
              "type": "mcq",
              "question": "What rotation is needed when a left-heavy AVL tree becomes more left-heavy?",
              "options": ["Left rotation", "Right rotation", "Left-Right rotation", "Right-Left rotation"],
              "correctAnswer": "Right rotation",
              "explanation": "A right rotation fixes the left-left case in AVL trees by rotating the problematic node to the right.",
              "difficulty": "hard",
              "topic": "trees"
            },
            {
              "id": "q58h",
              "type": "mcq",
              "question": "What is the worst-case time complexity for operations in a balanced BST?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
              "correctAnswer": "O(log n)",
              "explanation": "Balanced trees guarantee O(log n) height, ensuring all operations complete in logarithmic time.",
              "difficulty": "medium",
              "topic": "trees"
            }
          ]
        },
        {
          "id": "tree-algorithms",
          "title": "Tree Algorithms",
          "description": "Advanced algorithms for tree manipulation and analysis",
          "xpReward": 90,
          "questions": [
            {
              "id": "q58i",
              "type": "mcq",
              "question": "What algorithm is used to find the Lowest Common Ancestor (LCA) efficiently?",
              "options": ["DFS", "BFS", "Binary lifting", "Linear search"],
              "correctAnswer": "Binary lifting",
              "explanation": "Binary lifting preprocesses the tree to answer LCA queries in O(log n) time after O(n log n) preprocessing.",
              "difficulty": "hard",
              "topic": "trees"
            },
            {
              "id": "q58j",
              "type": "fillInBlank",
              "question": "Morris traversal achieves tree traversal in O(1) space by temporarily modifying _____ pointers.",
              "acceptedAnswers": ["predecessor", "Predecessor", "PREDECESSOR", "threading", "Threading", "THREADING", "predecessor-pointer", "Predecessor-Pointer", "PREDECESSOR-POINTER"],
              "explanation": "Morris traversal uses threading by temporarily modifying predecessor pointers to enable constant space traversal.",
              "difficulty": "hard",
              "topic": "trees"
            },
            {
              "id": "q58k",
              "type": "mcq",
              "question": "What is the time complexity of converting a sorted array to a balanced BST?",
              "options": ["O(n)", "O(n log n)", "O(n²)", "O(log n)"],
              "correctAnswer": "O(n)",
              "explanation": "Each element is visited exactly once during the recursive construction, resulting in O(n) time.",
              "difficulty": "medium",
              "topic": "trees"
            },
            {
              "id": "q58l",
              "type": "mcq",
              "question": "In a tree serialization problem, what traversal uniquely identifies a binary tree structure?",
              "options": ["Preorder only", "Inorder only", "Preorder with null markers", "Level order only"],
              "correctAnswer": "Preorder with null markers",
              "explanation": "Preorder traversal with null markers for missing children can uniquely reconstruct the tree structure.",
              "difficulty": "hard",
              "topic": "trees"
            }
          ]
        },
        {
          "id": "advanced-tree-structures",
          "title": "Advanced Tree Structures",
          "description": "Specialized trees for specific applications",
          "xpReward": 95,
          "questions": [
            {
              "id": "q58m",
              "type": "mcq",
              "question": "What is the main advantage of a Trie (Prefix Tree) over hash maps for string operations?",
              "options": ["Faster insertion", "Prefix-based searches", "Less memory usage", "Better hash function"],
              "correctAnswer": "Prefix-based searches",
              "explanation": "Tries excel at prefix-based operations like autocomplete and finding all words with a given prefix.",
              "difficulty": "medium",
              "topic": "trees"
            },
            {
              "id": "q58n",
              "type": "fillInBlank",
              "question": "A Segment Tree allows range queries and updates in O(_____ ) time.",
              "acceptedAnswers": ["log n", "Log n", "LOG N", "log-n", "Log-n", "LOG-N", "log-n-time", "Log-n-Time", "LOG-N-TIME"],
              "explanation": "Segment trees support both range queries and range updates in O(log n) time complexity.",
              "difficulty": "hard",
              "topic": "trees"
            },
            {
              "id": "q58o",
              "type": "mcq",
              "question": "What type of tree is most efficient for range minimum/maximum queries?",
              "options": ["Binary search tree", "AVL tree", "Segment tree", "B-tree"],
              "correctAnswer": "Segment tree",
              "explanation": "Segment trees are specifically designed for efficient range queries like finding minimum or maximum in a range.",
              "difficulty": "hard",
              "topic": "trees"
            },
            {
              "id": "q58p",
              "type": "mcq",
              "question": "What is the space complexity of a typical Trie storing n strings of average length m?",
              "options": ["O(n)", "O(m)", "O(n*m)", "O(alphabet_size * n * m)"],
              "correctAnswer": "O(alphabet_size * n * m)",
              "explanation": "Trie space depends on alphabet size, number of strings, and their lengths, in worst case O(alphabet_size * n * m).",
              "difficulty": "hard",
              "topic": "trees"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-6",
      "title": "Graphs",
      "description": "Network data structures and graph algorithms",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "graph-basics",
          "title": "Basics",
          "description": "Understanding vertices, edges, and graph types",
          "xpReward": 80,
          "questions": [
            {
              "id": "q59",
              "type": "mcq",
              "question": "What is the fundamental difference between vertices and edges in graph theory?",
              "options": ["Vertices store data, edges store relationships", "Vertices represent entities, edges represent connections", "Vertices are numbered, edges are named", "Vertices are internal, edges are external"],
              "correctAnswer": "Vertices represent entities, edges represent connections",
              "explanation": "In graph theory, vertices (nodes) represent entities or objects, while edges represent the relationships or connections between these entities.",
              "difficulty": "medium",
              "topic": "graphs"
            },
            {
              "id": "q59a",
              "type": "mcq",
              "question": "What is the difference between directed and undirected graphs?",
              "options": ["Directed graphs are faster", "Directed edges have direction, undirected don't", "Undirected graphs use more memory", "No difference"],
              "correctAnswer": "Directed edges have direction, undirected don't",
              "explanation": "Directed graphs have edges with direction (A→B), while undirected graphs have bidirectional connections (A—B).",
              "difficulty": "medium",
              "topic": "graphs"
            },
            {
              "id": "q59b",
              "type": "mcq",
              "question": "What does the degree of a vertex represent in graph theory?",
              "options": ["The depth of the vertex in the graph", "The number of edges connected to the vertex", "The importance of the vertex", "The distance from the root vertex"],
              "correctAnswer": "The number of edges connected to the vertex",
              "explanation": "The degree of a vertex is the count of edges that are incident to (connected to) that vertex.",
              "difficulty": "medium",
              "topic": "graphs"
            }
          ]
        },
        {
          "id": "graph-traversal",
          "title": "Graph Traversal",
          "description": "DFS and BFS algorithms for exploring graphs",
          "xpReward": 85,
          "questions": [
            {
              "id": "q59c",
              "type": "mcq",
              "question": "Which data structure is typically used for DFS (Depth-First Search)?",
              "options": ["Queue", "Stack", "Heap", "Hash Map"],
              "correctAnswer": "Stack",
              "explanation": "DFS uses a stack (or recursion which uses the call stack) to explore as deep as possible before backtracking.",
              "difficulty": "medium",
              "topic": "graphs"
            },
            {
              "id": "q59d",
              "type": "mcq",
              "question": "Which data structure is typically used for BFS (Breadth-First Search)?",
              "options": ["Queue", "Stack", "Heap", "Hash Map"],
              "correctAnswer": "Queue",
              "explanation": "BFS uses a queue to explore all neighbors at the current depth before moving to the next depth level.",
              "difficulty": "medium",
              "topic": "graphs"
            },
            {
              "id": "q59e",
              "type": "fillInBlank",
              "question": "BFS finds the _____ path between two vertices in an unweighted graph.",
              "acceptedAnswers": ["shortest", "Shortest", "SHORTEST", "shortest-path", "Shortest-Path", "SHORTEST-PATH", "shortest-path-between-two-vertices", "Shortest-Path-Between-Two-Vertices", "SHORTEST-PATH-BETWEEN-TWO-VERTICES"],
              "explanation": "BFS naturally finds the shortest path in unweighted graphs by exploring vertices level by level.",
              "difficulty": "medium",
              "topic": "graphs"
            }
          ]
        },
        {
          "id": "shortest-path",
          "title": "Shortest Path Algorithms",
          "description": "Finding optimal paths in weighted graphs",
          "xpReward": 90,
          "questions": [
            {
              "id": "q59f",
              "type": "mcq",
              "question": "Which algorithm is used for single-source shortest path in graphs with non-negative weights?",
              "options": ["Bellman-Ford", "Dijkstra's", "Floyd-Warshall", "DFS"],
              "correctAnswer": "Dijkstra's",
              "explanation": "Dijkstra's algorithm efficiently finds shortest paths from a single source when all edge weights are non-negative.",
              "difficulty": "medium",
              "topic": "graphs"
            },
            {
              "id": "q59g",
              "type": "fillInBlank",
              "question": "The Bellman-Ford algorithm can detect _____ weight cycles in a graph.",
              "acceptedAnswers": ["negative", "Negative", "NEGATIVE", "negative-weight-cycles", "Negative-Weight-Cycles", "NEGATIVE-WEIGHT-CYCLES", "negative-weight-cycle", "Negative-Weight-Cycle", "NEGATIVE-WEIGHT-CYCLE"],
              "explanation": "Bellman-Ford algorithm can detect negative weight cycles while finding shortest paths.",
              "difficulty": "medium",
              "topic": "graphs"
            },
            {
              "id": "q59h",
              "type": "mcq",
              "question": "What is the time complexity of Dijkstra's algorithm using a binary heap?",
              "options": ["O(V²)", "O(E log V)", "O(VE)", "O(V + E)"],
              "correctAnswer": "O(E log V)",
              "explanation": "With a binary heap, Dijkstra's algorithm runs in O(E log V) time where E is edges and V is vertices.",
              "difficulty": "hard",
              "topic": "graphs"
            },
            {
              "id": "q59i",
              "type": "mcq",
              "question": "Which algorithm finds shortest paths between all pairs of vertices?",
              "options": ["Dijkstra's", "Bellman-Ford", "Floyd-Warshall", "BFS"],
              "correctAnswer": "Floyd-Warshall",
              "explanation": "Floyd-Warshall algorithm computes shortest paths between all pairs of vertices in O(V³) time.",
              "difficulty": "medium",
              "topic": "graphs"
            }
          ]
        },
        {
          "id": "minimum-spanning-tree",
          "title": "Minimum Spanning Trees",
          "description": "Finding minimum cost trees that connect all vertices",
          "xpReward": 85,
          "questions": [
            {
              "id": "q59j",
              "type": "mcq",
              "question": "What is the main difference between Kruskal's and Prim's algorithms?",
              "options": ["Time complexity", "Kruskal is edge-based, Prim is vertex-based", "Kruskal works on directed graphs", "Prim requires sorted edges"],
              "correctAnswer": "Kruskal is edge-based, Prim is vertex-based",
              "explanation": "Kruskal's algorithm processes edges in sorted order, while Prim's grows the MST vertex by vertex.",
              "difficulty": "medium",
              "topic": "graphs"
            },
            {
              "id": "q59k",
              "type": "fillInBlank",
              "question": "Kruskal's algorithm uses a _____ data structure to detect cycles efficiently.",
              "acceptedAnswers": ["union-find", "Union-Find", "UNION-FIND", "disjoint-set", "Disjoint-Set", "DISJOINT-SET", "union-find-data-structure", "Union-Find-Data-Structure", "UNION-FIND-DATA-STRUCTURE"],
              "explanation": "Union-find (disjoint set) data structure efficiently detects cycles when adding edges in Kruskal's algorithm.",
              "difficulty": "medium",
              "topic": "graphs"
            },
            {
              "id": "q59l",
              "type": "mcq",
              "question": "What is the time complexity of Kruskal's algorithm?",
              "options": ["O(V log V)", "O(E log E)", "O(VE)", "O(V + E)"],
              "correctAnswer": "O(E log E)",
              "explanation": "Kruskal's algorithm complexity is dominated by sorting edges, which takes O(E log E) time.",
              "difficulty": "medium",
              "topic": "graphs"
            },
            {
              "id": "q59m",
              "type": "mcq",
              "question": "A minimum spanning tree of a graph with V vertices has how many edges?",
              "options": ["V", "V-1", "V+1", "2V"],
              "correctAnswer": "V-1",
              "explanation": "Any spanning tree of a connected graph with V vertices must have exactly V-1 edges.",
              "difficulty": "easy",
              "topic": "graphs"
            }
          ]
        },
        {
          "id": "topological-sorting",
          "title": "Topological Sorting",
          "description": "Ordering vertices in directed acyclic graphs",
          "xpReward": 80,
          "questions": [
            {
              "id": "q59n",
              "type": "mcq",
              "question": "Topological sorting is only possible in which type of graphs?",
              "options": ["Undirected graphs", "Directed acyclic graphs (DAG)", "Complete graphs", "Bipartite graphs"],
              "correctAnswer": "Directed acyclic graphs (DAG)",
              "explanation": "Topological sorting is only possible in directed acyclic graphs where no cycles exist.",
              "difficulty": "medium",
              "topic": "graphs"
            },
            {
              "id": "q59o",
              "type": "fillInBlank",
              "question": "In Kahn's algorithm for topological sorting, vertices with _____ in-degree are processed first.",
              "acceptedAnswers": ["zero", "Zero", "ZERO", "in-degree-zero", "In-Degree-Zero", "IN-DEGREE-ZERO", "vertices-with-zero-in-degree", "Vertices-With-Zero-In-Degree", "VERTICES-WITH-ZERO-IN-DEGREE"],
              "explanation": "Kahn's algorithm repeatedly removes vertices with zero in-degree to generate topological order.",
              "difficulty": "medium",
              "topic": "graphs"
            },
            {
              "id": "q59p",
              "type": "mcq",
              "question": "What is a common application of topological sorting?",
              "options": ["Finding shortest paths", "Course scheduling with prerequisites", "Finding cycles", "Graph coloring"],
              "correctAnswer": "Course scheduling with prerequisites",
              "explanation": "Topological sorting is commonly used for scheduling tasks with dependencies, like course prerequisites.",
              "difficulty": "easy",
              "topic": "graphs"
            },
            {
              "id": "q59q",
              "type": "mcq",
              "question": "What happens when Kahn's algorithm cannot find a vertex with zero in-degree?",
              "options": ["Algorithm completes", "Graph has a cycle", "Algorithm restarts", "Need more memory"],
              "correctAnswer": "Graph has a cycle",
              "explanation": "If no vertex with zero in-degree exists during processing, the graph contains a cycle.",
              "difficulty": "medium",
              "topic": "graphs"
            }
          ]
        },
        {
          "id": "advanced-graph-algorithms",
          "title": "Advanced Graph Algorithms",
          "description": "Complex graph problems and specialized algorithms",
          "xpReward": 95,
          "questions": [
            {
              "id": "q59r",
              "type": "mcq",
              "question": "What is the purpose of strongly connected components (SCCs) in directed graphs?",
              "options": ["Find shortest paths", "Identify mutually reachable vertices", "Detect bipartite graphs", "Find minimum cuts"],
              "correctAnswer": "Identify mutually reachable vertices",
              "explanation": "SCCs group vertices that can reach each other through directed paths in both directions.",
              "difficulty": "hard",
              "topic": "graphs"
            },
            {
              "id": "q59s",
              "type": "fillInBlank",
              "question": "Tarjan's algorithm finds strongly connected components using _____ traversal.",
              "acceptedAnswers": ["DFS", "Dfs", "DFS", "Depth-First Search", "Depth-First-Search", "DEPTH-FIRST-SEARCH", "depth-first-search", "Depth-First-Search", "DEPTH-FIRST-SEARCH"],
              "explanation": "Tarjan's algorithm uses DFS traversal with low-link values to identify SCCs in a single pass.",
              "difficulty": "hard",
              "topic": "graphs"
            },
            {
              "id": "q59t",
              "type": "mcq",
              "question": "What is the maximum flow problem trying to optimize?",
              "options": ["Minimum path length", "Maximum number of paths", "Maximum flow from source to sink", "Minimum number of edges"],
              "correctAnswer": "Maximum flow from source to sink",
              "explanation": "Maximum flow problem finds the maximum amount of flow that can be sent from source to sink.",
              "difficulty": "medium",
              "topic": "graphs"
            },
            {
              "id": "q59u",
              "type": "mcq",
              "question": "Which algorithm solves the maximum bipartite matching problem efficiently?",
              "options": ["Dijkstra's", "Kruskal's", "Hungarian algorithm", "Bellman-Ford"],
              "correctAnswer": "Hungarian algorithm",
              "explanation": "The Hungarian algorithm efficiently solves maximum bipartite matching and assignment problems.",
              "difficulty": "hard",
              "topic": "graphs"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-7", 
      "title": "Sorting I",
      "description": "Simple O(n²) sorting algorithms",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "bubble-sort",
          "title": "Bubble Sort",
          "description": "Understanding the simplest sorting algorithm",
          "xpReward": 50,
          "questions": [
            {
              "id": "q60",
              "type": "mcq",
              "question": "What is the time complexity of bubble sort?",
              "options": ["O(n)", "O(n log n)", "O(n²)", "O(log n)"],
              "correctAnswer": "O(n²)",
              "explanation": "Bubble sort has O(n²) time complexity due to nested loops comparing adjacent elements.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q60a",
              "type": "mcq",
              "question": "What is the key optimization that can improve bubble sort's performance on nearly sorted arrays?",
              "options": ["Use binary search for comparisons", "Stop early if no swaps occur in a pass", "Sort smaller subarrays first", "Use a different comparison function"],
              "correctAnswer": "Stop early if no swaps occur in a pass",
              "explanation": "If no swaps occur during a complete pass through the array, it means the array is already sorted, allowing the algorithm to terminate early.",
              "difficulty": "medium",
              "topic": "sorting"
            }
          ]
        },
        {
          "id": "selection-sort",
          "title": "Selection Sort",
          "description": "Sorting by repeatedly finding the minimum element",
          "xpReward": 55,
          "questions": [
            {
              "id": "q60b",
              "type": "mcq",
              "question": "How does selection sort work?",
              "options": ["Swaps adjacent elements", "Finds minimum and places it at beginning", "Divides array in half", "Uses a pivot element"],
              "correctAnswer": "Finds minimum and places it at beginning",
              "explanation": "Selection sort repeatedly finds the minimum element from unsorted portion and places it at the beginning.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q60c",
              "type": "mcq",
              "question": "What is the time complexity of selection sort?",
              "options": ["O(n)", "O(n log n)", "O(n²)", "O(log n)"],
              "correctAnswer": "O(n²)",
              "explanation": "Selection sort has O(n²) time complexity as it performs nested loops to find minimum elements.",
              "difficulty": "medium",
              "topic": "sorting"
            }
          ]
        },
        {
          "id": "insertion-sort",
          "title": "Insertion Sort", 
          "description": "Building sorted array one element at a time",
          "xpReward": 60,
          "questions": [
            {
              "id": "q60d",
              "type": "mcq",
              "question": "How does insertion sort build the final sorted array?",
              "options": ["By finding minimum elements", "By inserting each element in its correct position", "By swapping adjacent elements", "By dividing the array"],
              "correctAnswer": "By inserting each element in its correct position",
              "explanation": "Insertion sort builds the sorted array by taking each element and inserting it in the correct position among previously sorted elements.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q60e",
              "type": "fillInBlank",
              "question": "Insertion sort is efficient for _____ datasets.",
              "acceptedAnswers": ["small", "Small", "SMALL", "small-datasets", "Small-Datasets", "SMALL-DATASETS", "small-data", "Small-Data", "SMALL-DATA"],
              "explanation": "Insertion sort performs well on small datasets due to its simple implementation and low overhead.",
              "difficulty": "easy",
              "topic": "sorting"
            }
          ]
        },
        {
          "id": "sorting-analysis",
          "title": "Sorting Analysis",
          "description": "Comparing simple sorting algorithms and their performance",
          "xpReward": 65,
          "questions": [
            {
              "id": "q60f",
              "type": "mcq",
              "question": "Which simple sorting algorithm has the best best-case time complexity?",
              "options": ["Bubble sort", "Selection sort", "Insertion sort", "All are the same"],
              "correctAnswer": "Insertion sort",
              "explanation": "Insertion sort has O(n) best-case complexity when the array is already sorted, while others remain O(n²).",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q60g",
              "type": "fillInBlank",
              "question": "Selection sort makes exactly _____ swaps for an array of n elements.",
              "acceptedAnswers": ["n-1", "N-1", "N-1", "n-1-swaps", "N-1-Swaps", "N-1-SWAPS", "n-1-swaps-for-an-array-of-n-elements", "N-1-Swaps-For-An-Array-Of-N-Elements", "N-1-SWAPS-FOR-AN-ARRAY-OF-N-ELEMENTS"],
              "explanation": "Selection sort performs exactly n-1 swaps, one for each position except the last.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q60h",
              "type": "mcq",
              "question": "Which sorting algorithm is stable among the simple O(n²) sorts?",
              "options": ["Selection sort", "Bubble sort", "Shell sort", "Heap sort"],
              "correctAnswer": "Bubble sort",
              "explanation": "Bubble sort is stable as it only swaps adjacent elements when they are in wrong order, preserving relative order of equal elements.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q60i",
              "type": "mcq",
              "question": "What is the space complexity of bubble sort?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
              "correctAnswer": "O(1)",
              "explanation": "Bubble sort is an in-place algorithm using only constant extra space for temporary variables.",
              "difficulty": "easy",
              "topic": "sorting"
            }
          ]
        },
        {
          "id": "adaptive-sorting",
          "title": "Adaptive Sorting",
          "description": "Algorithms that perform better on partially sorted data",
          "xpReward": 70,
          "questions": [
            {
              "id": "q60j",
              "type": "mcq",
              "question": "What makes a sorting algorithm adaptive?",
              "options": ["Uses less memory", "Performs better on nearly sorted data", "Works on any data type", "Has stable behavior"],
              "correctAnswer": "Performs better on nearly sorted data",
              "explanation": "Adaptive algorithms take advantage of existing order in the data to perform better than their worst-case complexity.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q60k",
              "type": "fillInBlank",
              "question": "Tim sort is an adaptive sorting algorithm used in Python's built-in _____ function.",
              "acceptedAnswers": ["sort", "Sort", "SORT", "timsort", "Timsort", "TIMSORT", "timsort-algorithm", "Timsort-Algorithm", "TIMSORT-ALGORITHM"],
              "explanation": "Tim sort is the algorithm behind Python's built-in sort() and sorted() functions.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q60l",
              "type": "mcq",
              "question": "Which simple sorting algorithm adapts best to partially sorted arrays?",
              "options": ["Bubble sort", "Selection sort", "Insertion sort", "Shell sort"],
              "correctAnswer": "Insertion sort",
              "explanation": "Insertion sort performs very well on partially sorted arrays, approaching O(n) time complexity.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q60m",
              "type": "mcq",
              "question": "What optimization can make bubble sort adaptive?",
              "options": ["Use recursion", "Stop early if no swaps occur", "Use binary search", "Sort in reverse"],
              "correctAnswer": "Stop early if no swaps occur",
              "explanation": "If no swaps occur in a complete pass, the array is sorted and the algorithm can terminate early.",
              "difficulty": "medium",
              "topic": "sorting"
            }
          ]
        },
        {
          "id": "counting-sort",
          "title": "Counting Sort",
          "description": "Non-comparison based sorting for specific data ranges",
          "xpReward": 75,
          "questions": [
            {
              "id": "q60n",
              "type": "mcq",
              "question": "What is the time complexity of counting sort?",
              "options": ["O(n log n)", "O(n + k)", "O(n²)", "O(k log n)"],
              "correctAnswer": "O(n + k)",
              "explanation": "Counting sort runs in O(n + k) time where n is the number of elements and k is the range of input.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q60o",
              "type": "fillInBlank",
              "question": "Counting sort works best when the range of possible values (k) is _____ compared to the number of elements (n).",
              "acceptedAnswers": ["small", "Small", "SMALL", "small-range", "Small-Range", "SMALL-RANGE", "small-k", "Small-K", "SMALL-K"],
              "explanation": "Counting sort is efficient when k (range) is not significantly larger than n (number of elements).",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q60p",
              "type": "mcq",
              "question": "What is the main limitation of counting sort?",
              "options": ["Unstable sorting", "High time complexity", "Requires knowing the range of values", "Uses recursion"],
              "correctAnswer": "Requires knowing the range of values",
              "explanation": "Counting sort needs to know the range of possible input values to create the counting array.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q60q",
              "type": "mcq",
              "question": "Is counting sort a stable sorting algorithm?",
              "options": ["Yes, always", "No, never", "Depends on implementation", "Only for positive numbers"],
              "correctAnswer": "Yes, always",
              "explanation": "Counting sort is stable when implemented correctly, preserving the relative order of equal elements.",
              "difficulty": "medium",
              "topic": "sorting"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-8",
      "title": "Sorting II",
      "description": "Efficient O(n log n) sorting algorithms",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "merge-sort",
          "title": "Merge Sort",
          "description": "Divide and conquer sorting approach",
          "xpReward": 70,
          "questions": [
            {
              "id": "q61",
              "type": "mcq",
              "question": "What is the time complexity of merge sort?",
              "options": ["O(n)", "O(n log n)", "O(n²)", "O(log n)"],
              "correctAnswer": "O(n log n)",
              "explanation": "Merge sort consistently runs in O(n log n) time using divide and conquer.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q61a",
              "type": "mcq",
              "question": "What is the key principle behind merge sort?",
              "options": ["Bubble elements up", "Divide and conquer", "Find pivot element", "Select minimum"],
              "correctAnswer": "Divide and conquer",
              "explanation": "Merge sort divides the array into smaller subarrays, sorts them, then merges them back together.",
              "difficulty": "medium",
              "topic": "sorting"
            }
          ]
        },
        {
          "id": "quick-sort",
          "title": "Quick Sort",
          "description": "Efficient in-place sorting algorithm",
          "xpReward": 75,
          "questions": [
            {
              "id": "q62",
              "type": "fillInBlank",
              "question": "Quick sort uses a _____ element to partition the array.",
              "acceptedAnswers": ["pivot", "Pivot", "PIVOT", "pivot-element", "Pivot-Element", "PIVOT-ELEMENT", "pivot-element-for-partitioning", "Pivot-Element-For-Partitioning", "PIVOT-ELEMENT-FOR-PARTITIONING"],
              "explanation": "Quick sort selects a pivot element and partitions the array around it.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q62a",
              "type": "mcq",
              "question": "What is the average time complexity of quick sort?",
              "options": ["O(n)", "O(n log n)", "O(n²)", "O(log n)"],
              "correctAnswer": "O(n log n)",
              "explanation": "Quick sort has average case O(n log n) time complexity with good pivot selection.",
              "difficulty": "medium",
              "topic": "sorting"
            }
          ]
        },
        {
          "id": "heap-sort",
          "title": "Heap Sort",
          "description": "Sorting using heap data structure",
          "xpReward": 80,
          "questions": [
            {
              "id": "q62b",
              "type": "mcq",
              "question": "What data structure does heap sort use?",
              "options": ["Stack", "Queue", "Binary heap", "Hash table"],
              "correctAnswer": "Binary heap",
              "explanation": "Heap sort uses a binary heap to efficiently find and remove the maximum/minimum element.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q62c",
              "type": "mcq",
              "question": "What is the time complexity of heap sort?",
              "options": ["O(n)", "O(n log n)", "O(n²)", "O(log n)"],
              "correctAnswer": "O(n log n)",
              "explanation": "Heap sort consistently runs in O(n log n) time for building heap and extracting elements.",
              "difficulty": "medium",
              "topic": "sorting"
            }
          ]
        },
        {
          "id": "divide-conquer-analysis",
          "title": "Divide & Conquer",
          "description": "Understanding the mathematics behind efficient sorting",
          "xpReward": 85,
          "questions": [
            {
              "id": "q62d",
              "type": "mcq",
              "question": "What is the recurrence relation for merge sort's time complexity?",
              "options": ["T(n) = T(n/2) + O(n)", "T(n) = 2T(n/2) + O(n)", "T(n) = 2T(n/2) + O(1)", "T(n) = T(n-1) + O(n)"],
              "correctAnswer": "T(n) = 2T(n/2) + O(n)",
              "explanation": "Merge sort divides into two halves (2T(n/2)) and merges them in linear time (O(n)).",
              "difficulty": "hard",
              "topic": "sorting"
            },
            {
              "id": "q62e",
              "type": "fillInBlank",
              "question": "The Master Theorem can be used to solve recurrence relations of the form T(n) = aT(n/b) + _____.",
              "acceptedAnswers": ["f(n)", "F(n)", "F(n)", "f(n)-work-done-at-each-level", "F(n)-Work-Done-At-Each-Level", "F(N)-WORK-DONE-AT-EACH-LEVEL", "f(n)-work-done-at-each-level-function", "F(n)-Work-Done-At-Each-Level-Function", "F(N)-WORK-DONE-AT-EACH-LEVEL-FUNCTION"],
              "explanation": "Master Theorem solves recurrences T(n) = aT(n/b) + f(n) where f(n) is the work done at each level.",
              "difficulty": "hard",
              "topic": "sorting"
            },
            {
              "id": "q62f",
              "type": "mcq",
              "question": "Why is quicksort's average case O(n log n) but worst case O(n²)?",
              "options": ["Bad implementation", "Poor pivot selection", "Memory limitations", "Compiler optimization"],
              "correctAnswer": "Poor pivot selection",
              "explanation": "If pivot is always the smallest/largest element, quicksort degrades to O(n²) due to unbalanced partitions.",
              "difficulty": "hard",
              "topic": "sorting"
            },
            {
              "id": "q62g",
              "type": "mcq",
              "question": "What makes merge sort consistently O(n log n) regardless of input?",
              "options": ["Always divides evenly", "Uses extra memory", "Better pivot selection", "In-place operation"],
              "correctAnswer": "Always divides evenly",
              "explanation": "Merge sort always divides the array into equal halves, ensuring balanced recursion tree.",
              "difficulty": "medium",
              "topic": "sorting"
            }
          ]
        },
        {
          "id": "hybrid-sorting",
          "title": "Hybrid Sorting",
          "description": "Combining multiple sorting techniques for optimal performance",
          "xpReward": 90,
          "questions": [
            {
              "id": "q62h",
              "type": "mcq",
              "question": "What strategy does Introsort (introspective sort) use?",
              "options": ["Always use quicksort", "Start with heapsort", "Switch from quicksort to heapsort if recursion gets too deep", "Randomly choose algorithm"],
              "correctAnswer": "Switch from quicksort to heapsort if recursion gets too deep",
              "explanation": "Introsort begins with quicksort but switches to heapsort when recursion depth exceeds 2*log(n) to avoid O(n²) behavior.",
              "difficulty": "hard",
              "topic": "sorting"
            },
            {
              "id": "q62i",
              "type": "fillInBlank",
              "question": "Timsort combines _____ sort and merge sort to achieve excellent performance on real-world data.",
              "acceptedAnswers": ["insertion", "Insertion", "INSERTION", "insertion-sort", "Insertion-Sort", "INSERTION-SORT", "insertion-sort-and-merge-sort", "Insertion-Sort-And-Merge-Sort", "INSERTION-SORT-AND-MERGE-SORT"],
              "explanation": "Timsort uses insertion sort for small runs and merge sort for combining runs efficiently.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q62j",
              "type": "mcq",
              "question": "When does a hybrid sorting algorithm typically switch to insertion sort?",
              "options": ["Never", "For arrays smaller than 10-50 elements", "Only for sorted arrays", "When memory is low"],
              "correctAnswer": "For arrays smaller than 10-50 elements",
              "explanation": "Insertion sort's low overhead makes it faster than complex algorithms for small subarrays.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q62k",
              "type": "mcq",
              "question": "What is the main advantage of hybrid sorting algorithms?",
              "options": ["Simpler code", "Combine benefits of different algorithms", "Use less memory", "Always stable"],
              "correctAnswer": "Combine benefits of different algorithms",
              "explanation": "Hybrid algorithms leverage strengths of different sorting methods for various input characteristics.",
              "difficulty": "medium",
              "topic": "sorting"
            }
          ]
        },
        {
          "id": "external-sorting",
          "title": "External Sorting",
          "description": "Sorting data that doesn't fit in memory",
          "xpReward": 95,
          "questions": [
            {
              "id": "q62l",
              "type": "mcq",
              "question": "What is the main challenge in external sorting?",
              "options": ["Data doesn't fit in memory", "Slow processors", "Network latency", "Power consumption"],
              "correctAnswer": "Data doesn't fit in memory",
              "explanation": "External sorting deals with datasets too large to fit entirely in RAM, requiring disk-based algorithms.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q62m",
              "type": "fillInBlank",
              "question": "External merge sort divides large files into smaller _____ that can fit in memory.",
              "acceptedAnswers": ["runs", "Runs", "RUNS", "sorted-runs", "Sorted-Runs", "RUNS", "sorted-run", "Sorted-Run", "RUNS"],
              "explanation": "External merge sort creates sorted runs that fit in memory, then merges them using k-way merging.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q62n",
              "type": "mcq",
              "question": "What data structure is commonly used in k-way merging for external sorting?",
              "options": ["Stack", "Queue", "Min heap", "Hash table"],
              "correctAnswer": "Min heap",
              "explanation": "A min heap efficiently maintains the smallest elements from k sorted runs during merging.",
              "difficulty": "hard",
              "topic": "sorting"
            },
            {
              "id": "q62o",
              "type": "mcq",
              "question": "Why is disk I/O the bottleneck in external sorting?",
              "options": ["CPU is too fast", "Disk access is much slower than memory", "Network congestion", "Limited bandwidth"],
              "correctAnswer": "Disk access is much slower than memory",
              "explanation": "Disk I/O is orders of magnitude slower than memory access, making it the limiting factor.",
              "difficulty": "easy",
              "topic": "sorting"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-9",
      "title": "Greedy",
      "description": "Making locally optimal choices for global solutions",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "greedy-basics",
          "title": "Basics",
          "description": "Understanding the greedy approach and when to use it",
          "xpReward": 65,
          "questions": [
            {
              "id": "q65",
              "type": "mcq",
              "question": "What is the key principle of greedy algorithms?",
              "options": ["Try all possible solutions", "Make locally optimal choices", "Use dynamic programming", "Divide and conquer"],
              "correctAnswer": "Make locally optimal choices",
              "explanation": "Greedy algorithms make the best local choice at each step, hoping to find a global optimum.",
              "difficulty": "medium",
              "topic": "greedy"
            },
            {
              "id": "q66",
              "type": "mcq",
              "question": "Why don't greedy algorithms always produce optimal solutions?",
              "options": ["They are too slow to find the best solution", "They make locally optimal choices that may not lead to global optimum", "They require too much memory to store all possibilities", "They are designed for approximation only"],
              "correctAnswer": "They make locally optimal choices that may not lead to global optimum",
              "explanation": "Greedy algorithms make the best choice at each step based on current information, but this locally optimal choice may prevent reaching the globally optimal solution.",
              "difficulty": "hard",
              "topic": "greedy"
            },
            {
              "id": "q67",
              "type": "mcq",
              "question": "What is a key advantage of greedy algorithms?",
              "options": ["Always find optimal solution", "Simple and efficient", "Work for all problems", "Use minimal memory"],
              "correctAnswer": "Simple and efficient",
              "explanation": "Greedy algorithms are typically simple to implement and have good time complexity.",
              "difficulty": "easy",
              "topic": "greedy"
            }
          ]
        },
        {
          "id": "activity-selection",
          "title": "Activity Selection",
          "description": "Classic greedy problem of selecting maximum activities",
          "xpReward": 70,
          "questions": [
            {
              "id": "q68",
              "type": "mcq",
              "question": "In the activity selection problem, what is the greedy choice?",
              "options": ["Select longest activity", "Select activity that starts earliest", "Select activity that finishes earliest", "Select most profitable activity"],
              "correctAnswer": "Select activity that finishes earliest",
              "explanation": "Selecting the activity that finishes earliest leaves maximum room for subsequent activities.",
              "difficulty": "medium",
              "topic": "greedy"
            },
            {
              "id": "q69",
              "type": "mcq",
              "question": "What is the constraint that defines the activity selection problem?",
              "options": ["Activities must be scheduled in chronological order", "Selected activities cannot overlap in time", "Activities must have equal duration", "Activities must maximize total profit"],
              "correctAnswer": "Selected activities cannot overlap in time",
              "explanation": "The activity selection problem seeks to select the maximum number of activities such that no two selected activities have overlapping time intervals.",
              "difficulty": "medium",
              "topic": "greedy"
            }
          ]
        },
        {
          "id": "huffman-coding",
          "title": "Huffman Coding",
          "description": "Optimal prefix-free codes using greedy approach",
          "xpReward": 80,
          "questions": [
            {
              "id": "q70",
              "type": "mcq",
              "question": "What does Huffman coding optimize?",
              "options": ["Memory usage", "Code length based on frequency", "Processing speed", "Security"],
              "correctAnswer": "Code length based on frequency",
              "explanation": "Huffman coding assigns shorter codes to more frequent characters, minimizing total code length.",
              "difficulty": "medium",
              "topic": "greedy"
            },
            {
              "id": "q71",
              "type": "mcq",
              "question": "How does Huffman coding achieve optimal prefix-free encoding?",
              "options": ["By assigning equal-length codes to all characters", "By assigning shorter codes to more frequent characters", "By sorting characters alphabetically before encoding", "By using fixed-width codes for efficiency"],
              "correctAnswer": "By assigning shorter codes to more frequent characters",
              "explanation": "Huffman coding creates an optimal prefix-free code by building a binary tree where more frequent characters have shorter paths from root to leaf, resulting in shorter codes.",
              "difficulty": "hard",
              "topic": "greedy"
            }
          ]
        },
        {
          "id": "interval-scheduling",
          "title": "Interval Scheduling",
          "description": "Selecting maximum number of non-overlapping intervals",
          "xpReward": 85,
          "questions": [
            {
              "id": "q69a",
              "type": "mcq",
              "question": "In the interval scheduling problem, what greedy choice leads to an optimal solution?",
              "options": ["Select shortest intervals first", "Select intervals with earliest finish time", "Select intervals with latest start time", "Select intervals with maximum profit"],
              "correctAnswer": "Select intervals with earliest finish time",
              "explanation": "Selecting intervals by earliest finish time leaves the most room for future intervals, proving optimal.",
              "difficulty": "medium",
              "topic": "greedy"
            },
            {
              "id": "q69b",
              "type": "fillInBlank",
              "question": "The interval scheduling algorithm sorts intervals by _____ time and greedily selects compatible intervals.",
              "acceptedAnswers": ["finish", "Finish", "FINISH", "finish-time", "Finish-Time", "FINISH-TIME", "finish-time-and-greedily-selects-compatible-intervals", "Finish-Time-And-Greedily-Selects-Compatible-Intervals", "FINISH-TIME-AND-GREEDILY-SELECTS-COMPATIBLE-INTERVALS"],
              "explanation": "Sorting by finish time allows the greedy algorithm to maximize the number of selected intervals.",
              "difficulty": "medium",
              "topic": "greedy"
            },
            {
              "id": "q69c",
              "type": "mcq",
              "question": "What is the time complexity of the interval scheduling algorithm?",
              "options": ["O(n)", "O(n log n)", "O(n²)", "O(2ⁿ)"],
              "correctAnswer": "O(n log n)",
              "explanation": "The algorithm requires O(n log n) time for sorting, followed by O(n) time for greedy selection.",
              "difficulty": "medium",
              "topic": "greedy"
            },
            {
              "id": "q69d",
              "type": "mcq",
              "question": "Which of these problems can be solved optimally using a greedy approach similar to interval scheduling?",
              "options": ["Fractional knapsack", "0/1 knapsack", "Traveling salesman", "Subset sum"],
              "correctAnswer": "Fractional knapsack",
              "explanation": "Fractional knapsack can be solved optimally by greedily selecting items by value-to-weight ratio.",
              "difficulty": "hard",
              "topic": "greedy"
            }
          ]
        },
        {
          "id": "greedy-graph-algorithms",
          "title": "Greedy Graph Algorithms",
          "description": "Minimum spanning trees and shortest paths",
          "xpReward": 90,
          "questions": [
            {
              "id": "q70a",
              "type": "mcq",
              "question": "Which algorithm uses a greedy approach to find minimum spanning trees?",
              "options": ["Bellman-Ford", "Floyd-Warshall", "Kruskal's algorithm", "Topological sort"],
              "correctAnswer": "Kruskal's algorithm",
              "explanation": "Kruskal's algorithm greedily adds the smallest weight edge that doesn't create a cycle.",
              "difficulty": "medium",
              "topic": "greedy"
            },
            {
              "id": "q70b",
              "type": "fillInBlank",
              "question": "Prim's algorithm builds a minimum spanning tree by starting with a vertex and greedily adding the _____ weight edge to the tree.",
              "acceptedAnswers": ["minimum", "Minimum", "MINIMUM", "minimum-weight-edge", "Minimum-Weight-Edge", "MINIMUM-WEIGHT-EDGE", "minimum-weight-edge-to-tree", "Minimum-Weight-Edge-To-Tree", "MINIMUM-WEIGHT-EDGE-TO-TREE"],
              "explanation": "Prim's algorithm maintains a growing tree and adds the minimum weight edge connecting the tree to a new vertex.",
              "difficulty": "medium",
              "topic": "greedy"
            },
            {
              "id": "q70c",
              "type": "mcq",
              "question": "What data structure does Dijkstra's algorithm typically use for efficient implementation?",
              "options": ["Stack", "Queue", "Priority queue", "Hash table"],
              "correctAnswer": "Priority queue",
              "explanation": "Dijkstra's algorithm uses a priority queue to efficiently extract the vertex with minimum distance.",
              "difficulty": "medium",
              "topic": "greedy"
            },
            {
              "id": "q70d",
              "type": "mcq",
              "question": "Why does Dijkstra's algorithm fail with negative edge weights?",
              "options": ["It becomes too slow", "It uses too much memory", "The greedy choice becomes suboptimal", "It cannot handle negative numbers"],
              "correctAnswer": "The greedy choice becomes suboptimal",
              "explanation": "With negative weights, choosing the current shortest path may not lead to the global optimum due to negative cycles.",
              "difficulty": "hard",
              "topic": "greedy"
            }
          ]
        },
        {
          "id": "greedy-optimization",
          "title": "Advanced Greedy Techniques",
          "description": "Huffman coding and exchange arguments",
          "xpReward": 95,
          "questions": [
            {
              "id": "q71a",
              "type": "mcq",
              "question": "What principle does Huffman coding use to create optimal prefix codes?",
              "options": ["Merge least frequent symbols first", "Merge most frequent symbols first", "Merge symbols randomly", "Merge symbols alphabetically"],
              "correctAnswer": "Merge least frequent symbols first",
              "explanation": "Huffman coding greedily merges the two least frequent symbols to minimize expected code length.",
              "difficulty": "hard",
              "topic": "greedy"
            },
            {
              "id": "q71b",
              "type": "fillInBlank",
              "question": "An _____ argument is used to prove that a greedy algorithm produces an optimal solution by showing any optimal solution can be transformed into the greedy solution.",
              "acceptedAnswers": ["exchange", "Exchange", "EXCHANGE", "exchange-argument", "Exchange-Argument", "EXCHANGE-ARGUMENT", "exchange-argument-for-optimality", "Exchange-Argument-For-Optimality", "EXCHANGE-ARGUMENT-FOR-OPTIMALITY"],
              "explanation": "Exchange arguments prove optimality by showing that swapping elements in any optimal solution with greedy choices maintains optimality.",
              "difficulty": "hard",
              "topic": "greedy"
            },
            {
              "id": "q71c",
              "type": "mcq",
              "question": "In the coin change problem with standard denominations, why does the greedy algorithm work?",
              "options": ["Coins have equal value", "Denominatations form a canonical system", "There are infinite coins", "Algorithm is always optimal"],
              "correctAnswer": "Denominatations form a canonical system",
              "explanation": "Standard coin systems are canonical, meaning the greedy approach (largest denomination first) always gives minimum coins.",
              "difficulty": "hard",
              "topic": "greedy"
            },
            {
              "id": "q71d",
              "type": "mcq",
              "question": "What makes a problem suitable for a greedy approach?",
              "options": ["It has overlapping subproblems", "It exhibits optimal substructure and greedy choice property", "It can be solved recursively", "It has exponential solutions"],
              "correctAnswer": "It exhibits optimal substructure and greedy choice property",
              "explanation": "Greedy algorithms work when problems have optimal substructure and the greedy choice property holds.",
              "difficulty": "hard",
              "topic": "greedy"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-10",
      "title": "Dynamic Programming",
      "description": "Optimizing recursive problems with memoization",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "dp-basics",
          "title": "Basics",
          "description": "Understanding overlapping subproblems and optimal substructure",
          "xpReward": 80,
          "questions": [
            {
              "id": "q63",
              "type": "mcq",
              "question": "What are the two key properties of dynamic programming problems?",
              "options": ["Fast and efficient", "Overlapping subproblems and optimal substructure", "Recursive and iterative", "Simple and complex"],
              "correctAnswer": "Overlapping subproblems and optimal substructure",
              "explanation": "DP problems must have overlapping subproblems and optimal substructure to benefit from memoization.",
              "difficulty": "hard",
              "topic": "dp"
            }
          ]
        },
        {
          "id": "fibonacci-dp",
          "title": "Fibonacci DP",
          "description": "Classic example of dynamic programming optimization",
          "xpReward": 60,
          "questions": [
            {
              "id": "q64",
              "type": "mcq",
              "question": "Why does memoization dramatically improve the fibonacci algorithm's performance?",
              "options": ["It uses less memory per recursive call", "It eliminates redundant subproblem calculations", "It converts recursion to iteration automatically", "It uses a more efficient comparison operation"],
              "correctAnswer": "It eliminates redundant subproblem calculations",
              "explanation": "Memoization stores the results of previously computed fibonacci numbers, avoiding the exponential number of redundant calculations that occur in the naive recursive approach.",
              "difficulty": "hard",
              "topic": "dp"
            }
          ]
        },
        {
          "id": "classic-dp-problems",
          "title": "Classic DP Problems",
          "description": "Longest Common Subsequence and Edit Distance",
          "xpReward": 85,
          "questions": [
            {
              "id": "q74a",
              "type": "mcq",
              "question": "In the Longest Common Subsequence (LCS) problem, what does dp[i][j] typically represent?",
              "options": ["Length of string i up to j", "LCS length of first i chars of string1 and first j chars of string2", "Number of mismatches", "Total string length"],
              "correctAnswer": "LCS length of first i chars of string1 and first j chars of string2",
              "explanation": "The DP table stores the length of the LCS for prefixes of both input strings.",
              "difficulty": "medium",
              "topic": "dynamic_programming"
            },
            {
              "id": "q74b",
              "type": "fillInBlank",
              "question": "The edit distance between two strings is the minimum number of _____, insertions, and deletions needed to transform one string into another.",
              "acceptedAnswers": ["substitutions", "Substitutions", "SUBSTITUTIONS", "edit-distance", "Edit-Distance", "EDIT-DISTANCE", "edit-distance-between-two-strings", "Edit-Distance-Between-Two-Strings", "EDIT-DISTANCE-BETWEEN-TWO-STRINGS"],
              "explanation": "Edit distance (Levenshtein distance) counts substitutions, insertions, and deletions as basic operations.",
              "difficulty": "medium",
              "topic": "dynamic_programming"
            },
            {
              "id": "q74c",
              "type": "mcq",
              "question": "What is the time complexity of the standard DP solution for LCS of two strings of length m and n?",
              "options": ["O(m)", "O(n)", "O(m*n)", "O(m^n)"],
              "correctAnswer": "O(m*n)",
              "explanation": "The DP table has m*n entries, and each entry takes constant time to compute.",
              "difficulty": "medium",
              "topic": "dynamic_programming"
            },
            {
              "id": "q74d",
              "type": "mcq",
              "question": "Which problem is equivalent to finding the minimum edit distance?",
              "options": ["Longest path problem", "Shortest path in a grid", "Maximum flow", "Traveling salesman"],
              "correctAnswer": "Shortest path in a grid",
              "explanation": "Edit distance can be viewed as finding the shortest path in a grid where moves represent edit operations.",
              "difficulty": "hard",
              "topic": "dynamic_programming"
            }
          ]
        },
        {
          "id": "knapsack-variants",
          "title": "Knapsack Problem Variants",
          "description": "0/1 knapsack, unbounded knapsack, and variations",
          "xpReward": 90,
          "questions": [
            {
              "id": "q75a",
              "type": "mcq",
              "question": "What's the key difference between 0/1 knapsack and unbounded knapsack?",
              "options": ["Weight constraints", "Number of items available", "Profit calculation", "Algorithm complexity"],
              "correctAnswer": "Number of items available",
              "explanation": "In 0/1 knapsack each item can be used at most once, while unbounded knapsack allows unlimited use of each item.",
              "difficulty": "medium",
              "topic": "dynamic_programming"
            },
            {
              "id": "q75b",
              "type": "fillInBlank",
              "question": "In the 0/1 knapsack problem, for each item we make a _____ choice: include it or exclude it.",
              "acceptedAnswers": ["binary", "Binary", "BINARY", "binary-choice", "Binary-Choice", "BINARY-CHOICE", "binary-decision", "Binary-Decision", "BINARY-DECISION"],
              "explanation": "The name '0/1 knapsack' comes from the binary choice of taking 0 or 1 copy of each item.",
              "difficulty": "easy",
              "topic": "dynamic_programming"
            },
            {
              "id": "q75c",
              "type": "mcq",
              "question": "What is the space complexity of the standard DP solution for 0/1 knapsack with n items and capacity W?",
              "options": ["O(n)", "O(W)", "O(n*W)", "O(2^n)"],
              "correctAnswer": "O(n*W)",
              "explanation": "The DP table has dimensions n×W to store the maximum value for each item and capacity combination.",
              "difficulty": "medium",
              "topic": "dynamic_programming"
            },
            {
              "id": "q75d",
              "type": "mcq",
              "question": "Which optimization can reduce the space complexity of 0/1 knapsack to O(W)?",
              "options": ["Memoization", "Rolling array technique", "Greedy approach", "Binary search"],
              "correctAnswer": "Rolling array technique",
              "explanation": "Since we only need the previous row to compute the current row, we can use two 1D arrays instead of a 2D table.",
              "difficulty": "hard",
              "topic": "dynamic_programming"
            }
          ]
        },
        {
          "id": "dp-optimization",
          "title": "DP Optimization Techniques",
          "description": "Memoization, bottom-up vs top-down, and space optimization",
          "xpReward": 95,
          "questions": [
            {
              "id": "q76a",
              "type": "mcq",
              "question": "What is the main advantage of memoization over naive recursion?",
              "options": ["Simpler code", "Less memory usage", "Avoids recomputing subproblems", "Faster base case handling"],
              "correctAnswer": "Avoids recomputing subproblems",
              "explanation": "Memoization stores results of subproblems to avoid redundant computations in recursive solutions.",
              "difficulty": "medium",
              "topic": "dynamic_programming"
            },
            {
              "id": "q76b",
              "type": "fillInBlank",
              "question": "A _____ approach builds solutions from the smallest subproblems up to the original problem.",
              "acceptedAnswers": ["bottom-up", "Bottom-Up", "BOTTOM-UP", "bottom-up-dp", "Bottom-Up-Dp", "BOTTOM-UP-DP", "bottom-up-dynamic-programming", "Bottom-Up-Dynamic-Programming", "BOTTOM-UP-DYNAMIC-PROGRAMMING"],
              "explanation": "Bottom-up DP starts with base cases and iteratively builds larger solutions, avoiding recursion overhead.",
              "difficulty": "easy",
              "topic": "dynamic_programming"
            },
            {
              "id": "q76c",
              "type": "mcq",
              "question": "When might top-down DP with memoization be preferred over bottom-up DP?",
              "options": ["When memory is limited", "When only some subproblems are needed", "When base cases are complex", "When recursion is forbidden"],
              "correctAnswer": "When only some subproblems are needed",
              "explanation": "Top-down DP only computes needed subproblems, while bottom-up typically computes all possible subproblems.",
              "difficulty": "hard",
              "topic": "dynamic_programming"
            },
            {
              "id": "q76d",
              "type": "mcq",
              "question": "What technique can help when the DP state space is too large for a standard table?",
              "options": ["State compression", "Greedy approximation", "Random sampling", "Recursive backtracking"],
              "correctAnswer": "State compression",
              "explanation": "State compression reduces the dimensions of the DP table by representing states more efficiently.",
              "difficulty": "hard",
              "topic": "dynamic_programming"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-11",
      "title": "Linked Lists",
      "description": "Dynamic linear data structures with pointer-based connections",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "linked-list-basics",
          "title": "Basics",
          "description": "Understanding nodes, pointers, and basic operations",
          "xpReward": 60,
          "questions": [
            {
              "id": "q72",
              "type": "mcq",
              "question": "What are the two main components of a linked list node?",
              "options": ["Data and index", "Data and next pointer", "Value and size", "Key and value"],
              "correctAnswer": "Data and next pointer",
              "explanation": "Each node contains data (the actual value) and a next pointer (reference to the next node).",
              "difficulty": "easy",
              "topic": "linked-lists"
            },
            {
              "id": "q73",
              "type": "mcq",
              "question": "What is the primary purpose of the head pointer in a linked list?",
              "options": ["To store the largest element", "To provide a reference to the first node", "To count the total number of nodes", "To mark the end of the list"],
              "correctAnswer": "To provide a reference to the first node",
              "explanation": "The head pointer serves as the entry point to the linked list, providing a reference to the first node from which all other nodes can be accessed.",
              "difficulty": "medium",
              "topic": "linked-lists"
            },
            {
              "id": "q74",
              "type": "mcq",
              "question": "What is the time complexity of inserting at the beginning of a linked list?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
              "correctAnswer": "O(1)",
              "explanation": "Inserting at the beginning only requires updating the head pointer and the new node's next pointer.",
              "difficulty": "medium",
              "topic": "linked-lists"
            }
          ]
        },
        {
          "id": "linked-list-types",
          "title": "Types",
          "description": "Singly, doubly, and circular linked lists",
          "xpReward": 65,
          "questions": [
            {
              "id": "q75",
              "type": "mcq",
              "question": "What is the main advantage of a doubly linked list over a singly linked list?",
              "options": ["Uses less memory", "Allows efficient bidirectional traversal", "Faster insertion at the beginning", "Simpler implementation"],
              "correctAnswer": "Allows efficient bidirectional traversal",
              "explanation": "Doubly linked lists have both next and previous pointers, allowing efficient traversal in both directions without restarting from the head.",
              "difficulty": "medium",
              "topic": "linked-lists"
            },
            {
              "id": "q76",
              "type": "mcq",
              "question": "What is the key characteristic of a circular linked list?",
              "options": ["It has no beginning or end", "The last node points to the first node", "All nodes point to a central hub", "It can only be traversed in one direction"],
              "correctAnswer": "The last node points to the first node",
              "explanation": "In a circular linked list, the last node's next pointer points back to the first node, creating a closed loop structure.",
              "difficulty": "medium",
              "topic": "linked-lists"
            }
          ]
        },
        {
          "id": "doubly-linked-lists",
          "title": "Doubly Linked Lists",
          "description": "Bidirectional traversal and operations",
          "xpReward": 75,
          "questions": [
            {
              "id": "q78a",
              "type": "mcq",
              "question": "What is the trade-off when using doubly linked lists compared to singly linked lists?",
              "options": ["Faster insertion but slower deletion", "Higher memory overhead but bidirectional traversal", "Simpler implementation but limited functionality", "Better cache performance but more complex algorithms"],
              "correctAnswer": "Higher memory overhead but bidirectional traversal",
              "explanation": "Doubly linked lists require extra memory for the previous pointer in each node, but this enables efficient traversal in both directions and O(1) deletion when you have a reference to the node.",
              "difficulty": "hard",
              "topic": "linked_lists"
            },
            {
              "id": "q78b",
              "type": "fillInBlank",
              "question": "The main advantage of doubly linked lists is _____ traversal in both directions.",
              "acceptedAnswers": ["efficient", "Efficient", "EFFICIENT", "efficient-traversal", "Efficient-Traversal", "EFFICIENT-TRAVERSAL", "efficient-traversal-in-both-directions", "Efficient-Traversal-In-Both-Directions", "EFFICIENT-TRAVERSAL-IN-BOTH-DIRECTIONS"],
              "explanation": "Doubly linked lists allow efficient traversal backward and forward without restarting from the head.",
              "difficulty": "easy",
              "topic": "linked_lists"
            },
            {
              "id": "q78c",
              "type": "mcq",
              "question": "What is the time complexity of deleting a node when you have a direct reference to it in a doubly linked list?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
              "correctAnswer": "O(1)",
              "explanation": "With both next and previous pointers, we can update adjacent nodes directly without traversing the list.",
              "difficulty": "medium",
              "topic": "linked_lists"
            },
            {
              "id": "q78d",
              "type": "mcq",
              "question": "What is the main disadvantage of doubly linked lists compared to singly linked lists?",
              "options": ["Slower insertion", "Higher memory overhead", "No backward traversal", "Complex deletion"],
              "correctAnswer": "Higher memory overhead",
              "explanation": "Each node requires an additional pointer, increasing memory usage compared to singly linked lists.",
              "difficulty": "medium",
              "topic": "linked_lists"
            }
          ]
        },
        {
          "id": "circular-linked-lists",
          "title": "Circular Linked Lists",
          "description": "Lists where the last node points to the first",
          "xpReward": 80,
          "questions": [
            {
              "id": "q79a",
              "type": "mcq",
              "question": "In a circular linked list, what does the last node point to?",
              "options": ["NULL", "The first node", "The previous node", "A sentinel node"],
              "correctAnswer": "The first node",
              "explanation": "In circular linked lists, the last node's next pointer points back to the first node, forming a cycle.",
              "difficulty": "easy",
              "topic": "linked_lists"
            },
            {
              "id": "q79b",
              "type": "fillInBlank",
              "question": "The main challenge in traversing circular linked lists is avoiding _____ loops.",
              "acceptedAnswers": ["infinite", "Infinite", "INFINITE", "infinite-loops", "Infinite-Loops", "INFINITE-LOOPS", "infinite-loop", "Infinite-Loop", "INFINITE-LOOP"],
              "explanation": "Since there's no NULL terminator, traversal must track the starting point to avoid infinite loops.",
              "difficulty": "medium",
              "topic": "linked_lists"
            },
            {
              "id": "q79c",
              "type": "mcq",
              "question": "What is a practical application of circular linked lists?",
              "options": ["Binary search", "Hash tables", "Round-robin scheduling", "Stack implementation"],
              "correctAnswer": "Round-robin scheduling",
              "explanation": "Circular lists naturally represent cyclic processes like round-robin CPU scheduling where processes are served in rotation.",
              "difficulty": "medium",
              "topic": "linked_lists"
            },
            {
              "id": "q79d",
              "type": "mcq",
              "question": "How can you detect if a linked list is circular?",
              "options": ["Count nodes", "Floyd's cycle detection algorithm", "Check for NULL", "Use recursion"],
              "correctAnswer": "Floyd's cycle detection algorithm",
              "explanation": "Floyd's algorithm (tortoise and hare) uses two pointers moving at different speeds to detect cycles efficiently.",
              "difficulty": "hard",
              "topic": "linked_lists"
            }
          ]
        },
        {
          "id": "skip-lists",
          "title": "Skip Lists",
          "description": "Probabilistic data structure for fast search",
          "xpReward": 90,
          "questions": [
            {
              "id": "q80a",
              "type": "mcq",
              "question": "What is the expected time complexity for search in a skip list?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
              "correctAnswer": "O(log n)",
              "explanation": "Skip lists provide probabilistic O(log n) search time by maintaining multiple levels of linked lists.",
              "difficulty": "medium",
              "topic": "linked_lists"
            },
            {
              "id": "q80b",
              "type": "fillInBlank",
              "question": "Skip lists use _____ to determine how many levels a new node should appear in.",
              "acceptedAnswers": ["randomization", "Randomization", "RANDOMIZATION", "random-coin-flips", "Random-Coin-Flips", "RANDOM-COIN-FLIPS", "random-coin-flip", "Random-Coin-Flip", "RANDOM-COIN-FLIP"],
              "explanation": "Skip lists use random coin flips to determine node height, creating a probabilistically balanced structure.",
              "difficulty": "medium",
              "topic": "linked_lists"
            },
            {
              "id": "q80c",
              "type": "mcq",
              "question": "What advantage do skip lists have over balanced binary search trees?",
              "options": ["Better worst-case guarantees", "Simpler implementation", "Less memory usage", "Faster best-case search"],
              "correctAnswer": "Simpler implementation",
              "explanation": "Skip lists avoid complex rebalancing operations needed in balanced trees, while providing similar expected performance.",
              "difficulty": "hard",
              "topic": "linked_lists"
            },
            {
              "id": "q80d",
              "type": "mcq",
              "question": "In a skip list, what is the probability that a node appears in level k+1 given it appears in level k?",
              "options": ["0.25", "0.5", "0.75", "1.0"],
              "correctAnswer": "0.5",
              "explanation": "Typically, skip lists use p=0.5, meaning each level has roughly half the nodes of the level below it.",
              "difficulty": "hard",
              "topic": "linked_lists"
            }
          ]
        },
        {
          "id": "linked-list-applications",
          "title": "Advanced Applications",
          "description": "Real-world uses and implementation techniques",
          "xpReward": 85,
          "questions": [
            {
              "id": "q81a",
              "type": "mcq",
              "question": "Which data structure commonly uses linked lists in its implementation?",
              "options": ["Array", "Hash table with chaining", "Binary search tree", "Heap"],
              "correctAnswer": "Hash table with chaining",
              "explanation": "Hash tables often use linked lists to handle collisions by chaining multiple elements in the same bucket.",
              "difficulty": "medium",
              "topic": "linked_lists"
            },
            {
              "id": "q81b",
              "type": "fillInBlank",
              "question": "Memory _____ lists are used by operating systems to track free memory blocks.",
              "acceptedAnswers": ["free", "Free", "FREE", "free-lists", "Free-Lists", "FREE-LISTS", "free-list", "Free-List", "FREE-LIST"],
              "explanation": "Operating systems maintain free lists to efficiently allocate and deallocate variable-sized memory blocks.",
              "difficulty": "medium",
              "topic": "linked_lists"
            },
            {
              "id": "q81c",
              "type": "mcq",
              "question": "What technique helps improve cache performance when working with linked lists?",
              "options": ["Use smaller nodes", "Store multiple elements per node", "Use circular lists", "Avoid pointers"],
              "correctAnswer": "Store multiple elements per node",
              "explanation": "Unrolled linked lists store multiple elements per node, improving cache locality and reducing pointer overhead.",
              "difficulty": "hard",
              "topic": "linked_lists"
            },
            {
              "id": "q81d",
              "type": "mcq",
              "question": "In which scenario would linked lists be preferred over dynamic arrays?",
              "options": ["Random access needed", "Memory is limited", "Frequent insertions/deletions at arbitrary positions", "Cache performance is critical"],
              "correctAnswer": "Frequent insertions/deletions at arbitrary positions",
              "explanation": "Linked lists excel when the position of insertions/deletions is known and random access is not required.",
              "difficulty": "medium",
              "topic": "linked_lists"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-12",
      "title": "Heaps",
      "description": "Complete binary trees with heap property for priority operations",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "heap-basics",
          "title": "Basics",
          "description": "Understanding heap property and binary heap structure",
          "xpReward": 70,
          "questions": [
            {
              "id": "q77",
              "type": "mcq",
              "question": "What is the heap property for a max heap?",
              "options": ["Parent ≤ children", "Parent ≥ children", "Left child ≤ right child", "All nodes are equal"],
              "correctAnswer": "Parent ≥ children",
              "explanation": "In a max heap, every parent node is greater than or equal to its children.",
              "difficulty": "medium",
              "topic": "heaps"
            },
            {
              "id": "q78",
              "type": "mcq",
              "question": "Why does insertion in a binary heap have O(log n) time complexity?",
              "options": ["The heap must be completely rebuilt after each insertion", "Elements may need to bubble up through log n levels to maintain heap property", "All existing elements must be compared with the new element", "The heap array must be resized and elements copied"],
              "correctAnswer": "Elements may need to bubble up through log n levels to maintain heap property",
              "explanation": "In the worst case, a newly inserted element may need to bubble up from the bottom of the heap to the root, traversing at most log n levels in a complete binary tree.",
              "difficulty": "hard",
              "topic": "heaps"
            },
            {
              "id": "q79",
              "type": "mcq",
              "question": "What operation extracts the maximum element from a max heap?",
              "options": ["peek", "extract-max", "heapify", "build-heap"],
              "correctAnswer": "extract-max",
              "explanation": "Extract-max removes and returns the maximum element (root) from a max heap.",
              "difficulty": "easy",
              "topic": "heaps"
            }
          ]
        },
        {
          "id": "priority-queues",
          "title": "Priority Queues",
          "description": "Using heaps to implement priority queues",
          "xpReward": 75,
          "questions": [
            {
              "id": "q80",
              "type": "mcq",
              "question": "What data structure is commonly used to implement a priority queue?",
              "options": ["Array", "Stack", "Binary heap", "Hash table"],
              "correctAnswer": "Binary heap",
              "explanation": "Binary heaps provide efficient O(log n) insertion and O(log n) extraction of highest priority elements.",
              "difficulty": "medium",
              "topic": "heaps"
            },
            {
              "id": "q81",
              "type": "mcq",
              "question": "What distinguishes a priority queue from a regular queue in terms of element ordering?",
              "options": ["Priority queues maintain FIFO order but process faster", "Priority queues serve elements based on priority rather than insertion order", "Priority queues reverse the order of elements like a stack", "Priority queues randomly select elements to serve next"],
              "correctAnswer": "Priority queues serve elements based on priority rather than insertion order",
              "explanation": "Unlike regular queues that follow FIFO (First In First Out), priority queues serve the element with the highest priority first, regardless of when it was inserted.",
              "difficulty": "medium",
              "topic": "heaps"
            }
          ]
        },
        {
          "id": "heap-construction",
          "title": "Building Heaps",
          "description": "Different methods to construct heaps from arrays",
          "xpReward": 80,
          "questions": [
            {
              "id": "q82a",
              "type": "mcq",
              "question": "What is the time complexity of building a heap from an unsorted array using the heapify approach?",
              "options": ["O(n)", "O(n log n)", "O(n²)", "O(log n)"],
              "correctAnswer": "O(n)",
              "explanation": "Bottom-up heapify (Floyd's method) builds a heap in O(n) time by starting from non-leaf nodes and working upward.",
              "difficulty": "medium",
              "topic": "heaps"
            },
            {
              "id": "q82b",
              "type": "fillInBlank",
              "question": "When building a heap using repeated insertions, the time complexity is _____ .",
              "acceptedAnswers": ["O(n log n)", "O(n log n)", "O(N LOG N)", "n-log-n-time-for-building-heap-using-repeated-insertions", "N-Log-N-Time-For-Building-Heap-Using-Repeated-Insertions", "N-LOG-N-TIME-FOR-BUILDING-HEAP-USING-REPEATED-INSERTIONS", "n-log-n-time-for-building-heap-using-repeated-insertions-in-binary-heap", "N-Log-N-Time-For-Building-Heap-Using-Repeated-Insertions-In-Binary-Heap", "N-LOG-N-TIME-FOR-BUILDING-HEAP-USING-REPEATED-INSERTIONS-IN-BINARY-HEAP"],
              "explanation": "Inserting n elements one by one into a heap takes O(log n) time per insertion, totaling O(n log n).",
              "difficulty": "medium",
              "topic": "heaps"
            },
            {
              "id": "q82c",
              "type": "mcq",
              "question": "In the heapify process, which nodes need to be processed?",
              "options": ["All nodes", "Only leaf nodes", "Only non-leaf nodes", "Only the root"],
              "correctAnswer": "Only non-leaf nodes",
              "explanation": "Leaf nodes are already valid heaps, so heapify only processes non-leaf nodes from bottom to top.",
              "difficulty": "medium",
              "topic": "heaps"
            },
            {
              "id": "q82d",
              "type": "mcq",
              "question": "What is the index of the last non-leaf node in a heap array of size n?",
              "options": ["n/2", "⌊n/2⌋", "⌊n/2⌋ - 1", "n - 1"],
              "correctAnswer": "⌊n/2⌋ - 1",
              "explanation": "In a 0-indexed array, the last non-leaf node is at index ⌊n/2⌋ - 1, which is the parent of the last element.",
              "difficulty": "hard",
              "topic": "heaps"
            }
          ]
        },
        {
          "id": "heapsort-analysis",
          "title": "Heapsort Algorithm",
          "description": "In-place sorting using heap properties",
          "xpReward": 85,
          "questions": [
            {
              "id": "q83a",
              "type": "mcq",
              "question": "What is the time complexity of heapsort in all cases?",
              "options": ["O(n)", "O(n log n)", "O(n²)", "O(2ⁿ)"],
              "correctAnswer": "O(n log n)",
              "explanation": "Heapsort consistently performs in O(n log n) time regardless of input distribution, making it a reliable sorting algorithm.",
              "difficulty": "medium",
              "topic": "heaps"
            },
            {
              "id": "q83b",
              "type": "fillInBlank",
              "question": "Heapsort is an _____ sorting algorithm, meaning it sorts without using extra space.",
              "acceptedAnswers": ["in-place", "In-Place", "IN-PLACE", "in-place-sorting", "In-Place-Sorting", "IN-PLACE-SORTING", "in-place-sort", "In-Place-Sort", "IN-PLACE-SORT"],
              "explanation": "Heapsort rearranges elements within the original array without requiring additional memory proportional to input size.",
              "difficulty": "easy",
              "topic": "heaps"
            },
            {
              "id": "q83c",
              "type": "mcq",
              "question": "What happens after extracting the maximum element in heapsort?",
              "options": ["The heap shrinks by one", "A new heap is created", "All elements are reordered", "The algorithm terminates"],
              "correctAnswer": "The heap shrinks by one",
              "explanation": "After extracting the maximum, the heap size is reduced by one and the heap property is restored for the remaining elements.",
              "difficulty": "medium",
              "topic": "heaps"
            },
            {
              "id": "q83d",
              "type": "mcq",
              "question": "How does heapsort compare to quicksort in terms of worst-case performance?",
              "options": ["Heapsort is worse", "They're the same", "Heapsort is better", "It depends on input"],
              "correctAnswer": "Heapsort is better",
              "explanation": "Heapsort guarantees O(n log n) worst-case time, while quicksort has O(n²) worst-case performance.",
              "difficulty": "medium",
              "topic": "heaps"
            }
          ]
        },
        {
          "id": "heap-variants",
          "title": "Heap Variants",
          "description": "Binomial heaps, Fibonacci heaps, and other variants",
          "xpReward": 95,
          "questions": [
            {
              "id": "q84a",
              "type": "mcq",
              "question": "What advantage do Fibonacci heaps have over binary heaps?",
              "options": ["Faster search", "Better decrease-key operation", "Less memory usage", "Simpler implementation"],
              "correctAnswer": "Better decrease-key operation",
              "explanation": "Fibonacci heaps support decrease-key in O(1) amortized time, while binary heaps require O(log n).",
              "difficulty": "hard",
              "topic": "heaps"
            },
            {
              "id": "q84b",
              "type": "fillInBlank",
              "question": "A _____ heap is a set of heap-ordered trees where each tree is a perfect binary tree.",
              "acceptedAnswers": ["binomial", "Binomial", "BINOMIAL", "binomial-heap", "Binomial-Heap", "BINOMIAL-HEAP", "binomial-heap-set", "Binomial-Heap-Set", "BINOMIAL-HEAP-SET"],
              "explanation": "Binomial heaps consist of binomial trees, which are heap-ordered and have specific structural properties.",
              "difficulty": "hard",
              "topic": "heaps"
            },
            {
              "id": "q84c",
              "type": "mcq",
              "question": "Which heap variant is commonly used in Dijkstra's algorithm implementation?",
              "options": ["Binary heap", "Fibonacci heap", "Binomial heap", "Ternary heap"],
              "correctAnswer": "Fibonacci heap",
              "explanation": "Fibonacci heaps are preferred in Dijkstra's algorithm due to their efficient decrease-key operation needed for distance updates.",
              "difficulty": "hard",
              "topic": "heaps"
            },
            {
              "id": "q84d",
              "type": "mcq",
              "question": "What is a d-ary heap?",
              "options": ["A heap with d elements", "A heap where each node has d children", "A heap with depth d", "A heap storing d-dimensional data"],
              "correctAnswer": "A heap where each node has d children",
              "explanation": "A d-ary heap generalizes binary heaps by allowing each node to have up to d children instead of just 2.",
              "difficulty": "medium",
              "topic": "heaps"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-13",
      "title": "Recursion",
      "description": "Functions that call themselves to solve problems",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "recursion-basics",
          "title": "Basics",
          "description": "Understanding base cases and recursive calls",
          "xpReward": 55,
          "questions": [
            {
              "id": "q82",
              "type": "mcq",
              "question": "What are the two essential components of a recursive function?",
              "options": ["Loop and condition", "Base case and recursive case", "Input and output", "Start and end"],
              "correctAnswer": "Base case and recursive case",
              "explanation": "Every recursive function needs a base case (stopping condition) and a recursive case (calling itself).",
              "difficulty": "medium",
              "topic": "recursion"
            },
            {
              "id": "q83",
              "type": "mcq",
              "question": "What is the primary purpose of the base case in recursive functions?",
              "options": ["To make the function run faster", "To provide the starting point for calculations", "To prevent infinite recursion by providing a stopping condition", "To handle error conditions"],
              "correctAnswer": "To prevent infinite recursion by providing a stopping condition",
              "explanation": "The base case defines the condition under which the recursive function stops calling itself, preventing infinite recursion and eventual stack overflow.",
              "difficulty": "medium",
              "topic": "recursion"
            },
            {
              "id": "q84",
              "type": "mcq",
              "question": "What happens if a recursive function lacks a proper base case?",
              "options": ["It runs faster", "It causes infinite recursion", "It returns null", "It becomes iterative"],
              "correctAnswer": "It causes infinite recursion",
              "explanation": "Without a base case, the function will call itself indefinitely, leading to stack overflow.",
              "difficulty": "medium",
              "topic": "recursion"
            }
          ]
        },
        {
          "id": "recursion-examples",
          "title": "Classic Examples",
          "description": "Factorial, Fibonacci, and tree traversal",
          "xpReward": 65,
          "questions": [
            {
              "id": "q85",
              "type": "mcq",
              "question": "What is the base case for calculating factorial recursively?",
              "options": ["n = 0 or n = 1", "n = 2", "n < 0", "n > 10"],
              "correctAnswer": "n = 0 or n = 1",
              "explanation": "Factorial of 0 and 1 is 1, which serves as the base case for recursive factorial calculation.",
              "difficulty": "easy",
              "topic": "recursion"
            },
            {
              "id": "q86",
              "type": "fillInBlank",
              "question": "Tree traversal algorithms like preorder and inorder are naturally implemented using _____.",
              "acceptedAnswers": ["recursion", "Recursion", "RECURSION", "recursion-based-tree-traversal", "Recursion-Based-Tree-Traversal", "RECURSION-BASED-TREE-TRAVERSAL", "recursion-for-tree-traversal", "Recursion-For-Tree-Traversal", "RECURSION-FOR-TREE-TRAVERSAL"],
              "explanation": "Tree traversals naturally use recursion to visit nodes in a systematic order.",
              "difficulty": "medium",
              "topic": "recursion"
            }
          ]
        },
        {
          "id": "tail-recursion",
          "title": "Tail Recursion",
          "description": "Optimizing recursive calls for better performance",
          "xpReward": 75,
          "questions": [
            {
              "id": "q86a",
              "type": "mcq",
              "question": "What is a tail recursive function?",
              "options": ["A function that calls itself last", "A function with recursion at the end of the code", "A function where recursive call is the last operation", "A function that returns its tail"],
              "correctAnswer": "A function where recursive call is the last operation",
              "explanation": "In tail recursion, the recursive call is the final operation, allowing for optimization by reusing the stack frame.",
              "difficulty": "medium",
              "topic": "recursion"
            },
            {
              "id": "q86b",
              "type": "fillInBlank",
              "question": "Tail recursion can be optimized into _____ by compilers, eliminating stack overflow risk.",
              "acceptedAnswers": ["iteration", "Iteration", "ITERATION", "tail-recursion-optimization", "Tail-Recursion-Optimization", "TAIL-RECURSION-OPTIMIZATION", "tail-call-optimization", "Tail-Call-Optimization", "TAIL-CALL-OPTIMIZATION"],
              "explanation": "Tail call optimization converts tail recursive functions into iterative loops, using constant stack space.",
              "difficulty": "medium",
              "topic": "recursion"
            },
            {
              "id": "q86c",
              "type": "mcq",
              "question": "Which version of factorial is tail recursive?",
              "options": ["fact(n) = n * fact(n-1)", "fact(n, acc) = fact(n-1, n*acc)", "Both versions", "Neither version"],
              "correctAnswer": "fact(n, acc) = fact(n-1, n*acc)",
              "explanation": "The second version uses an accumulator and makes the recursive call the last operation, making it tail recursive.",
              "difficulty": "hard",
              "topic": "recursion"
            },
            {
              "id": "q86d",
              "type": "mcq",
              "question": "What is the main benefit of tail recursion optimization?",
              "options": ["Faster execution", "Less memory usage", "Simpler code", "Better readability"],
              "correctAnswer": "Less memory usage",
              "explanation": "Tail recursion optimization reduces stack space usage from O(n) to O(1) by reusing stack frames.",
              "difficulty": "medium",
              "topic": "recursion"
            }
          ]
        },
        {
          "id": "tree-recursion",
          "title": "Tree Recursion",
          "description": "Multiple recursive calls and their analysis",
          "xpReward": 85,
          "questions": [
            {
              "id": "q87a",
              "type": "mcq",
              "question": "What characterizes tree recursion?",
              "options": ["It works on trees only", "It makes multiple recursive calls", "It has tree-like structure", "It's always inefficient"],
              "correctAnswer": "It makes multiple recursive calls",
              "explanation": "Tree recursion involves making multiple recursive calls from a single function call, creating a tree-like call structure.",
              "difficulty": "medium",
              "topic": "recursion"
            },
            {
              "id": "q87b",
              "type": "fillInBlank",
              "question": "The naive Fibonacci implementation has _____ time complexity due to redundant calculations.",
              "acceptedAnswers": ["exponential", "Exponential", "EXPONENTIAL", "naive-fibonacci-complexity", "Naive-Fibonacci-Complexity", "NAIVE-FIBONACCI-COMPLEXITY", "naive-fibonacci-recursion", "Naive-Fibonacci-Recursion", "NAIVE-FIBONACCI-RECURSION"],
              "explanation": "Naive Fibonacci has O(2^n) complexity because it recalculates the same values multiple times.",
              "difficulty": "medium",
              "topic": "recursion"
            },
            {
              "id": "q87c",
              "type": "mcq",
              "question": "How can we optimize tree recursive algorithms like Fibonacci?",
              "options": ["Use iteration only", "Add memoization", "Avoid base cases", "Use more recursive calls"],
              "correctAnswer": "Add memoization",
              "explanation": "Memoization stores previously computed results, reducing exponential time complexity to polynomial.",
              "difficulty": "medium",
              "topic": "recursion"
            },
            {
              "id": "q87d",
              "type": "mcq",
              "question": "Which of these is an example of tree recursion?",
              "options": ["Linear search", "Binary search", "Merge sort", "Quick sort"],
              "correctAnswer": "Merge sort",
              "explanation": "Merge sort makes two recursive calls (left and right halves), exemplifying tree recursion structure.",
              "difficulty": "medium",
              "topic": "recursion"
            }
          ]
        },
        {
          "id": "recursion-vs-iteration",
          "title": "Recursion vs Iteration",
          "description": "Comparing recursive and iterative approaches",
          "xpReward": 80,
          "questions": [
            {
              "id": "q88a",
              "type": "mcq",
              "question": "What is a main advantage of recursion over iteration?",
              "options": ["Always faster", "Less memory usage", "More intuitive for some problems", "Better performance"],
              "correctAnswer": "More intuitive for some problems",
              "explanation": "Recursion naturally models problems with recursive structure like trees and divide-and-conquer algorithms.",
              "difficulty": "medium",
              "topic": "recursion"
            },
            {
              "id": "q88b",
              "type": "fillInBlank",
              "question": "Recursion uses the _____ to store function call information, while iteration typically uses less memory.",
              "acceptedAnswers": ["stack", "Stack", "STACK", "call-stack", "Call-Stack", "CALL-STACK", "recursion-stack", "Recursion-Stack", "RECURSION-STACK"],
              "explanation": "Each recursive call adds a frame to the call stack, which can lead to stack overflow for deep recursion.",
              "difficulty": "easy",
              "topic": "recursion"
            },
            {
              "id": "q88c",
              "type": "mcq",
              "question": "When might iteration be preferred over recursion?",
              "options": ["When working with trees", "When memory is limited", "When code clarity matters", "When using functional programming"],
              "correctAnswer": "When memory is limited",
              "explanation": "Iteration typically uses less memory than recursion since it doesn't need to maintain a call stack.",
              "difficulty": "medium",
              "topic": "recursion"
            },
            {
              "id": "q88d",
              "type": "mcq",
              "question": "Any recursive algorithm can be converted to:",
              "options": ["A greedy algorithm", "An iterative algorithm", "A dynamic programming solution", "A divide-and-conquer approach"],
              "correctAnswer": "An iterative algorithm",
              "explanation": "Any recursive algorithm can be converted to iteration using explicit stack management, though it may be more complex.",
              "difficulty": "hard",
              "topic": "recursion"
            }
          ]
        },
        {
          "id": "advanced-recursion",
          "title": "Advanced Recursive Techniques",
          "description": "Mutual recursion, continuation passing, and optimization",
          "xpReward": 95,
          "questions": [
            {
              "id": "q89a",
              "type": "mcq",
              "question": "What is mutual recursion?",
              "options": ["Two functions calling each other", "Multiple base cases", "Recursive data structures", "Parallel recursion"],
              "correctAnswer": "Two functions calling each other",
              "explanation": "Mutual recursion occurs when two or more functions call each other recursively to solve a problem.",
              "difficulty": "hard",
              "topic": "recursion"
            },
            {
              "id": "q89b",
              "type": "fillInBlank",
              "question": "_____ passing style (CPS) is a functional programming technique where functions never return but pass results to continuation functions.",
              "acceptedAnswers": ["Continuation", "Continuation", "CONTINUATION", "continuation-passing-style", "Continuation-Passing-Style", "CONTINUATION-PASSING-STYLE", "continuation-passing-style-cps", "Continuation-Passing-Style-Cps", "CONTINUATION-PASSING-STYLE-CPS"],
              "explanation": "Continuation passing style transforms recursion by explicitly passing what to do next as a function parameter.",
              "difficulty": "hard",
              "topic": "recursion"
            },
            {
              "id": "q89c",
              "type": "mcq",
              "question": "Which technique can convert any recursion to tail recursion?",
              "options": ["Memoization", "Continuation passing style", "Loop unrolling", "Dynamic programming"],
              "correctAnswer": "Continuation passing style",
              "explanation": "CPS can transform any recursive function into tail-recursive form by explicitly managing continuations.",
              "difficulty": "hard",
              "topic": "recursion"
            },
            {
              "id": "q89d",
              "type": "mcq",
              "question": "What is trampolining in the context of recursion?",
              "options": ["Jumping between functions", "Converting recursion to iteration", "Optimizing tail calls", "Eliminating stack overflow"],
              "correctAnswer": "Eliminating stack overflow",
              "explanation": "Trampolining is a technique to eliminate stack overflow by converting recursive calls into a loop with function objects.",
              "difficulty": "hard",
              "topic": "recursion"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-14",
      "title": "Searching",
      "description": "Algorithms for finding elements in data structures",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "linear-search",
          "title": "Linear Search",
          "description": "Sequential searching through elements",
          "xpReward": 45,
          "questions": [
            {
              "id": "q87",
              "type": "mcq",
              "question": "What is the time complexity of linear search?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
              "correctAnswer": "O(n)",
              "explanation": "Linear search checks each element sequentially, taking O(n) time in the worst case.",
              "difficulty": "easy",
              "topic": "searching"
            },
            {
              "id": "q88",
              "type": "mcq",
              "question": "What is the primary advantage of linear search over binary search?",
              "options": ["Linear search is always faster", "Linear search works on both sorted and unsorted data", "Linear search uses less memory", "Linear search has better worst-case performance"],
              "correctAnswer": "Linear search works on both sorted and unsorted data",
              "explanation": "Unlike binary search which requires sorted data, linear search can work on any arrangement of data since it checks each element sequentially.",
              "difficulty": "medium",
              "topic": "searching"
            }
          ]
        },
        {
          "id": "binary-search",
          "title": "Binary Search",
          "description": "Efficient searching in sorted arrays",
          "xpReward": 65,
          "questions": [
            {
              "id": "q89",
              "type": "mcq",
              "question": "What is the prerequisite for binary search?",
              "options": ["Array must be large", "Array must be sorted", "Array must have unique elements", "Array must be numeric"],
              "correctAnswer": "Array must be sorted",
              "explanation": "Binary search requires the array to be sorted to eliminate half the search space at each step.",
              "difficulty": "medium",
              "topic": "searching"
            },
            {
              "id": "q90",
              "type": "mcq",
              "question": "What is the time complexity of binary search?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
              "correctAnswer": "O(log n)",
              "explanation": "Binary search halves the search space at each step, resulting in O(log n) time complexity.",
              "difficulty": "medium",
              "topic": "searching"
            },
            {
              "id": "q91",
              "type": "fillInBlank",
              "question": "Binary search compares the target with the _____ element to decide which half to search.",
              "acceptedAnswers": ["middle", "Middle", "MIDDLE", "middle-element", "Middle-Element", "MIDDLE-ELEMENT", "middle-of-array", "Middle-Of-Array", "MIDDLE-OF-ARRAY"],
              "explanation": "Binary search finds the middle element and compares it with the target to eliminate half the array.",
              "difficulty": "easy",
              "topic": "searching"
            }
          ]
        },
        {
          "id": "advanced-binary-search",
          "title": "Binary Search Variants",
          "description": "Lower bound, upper bound, and search space applications",
          "xpReward": 85,
          "questions": [
            {
              "id": "q91a",
              "type": "mcq",
              "question": "What does lower_bound function find in a sorted array?",
              "options": ["The smallest element", "First element >= target", "Last element < target", "Any occurrence of target"],
              "correctAnswer": "First element >= target",
              "explanation": "Lower bound finds the first position where the target could be inserted while maintaining sorted order.",
              "difficulty": "medium",
              "topic": "searching"
            },
            {
              "id": "q91b",
              "type": "fillInBlank",
              "question": "Upper bound finds the first element _____ than the target value.",
              "acceptedAnswers": ["greater", "Greater", "GREATER", "greater-than-target", "Greater-Than-Target", "GREATER-THAN-TARGET", "greater-than-target-value", "Greater-Than-Target-Value", "GREATER-THAN-TARGET-VALUE"],
              "explanation": "Upper bound returns an iterator to the first element that is greater than the search value.",
              "difficulty": "medium",
              "topic": "searching"
            },
            {
              "id": "q91c",
              "type": "mcq",
              "question": "Binary search can be applied to problems where:",
              "options": ["Data is always sorted", "Search space is monotonic", "There are duplicates", "Array is circular"],
              "correctAnswer": "Search space is monotonic",
              "explanation": "Binary search works on any monotonic function, not just sorted arrays - the key is the property that splits the search space.",
              "difficulty": "hard",
              "topic": "searching"
            },
            {
              "id": "q91d",
              "type": "mcq",
              "question": "Which problem can be solved using binary search on the answer?",
              "options": ["Finding maximum in array", "Square root calculation", "Array sorting", "Graph traversal"],
              "correctAnswer": "Square root calculation",
              "explanation": "Finding square root can use binary search by searching for the answer in the range [0, x] where x*x ≤ target.",
              "difficulty": "hard",
              "topic": "searching"
            }
          ]
        },
        {
          "id": "hash-based-searching",
          "title": "Hash-Based Search",
          "description": "Hash tables and collision resolution for fast lookups",
          "xpReward": 80,
          "questions": [
            {
              "id": "q92a",
              "type": "mcq",
              "question": "What is the average time complexity of search in a well-designed hash table?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
              "correctAnswer": "O(1)",
              "explanation": "Hash tables provide O(1) average case search time through direct indexing using hash functions.",
              "difficulty": "easy",
              "topic": "searching"
            },
            {
              "id": "q92b",
              "type": "fillInBlank",
              "question": "When multiple keys hash to the same location, this is called a _____.",
              "acceptedAnswers": ["collision", "Collision", "COLLISION", "hash-collision", "Hash-Collision", "HASH-COLLISION", "hash-collisions", "Hash-Collisions", "HASH-COLLISIONS"],
              "explanation": "Hash collisions occur when different keys produce the same hash value, requiring resolution strategies.",
              "difficulty": "easy",
              "topic": "searching"
            },
            {
              "id": "q92c",
              "type": "mcq",
              "question": "Which collision resolution technique uses a secondary hash function?",
              "options": ["Chaining", "Linear probing", "Double hashing", "Quadratic probing"],
              "correctAnswer": "Double hashing",
              "explanation": "Double hashing uses a second hash function to determine the step size for probing when a collision occurs.",
              "difficulty": "medium",
              "topic": "searching"
            },
            {
              "id": "q92d",
              "type": "mcq",
              "question": "What is the main disadvantage of open addressing compared to chaining?",
              "options": ["Higher memory usage", "Clustering problems", "Complex implementation", "Poor cache performance"],
              "correctAnswer": "Clustering problems",
              "explanation": "Open addressing can suffer from clustering where consecutive occupied slots make future insertions slower.",
              "difficulty": "hard",
              "topic": "searching"
            }
          ]
        },
        {
          "id": "string-searching",
          "title": "String Search Algorithms",
          "description": "Pattern matching and substring search techniques",
          "xpReward": 90,
          "questions": [
            {
              "id": "q93a",
              "type": "mcq",
              "question": "What is the time complexity of the naive string matching algorithm?",
              "options": ["O(n)", "O(m)", "O(n*m)", "O(n+m)"],
              "correctAnswer": "O(n*m)",
              "explanation": "Naive string matching compares the pattern at each position in the text, leading to O(n*m) worst-case time.",
              "difficulty": "medium",
              "topic": "searching"
            },
            {
              "id": "q93b",
              "type": "fillInBlank",
              "question": "The KMP algorithm uses a _____ function to avoid redundant comparisons during pattern matching.",
              "acceptedAnswers": ["failure", "Failure", "FAILURE", "failure-function", "Failure-Function", "FAILURE-FUNCTION", "failure-function-for-pattern-matching", "Failure-Function-For-Pattern-Matching", "FAILURE-FUNCTION-FOR-PATTERN-MATCHING"],
              "explanation": "KMP preprocessing computes a failure function that determines how far to shift the pattern on mismatches.",
              "difficulty": "hard",
              "topic": "searching"
            },
            {
              "id": "q93c",
              "type": "mcq",
              "question": "Which string searching algorithm has O(n+m) time complexity in the worst case?",
              "options": ["Naive algorithm", "KMP algorithm", "Boyer-Moore", "Rabin-Karp"],
              "correctAnswer": "KMP algorithm",
              "explanation": "KMP (Knuth-Morris-Pratt) guarantees O(n+m) time by never backtracking in the text.",
              "difficulty": "medium",
              "topic": "searching"
            },
            {
              "id": "q93d",
              "type": "mcq",
              "question": "What technique does the Boyer-Moore algorithm use to improve average-case performance?",
              "options": ["Preprocessing the text", "Comparing from right to left", "Using multiple hash functions", "Building suffix trees"],
              "correctAnswer": "Comparing from right to left",
              "explanation": "Boyer-Moore compares the pattern from right to left and uses good suffix and bad character heuristics to skip positions.",
              "difficulty": "hard",
              "topic": "searching"
            }
          ]
        },
        {
          "id": "advanced-search-structures",
          "title": "Advanced Search Structures",
          "description": "Tries, suffix trees, and specialized search data structures",
          "xpReward": 95,
          "questions": [
            {
              "id": "q94a",
              "type": "mcq",
              "question": "What is the primary advantage of a trie over a hash table for string storage?",
              "options": ["Better memory usage", "Prefix-based operations", "Faster individual lookups", "Simpler implementation"],
              "correctAnswer": "Prefix-based operations",
              "explanation": "Tries excel at prefix-based operations like autocomplete and longest common prefix, which are difficult with hash tables.",
              "difficulty": "medium",
              "topic": "searching"
            },
            {
              "id": "q94b",
              "type": "fillInBlank",
              "question": "A _____ tree contains all suffixes of a string and enables linear-time substring search.",
              "acceptedAnswers": ["suffix", "Suffix", "SUFFIX", "suffix-tree", "Suffix-Tree", "SUFFIX-TREE", "suffix-tree-for-substring-search", "Suffix-Tree-For-Substring-Search", "SUFFIX-TREE-FOR-SUBSTRING-SEARCH"],
              "explanation": "Suffix trees store all suffixes of a string in a compressed trie, enabling fast pattern matching queries.",
              "difficulty": "hard",
              "topic": "searching"
            },
            {
              "id": "q94c",
              "type": "mcq",
              "question": "What is the space complexity of a standard trie storing n strings with total length m?",
              "options": ["O(n)", "O(m)", "O(n*m)", "O(m²)"],
              "correctAnswer": "O(m)",
              "explanation": "A trie uses O(m) space where m is the total length of all stored strings, as each character is stored once per path.",
              "difficulty": "hard",
              "topic": "searching"
            },
            {
              "id": "q94d",
              "type": "mcq",
              "question": "Which data structure would be most efficient for range queries on a 2D grid?",
              "options": ["Hash table", "Binary search tree", "Quadtree", "Linked list"],
              "correctAnswer": "Quadtree",
              "explanation": "Quadtrees recursively partition 2D space into quadrants, making them efficient for spatial range queries.",
              "difficulty": "hard",
              "topic": "searching"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-15",
      "title": "Big O Notation",
      "description": "Analyzing algorithm efficiency and complexity",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "time-complexity",
          "title": "Time Complexity",
          "description": "Understanding how algorithms scale with input size",
          "xpReward": 70,
          "questions": [
            {
              "id": "q92",
              "type": "mcq",
              "question": "What does Big O notation describe?",
              "options": ["Best case performance", "Average case performance", "Worst case performance", "Space usage only"],
              "correctAnswer": "Worst case performance",
              "explanation": "Big O notation describes the upper bound or worst-case time complexity of an algorithm.",
              "difficulty": "medium",
              "topic": "complexity"
            },
            {
              "id": "q93",
              "type": "mcq",
              "question": "What is the time complexity of accessing an element in an array by index?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
              "correctAnswer": "O(1)",
              "explanation": "Array access by index is constant time O(1) because arrays store elements in contiguous memory locations with direct address calculation.",
              "difficulty": "medium",
              "topic": "complexity"
            },
            {
              "id": "q94",
              "type": "mcq",
              "question": "Which time complexity is better: O(n) or O(log n)?",
              "options": ["O(n)", "O(log n)", "They're the same", "Depends on input"],
              "correctAnswer": "O(log n)",
              "explanation": "O(log n) grows much slower than O(n), making it more efficient for large inputs.",
              "difficulty": "medium",
              "topic": "complexity"
            }
          ]
        },
        {
          "id": "space-complexity",
          "title": "Space Complexity",
          "description": "Analyzing memory usage of algorithms",
          "xpReward": 60,
          "questions": [
            {
              "id": "q95",
              "type": "mcq",
              "question": "What does space complexity measure?",
              "options": ["Execution time", "Memory usage", "Code length", "CPU cycles"],
              "correctAnswer": "Memory usage",
              "explanation": "Space complexity measures how much additional memory an algorithm uses relative to input size.",
              "difficulty": "easy",
              "topic": "complexity"
            },
            {
              "id": "q96",
              "type": "fillInBlank",
              "question": "An algorithm that uses a fixed amount of extra memory has _____ space complexity.",
              "acceptedAnswers": ["O(1)", "O(1)", "O(1)", "constant-space", "Constant-Space", "CONSTANT-SPACE", "constant-space-complexity", "Constant-Space-Complexity", "CONSTANT-SPACE-COMPLEXITY"],
              "explanation": "Constant space O(1) means the algorithm uses the same amount of extra memory regardless of input size.",
              "difficulty": "medium",
              "topic": "complexity"
            }
          ]
        },
        {
          "id": "common-complexities",
          "title": "Common Time Complexities",
          "description": "Recognizing and comparing different complexity classes",
          "xpReward": 75,
          "questions": [
            {
              "id": "q97a",
              "type": "mcq",
              "question": "Which complexity is typical for divide-and-conquer algorithms like merge sort?",
              "options": ["O(n)", "O(n log n)", "O(n²)", "O(2ⁿ)"],
              "correctAnswer": "O(n log n)",
              "explanation": "Divide-and-conquer algorithms that split the problem in half typically have O(n log n) complexity.",
              "difficulty": "medium",
              "topic": "big_o"
            },
            {
              "id": "q97b",
              "type": "fillInBlank",
              "question": "Bubble sort has _____ time complexity in the worst case.",
              "acceptedAnswers": ["O(n²)", "O(n²)", "O(N²)", "n-squared-time-complexity-for-bubble-sort", "N-Squared-Time-Complexity-For-Bubble-Sort", "N-SQUARED-TIME-COMPLEXITY-FOR-BUBBLE-SORT", "n-squared-time-complexity-for-bubble-sort-in-worst-case", "N-Squared-Time-Complexity-For-Bubble-Sort-In-Worst-Case", "N-SQUARED-TIME-COMPLEXITY-FOR-BUBBLE-SORT-IN-WORST-CASE"],
              "explanation": "Bubble sort compares each element with every other element, resulting in quadratic time complexity.",
              "difficulty": "medium",
              "topic": "big_o"
            },
            {
              "id": "q97c",
              "type": "mcq",
              "question": "Which complexity grows fastest?",
              "options": ["O(n²)", "O(n log n)", "O(2ⁿ)", "O(n³)"],
              "correctAnswer": "O(2ⁿ)",
              "explanation": "Exponential complexity O(2ⁿ) grows much faster than polynomial complexities like O(n³).",
              "difficulty": "medium",
              "topic": "big_o"
            },
            {
              "id": "q97d",
              "type": "mcq",
              "question": "Binary search on a sorted array has which time complexity?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
              "correctAnswer": "O(log n)",
              "explanation": "Binary search eliminates half the search space at each step, resulting in logarithmic time complexity.",
              "difficulty": "easy",
              "topic": "big_o"
            }
          ]
        },
        {
          "id": "amortized-analysis",
          "title": "Amortized Analysis",
          "description": "Average case analysis over sequences of operations",
          "xpReward": 85,
          "questions": [
            {
              "id": "q98a",
              "type": "mcq",
              "question": "What does amortized analysis study?",
              "options": ["Single operation worst-case", "Average time over sequence of operations", "Memory usage patterns", "Algorithm correctness"],
              "correctAnswer": "Average time over sequence of operations",
              "explanation": "Amortized analysis considers the average performance per operation over a worst-case sequence of operations.",
              "difficulty": "medium",
              "topic": "big_o"
            },
            {
              "id": "q98b",
              "type": "fillInBlank",
              "question": "Dynamic array resizing has _____ amortized time per insertion even though individual operations may be expensive.",
              "acceptedAnswers": ["O(1)", "O(1)", "O(1)", "amortized-time-per-insertion", "Amortized-Time-Per-Insertion", "AMORTIZED-TIME-PER-INSERTION", "amortized-time-for-insertion", "Amortized-Time-For-Insertion", "AMORTIZED-TIME-FOR-INSERTION"],
              "explanation": "Although resizing takes O(n) time, it happens infrequently enough that the amortized cost per insertion is O(1).",
              "difficulty": "hard",
              "topic": "big_o"
            },
            {
              "id": "q98c",
              "type": "mcq",
              "question": "Which method is used to prove amortized bounds?",
              "options": ["Mathematical induction", "Potential method", "Substitution method", "Master theorem"],
              "correctAnswer": "Potential method",
              "explanation": "The potential method assigns a potential function to data structure states to analyze amortized costs.",
              "difficulty": "hard",
              "topic": "big_o"
            },
            {
              "id": "q98d",
              "type": "mcq",
              "question": "In the accounting method for amortized analysis, what represents 'credit'?",
              "options": ["Time saved", "Extra work done", "Memory allocated", "Operations completed"],
              "correctAnswer": "Extra work done",
              "explanation": "The accounting method assigns credits for extra work that can be used to pay for expensive operations later.",
              "difficulty": "hard",
              "topic": "big_o"
            }
          ]
        },
        {
          "id": "algorithm-analysis",
          "title": "Practical Algorithm Analysis",
          "description": "Analyzing real algorithms and their complexities",
          "xpReward": 80,
          "questions": [
            {
              "id": "q99a",
              "type": "mcq",
              "question": "What is the time complexity of finding the maximum element in an unsorted array?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
              "correctAnswer": "O(n)",
              "explanation": "Finding the maximum requires examining every element at least once, giving linear time complexity.",
              "difficulty": "easy",
              "topic": "big_o"
            },
            {
              "id": "q99b",
              "type": "fillInBlank",
              "question": "Matrix multiplication using the naive algorithm has _____ time complexity.",
              "acceptedAnswers": ["O(n³)", "O(n³)", "O(N³)", "n-cubed-time-complexity-for-matrix-multiplication", "N-Cubed-Time-Complexity-For-Matrix-Multiplication", "N-CUBED-TIME-COMPLEXITY-FOR-MATRIX-MULTIPLICATION", "n-cubed-time-complexity-for-matrix-multiplication-using-naive-algorithm", "N-Cubed-Time-Complexity-For-Matrix-Multiplication-Using-Naive-Algorithm", "N-CUBED-TIME-COMPLEXITY-FOR-MATRIX-MULTIPLICATION-USING-NAIVE-ALGORITHM"],
              "explanation": "Naive matrix multiplication requires three nested loops, each running n times, resulting in cubic complexity.",
              "difficulty": "medium",
              "topic": "big_o"
            },
            {
              "id": "q99c",
              "type": "mcq",
              "question": "When analyzing nested loops, what should you do?",
              "options": ["Add the complexities", "Multiply the complexities", "Take the maximum", "Take the minimum"],
              "correctAnswer": "Multiply the complexities",
              "explanation": "Nested loops multiply their complexities since the inner loop runs completely for each iteration of the outer loop.",
              "difficulty": "medium",
              "topic": "big_o"
            },
            {
              "id": "q99d",
              "type": "mcq",
              "question": "Which factor affects time complexity analysis?",
              "options": ["Programming language", "Input size", "Computer speed", "Operating system"],
              "correctAnswer": "Input size",
              "explanation": "Time complexity analysis focuses on how performance scales with input size, independent of hardware or software environment.",
              "difficulty": "medium",
              "topic": "big_o"
            }
          ]
        },
        {
          "id": "complexity-theory",
          "title": "Complexity Theory Basics",
          "description": "P, NP, and computational complexity classes",
          "xpReward": 90,
          "questions": [
            {
              "id": "q100a",
              "type": "mcq",
              "question": "What characterizes the complexity class P?",
              "options": ["Problems solvable in polynomial time", "Problems with polynomial space", "Undecidable problems", "NP-complete problems"],
              "correctAnswer": "Problems solvable in polynomial time",
              "explanation": "Class P contains decision problems that can be solved by a deterministic algorithm in polynomial time.",
              "difficulty": "hard",
              "topic": "big_o"
            },
            {
              "id": "q100b",
              "type": "fillInBlank",
              "question": "Class _____ contains problems whose solutions can be verified in polynomial time.",
              "acceptedAnswers": ["NP", "NP", "NP", "np-problems", "NP-Problems", "NP-PROBLEMS", "np-complete", "NP-Complete", "NP-COMPLETE"],
              "explanation": "NP (Nondeterministic Polynomial time) problems have solutions that can be verified quickly, even if finding them is hard.",
              "difficulty": "hard",
              "topic": "big_o"
            },
            {
              "id": "q100c",
              "type": "mcq",
              "question": "What makes a problem NP-complete?",
              "options": ["It's in P", "It's in NP and NP-hard", "It's undecidable", "It requires exponential space"],
              "correctAnswer": "It's in NP and NP-hard",
              "explanation": "NP-complete problems are in NP (verifiable in polynomial time) and NP-hard (at least as hard as any NP problem).",
              "difficulty": "hard",
              "topic": "big_o"
            },
            {
              "id": "q100d",
              "type": "mcq",
              "question": "Which of these is a famous NP-complete problem?",
              "options": ["Sorting", "Binary search", "Traveling salesman problem", "Matrix multiplication"],
              "correctAnswer": "Traveling salesman problem",
              "explanation": "TSP is one of the classic NP-complete problems, where finding the optimal tour is computationally difficult.",
              "difficulty": "medium",
              "topic": "big_o"
            }
          ]
        }
      ]
    }
  ]
}