{
  "units": [
    {
      "id": "unit-1",
      "title": "Arrays",
      "description": "Master the fundamentals of arrays and string manipulation",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "arrays-basics",
          "title": "Basics",
          "description": "Understanding what arrays are and basic concepts",
          "xpReward": 50,
          "questions": [
            {
              "id": "q1",
              "type": "mcq",
              "question": "What is the key characteristic of how arrays store elements in memory?",
              "options": ["Elements are stored in random locations", "Elements are stored in contiguous memory locations", "Elements are stored in separate memory blocks", "Elements are stored in linked memory nodes"],
              "correctAnswer": "Elements are stored in contiguous memory locations",
              "explanation": "Arrays store elements in contiguous (adjacent) memory locations, which enables constant-time access by index and better cache performance.",
              "difficulty": "easy",
              "topic": "arrays"
            },
            {
              "id": "q2",
              "type": "mcq",
              "question": "What is the main advantage of arrays over linked lists?",
              "options": ["Dynamic size", "Faster insertion at beginning", "Random access in O(1) time", "Lower memory usage per element"],
              "correctAnswer": "Random access in O(1) time",
              "explanation": "Arrays provide O(1) random access to elements by index, while linked lists require O(n) traversal to reach a specific element.",
              "difficulty": "easy",
              "topic": "arrays"
            },
            {
              "id": "q3",
              "type": "mcq",
              "question": "What is the difference between static and dynamic arrays?",
              "options": ["Static arrays can change size, dynamic cannot", "Static arrays have fixed size, dynamic can grow/shrink", "Static arrays are faster", "There is no difference"],
              "correctAnswer": "Static arrays have fixed size, dynamic can grow/shrink",
              "explanation": "Static arrays have a fixed size determined at compile time, while dynamic arrays can resize during runtime as needed.",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q4",
              "type": "fillInBlank",
              "question": "In most programming languages, array indexing starts from _____.",
              "correctAnswer": "0",
              "explanation": "Most programming languages use 0-based indexing, where the first element is at index 0, second at index 1, and so on.",
              "difficulty": "easy",
              "topic": "arrays"
            },
            {
              "id": "q5",
              "type": "mcq",
              "question": "Why do arrays have better cache performance compared to linked lists?",
              "options": ["Arrays use less memory", "Arrays have contiguous memory layout", "Arrays are smaller", "Arrays use pointers"],
              "correctAnswer": "Arrays have contiguous memory layout",
              "explanation": "Arrays store elements in contiguous memory, which means accessing nearby elements benefits from CPU cache locality, making sequential access faster.",
              "difficulty": "medium",
              "topic": "arrays"
            }
          ]
        },
        {
          "id": "array-operations",
          "title": "Operations",
          "description": "Understanding time complexity of basic array operations",
          "xpReward": 60,
          "questions": [
            {
              "id": "q6",
              "type": "mcq",
              "question": "What is the time complexity of accessing an element in an array by index?",
              "options": ["O(1)", "O(n)", "O(log n)", "O(n²)"],
              "correctAnswer": "O(1)",
              "explanation": "Array access by index is constant time O(1) because arrays store elements in contiguous memory locations with direct address calculation.",
              "difficulty": "easy",
              "topic": "arrays"
            },
            {
              "id": "q7",
              "type": "mcq",
              "question": "What is the time complexity of inserting an element at the end of a dynamic array?",
              "options": ["O(1)", "O(n)", "O(log n)", "O(1) amortized"],
              "correctAnswer": "O(1) amortized",
              "explanation": "Insertion at the end is O(1) amortized because occasional resizing operations (O(n)) are spread across many insertions.",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q8",
              "type": "mcq",
              "question": "Why is inserting at the beginning of an array O(n)?",
              "options": ["Need to allocate new memory", "Need to shift all existing elements", "Need to search for position", "Need to check bounds"],
              "correctAnswer": "Need to shift all existing elements",
              "explanation": "Inserting at the beginning requires shifting all existing elements one position to the right, making it O(n) operation.",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q9",
              "type": "fillInBlank",
              "question": "The time complexity of deleting an element from the end of an array is _____.",
              "correctAnswer": "O(1)",
              "explanation": "Deleting from the end only requires removing the last element without shifting others, making it O(1).",
              "difficulty": "easy",
              "topic": "arrays"
            },
            {
              "id": "q10",
              "type": "mcq",
              "question": "What is the time complexity of linear search in an unsorted array?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
              "correctAnswer": "O(n)",
              "explanation": "Linear search may need to check every element in the worst case, making it O(n).",
              "difficulty": "easy",
              "topic": "arrays"
            },
            {
              "id": "q11",
              "type": "mcq",
              "question": "What is the time complexity of binary search in a sorted array?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
              "correctAnswer": "O(log n)",
              "explanation": "Binary search repeatedly divides the search space in half, resulting in O(log n) time complexity.",
              "difficulty": "medium",
              "topic": "arrays"
            }
          ]
        },
        {
          "id": "array-properties",
          "title": "Properties",
          "description": "Essential array properties and common operations",
          "xpReward": 55,
          "questions": [
            {
              "id": "q12",
              "type": "fillInBlank",
              "question": "To find the number of elements in an array, you typically use the _____ property.",
              "correctAnswer": "length",
              "explanation": "The 'length' property returns the number of elements in an array and is available in most programming languages.",
              "difficulty": "easy",
              "topic": "arrays"
            },
            {
              "id": "q13",
              "type": "mcq",
              "question": "What happens when you try to access an array element beyond its bounds?",
              "options": ["Returns null", "Throws an exception or undefined behavior", "Returns 0", "Automatically extends the array"],
              "correctAnswer": "Throws an exception or undefined behavior",
              "explanation": "Accessing out-of-bounds indices typically results in an exception (Java), undefined behavior (C/C++), or undefined (JavaScript).",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q14",
              "type": "mcq",
              "question": "When initializing an array with zeros, what is typically the most efficient approach?",
              "options": ["Loop through and set each element", "Use built-in initialization methods", "Copy from another zero array", "Use recursion"],
              "correctAnswer": "Use built-in initialization methods",
              "explanation": "Most languages provide efficient built-in methods for array initialization (like Arrays.fill() or calloc()) that are optimized at the system level.",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q15",
              "type": "mcq", 
              "question": "What is the difference between shallow and deep copying of arrays?",
              "options": ["Shallow copies references, deep copies values", "Shallow is faster, deep is slower", "Shallow copies first half, deep copies all", "No difference"],
              "correctAnswer": "Shallow copies references, deep copies values",
              "explanation": "Shallow copy creates a new array but copies references to objects, while deep copy creates new objects as well.",
              "difficulty": "hard",
              "topic": "arrays"
            },
            {
              "id": "q16",
              "type": "fillInBlank",
              "question": "When comparing two arrays for equality, you typically need to compare both their _____ and corresponding elements.",
              "correctAnswer": "length",
              "explanation": "Array equality requires checking that arrays have the same length and that all corresponding elements are equal.",
              "difficulty": "medium",
              "topic": "arrays"
            }
          ]
        },
        {
          "id": "array-memory",
          "title": "Memory",
          "description": "Understanding how arrays manage memory and resizing",
          "xpReward": 65,
          "questions": [
            {
              "id": "q17",
              "type": "mcq",
              "question": "What is a key limitation of fixed-size arrays?",
              "options": ["Slow access time", "Cannot change size after creation", "Use more memory", "Poor cache performance"],
              "correctAnswer": "Cannot change size after creation",
              "explanation": "Fixed-size arrays have their size determined at creation time and cannot be changed, unlike dynamic arrays.",
              "difficulty": "easy",
              "topic": "arrays"
            },
            {
              "id": "q18",
              "type": "fillInBlank",
              "question": "Dynamic arrays like ArrayList in Java or vector in C++ are also called _____ arrays.",
              "correctAnswer": "resizable",
              "explanation": "Dynamic/resizable arrays can grow and shrink in size during runtime, unlike fixed-size arrays.",
              "difficulty": "easy",
              "topic": "arrays"
            },
            {
              "id": "q19",
              "type": "mcq",
              "question": "When a dynamic array needs to grow beyond its current capacity, what typically happens?",
              "options": ["It extends in place", "A new larger array is allocated and elements are copied", "It throws an error", "It compresses existing elements"],
              "correctAnswer": "A new larger array is allocated and elements are copied",
              "explanation": "Dynamic arrays typically allocate a new, larger array and copy all existing elements when they need to grow beyond capacity.",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q20",
              "type": "mcq",
              "question": "What is a common resizing strategy for dynamic arrays when they need to grow?",
              "options": ["Add one element at a time", "Double the current size", "Add 10 elements", "Triple the size"],
              "correctAnswer": "Double the current size",
              "explanation": "Doubling the size is a common strategy that provides good amortized performance - it balances memory usage with the frequency of expensive resize operations.",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q21",
              "type": "fillInBlank",
              "question": "The process of creating a new larger array and copying elements during resizing is called _____.",
              "correctAnswer": "reallocation",
              "explanation": "Reallocation is the process of allocating new memory space and copying data when an array needs to resize.",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q22",
              "type": "mcq",
              "question": "Why don't dynamic arrays shrink immediately when elements are removed?",
              "options": ["It's impossible to shrink", "To avoid frequent reallocation", "To maintain order", "To save computation time"],
              "correctAnswer": "To avoid frequent reallocation",
              "explanation": "Dynamic arrays typically don't shrink immediately to avoid the overhead of frequent reallocations when elements are added and removed repeatedly.",
              "difficulty": "hard",
              "topic": "arrays"
            }
          ]
        },
        {
          "id": "array-algorithms",
          "title": "Algorithms", 
          "description": "Common algorithms using arrays",
          "xpReward": 75,
          "questions": [
            {
              "id": "q23",
              "type": "mcq",
              "question": "What is the optimal time complexity for finding two numbers in a sorted array that sum to a target?",
              "options": ["O(n²)", "O(n log n)", "O(n)", "O(log n)"],
              "correctAnswer": "O(n)",
              "explanation": "Using two pointers (one at start, one at end) on a sorted array gives O(n) time complexity.",
              "difficulty": "medium",
              "topic": "arrays"
            },
            {
              "id": "q24",
              "type": "fillInBlank", 
              "question": "The technique that uses two pointers moving towards each other is called the _____ pointer technique.",
              "correctAnswer": "two",
              "explanation": "Two pointer technique is commonly used for array problems where you need to find pairs or subarrays.",
              "difficulty": "medium",
              "topic": "arrays"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-2", 
      "title": "Hash Maps",
      "description": "Master key-value data structures and hashing techniques",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "hashmap-fundamentals",
          "title": "Basics",
          "description": "Understanding hash tables and key-value storage",
          "xpReward": 60,
          "questions": [
            {
              "id": "q25",
              "type": "mcq",
              "question": "What is the primary purpose of a hash map (dictionary)?",
              "options": ["Store elements in order", "Map keys to values for fast lookup", "Sort data automatically", "Compress data"],
              "correctAnswer": "Map keys to values for fast lookup",
              "explanation": "Hash maps are designed to store key-value pairs and provide fast O(1) average-case lookup, insertion, and deletion operations.",
              "difficulty": "easy",
              "topic": "hashmap"
            },
            {
              "id": "q26",
              "type": "fillInBlank",
              "question": "A hash map uses a _____ function to convert keys into array indices.",
              "correctAnswer": "hash",
              "explanation": "A hash function takes a key and converts it into an array index where the corresponding value will be stored.",
              "difficulty": "easy",
              "topic": "hashmap"
            },
            {
              "id": "q27",
              "type": "mcq",
              "question": "What is the average time complexity for lookup in a hash map?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
              "correctAnswer": "O(1)",
              "explanation": "Hash maps provide O(1) average-case time complexity for lookup operations due to direct index access via hashing.",
              "difficulty": "easy",
              "topic": "hashmap"
            },
            {
              "id": "q28",
              "type": "mcq",
              "question": "What happens when two different keys produce the same hash value?",
              "options": ["One key overwrites the other", "A collision occurs", "The hash map breaks", "Keys are merged"],
              "correctAnswer": "A collision occurs",
              "explanation": "When different keys hash to the same index, it's called a collision. Hash maps need strategies to handle collisions.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q29",
              "type": "fillInBlank",
              "question": "Hash maps are also known as hash tables, dictionaries, or _____ arrays.",
              "correctAnswer": "associative",
              "explanation": "Associative arrays associate keys with values, allowing you to look up values using their corresponding keys.",
              "difficulty": "easy",
              "topic": "hashmap"
            }
          ]
        },
        {
          "id": "hash-functions",
          "title": "Functions",
          "description": "Understanding how hash functions work and their characteristics",
          "xpReward": 65,
          "questions": [
            {
              "id": "q30",
              "type": "mcq",
              "question": "What is a key property that a good hash function should have?",
              "options": ["Always return the same value", "Distribute keys uniformly across buckets", "Only work with strings", "Be reversible"],
              "correctAnswer": "Distribute keys uniformly across buckets",
              "explanation": "A good hash function should distribute keys uniformly to minimize collisions and ensure balanced performance.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q31",
              "type": "fillInBlank",
              "question": "A hash function should be _____, meaning the same key always produces the same hash value.",
              "correctAnswer": "deterministic",
              "explanation": "Deterministic behavior ensures that looking up the same key will always check the same location in the hash table.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q32",
              "type": "mcq",
              "question": "What is the 'avalanche effect' in hash functions?",
              "options": ["Hash values increase exponentially", "Small input changes cause large output changes", "Function becomes slower", "Memory usage doubles"],
              "correctAnswer": "Small input changes cause large output changes",
              "explanation": "The avalanche effect means small changes to input should produce significantly different hash values, improving distribution.",
              "difficulty": "hard",
              "topic": "hashmap"
            },
            {
              "id": "q33",
              "type": "mcq",
              "question": "Why should hash functions be fast to compute?",
              "options": ["To save memory", "To maintain O(1) performance", "To reduce collisions", "To improve security"],
              "correctAnswer": "To maintain O(1) performance",
              "explanation": "If hash function computation is slow, it would degrade the overall O(1) performance promise of hash maps.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q34",
              "type": "fillInBlank",
              "question": "The result of applying a hash function to a key is called a hash _____ or hash code.",
              "correctAnswer": "value",
              "explanation": "The hash value or hash code is the numerical result that determines where to store/find the key-value pair.",
              "difficulty": "easy",
              "topic": "hashmap"
            }
          ]
        },
        {
          "id": "collision-handling",
          "title": "Collisions",
          "description": "Methods for handling hash collisions",
          "xpReward": 70,
          "questions": [
            {
              "id": "q35",
              "type": "mcq",
              "question": "What is chaining as a collision resolution method?",
              "options": ["Linking hash functions together", "Storing collided items in linked lists", "Creating hash chains", "Connecting multiple hash maps"],
              "correctAnswer": "Storing collided items in linked lists",
              "explanation": "Chaining handles collisions by maintaining a linked list at each bucket to store all items that hash to the same index.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q36",
              "type": "mcq",
              "question": "What is open addressing in hash tables?",
              "options": ["Tables that can be accessed by anyone", "Finding alternative locations for collided items", "Hash tables without collision handling", "Dynamic resizing of tables"],
              "correctAnswer": "Finding alternative locations for collided items",
              "explanation": "Open addressing resolves collisions by probing for alternative empty slots in the hash table when collisions occur.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q37",
              "type": "fillInBlank",
              "question": "Linear probing is a type of _____ addressing where we check the next sequential slot.",
              "correctAnswer": "open",
              "explanation": "Linear probing is an open addressing technique that checks slots sequentially (i, i+1, i+2, ...) to find an empty position.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q38",
              "type": "mcq",
              "question": "What is a disadvantage of linear probing?",
              "options": ["Uses too much memory", "Creates clustering of elements", "Too slow for large datasets", "Cannot handle string keys"],
              "correctAnswer": "Creates clustering of elements",
              "explanation": "Linear probing can create clusters of consecutive occupied slots, leading to longer probe sequences and degraded performance.",
              "difficulty": "hard",
              "topic": "hashmap"
            },
            {
              "id": "q39",
              "type": "mcq",
              "question": "What is quadratic probing?",
              "options": ["Probing with quadratic hash functions", "Checking slots at quadratic intervals (i²)", "Using four probes maximum", "Squaring the key before hashing"],
              "correctAnswer": "Checking slots at quadratic intervals (i²)",
              "explanation": "Quadratic probing checks slots at quadratic distances (i, i+1², i+2², i+3², ...) to reduce clustering compared to linear probing.",
              "difficulty": "hard",
              "topic": "hashmap"
            }
          ]
        },
        {
          "id": "hashmap-operations",
          "title": "Operations",
          "description": "Core operations and their performance characteristics",
          "xpReward": 55,
          "questions": [
            {
              "id": "q40",
              "type": "mcq",
              "question": "What is the worst-case time complexity for hash map operations?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
              "correctAnswer": "O(n)",
              "explanation": "In the worst case (all keys hash to same bucket), hash map operations degrade to O(n) when using chaining or when the table is full with open addressing.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q41",
              "type": "fillInBlank",
              "question": "The _____ factor is the ratio of the number of stored elements to the size of the hash table.",
              "correctAnswer": "load",
              "explanation": "Load factor = (number of elements) / (table size). It's used to determine when to resize the hash table.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q42",
              "type": "mcq",
              "question": "When should a hash map typically be resized?",
              "options": ["When it's completely full", "When load factor exceeds a threshold (e.g., 0.75)", "Every 100 insertions", "Never"],
              "correctAnswer": "When load factor exceeds a threshold (e.g., 0.75)",
              "explanation": "Hash maps typically resize when load factor exceeds 0.75 to maintain good performance and minimize collisions.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q43",
              "type": "mcq",
              "question": "What happens during hash map resizing?",
              "options": ["Only the table size changes", "All elements are rehashed and moved", "Old elements are deleted", "Table is compressed"],
              "correctAnswer": "All elements are rehashed and moved",
              "explanation": "During resizing, a new larger table is created and all existing elements are rehashed and inserted into new positions.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q44",
              "type": "fillInBlank",
              "question": "Hash map deletion in open addressing often uses _____ deletion to avoid breaking probe sequences.",
              "correctAnswer": "lazy",
              "explanation": "Lazy deletion marks slots as 'deleted' rather than truly empty to maintain probe sequences for other elements.",
              "difficulty": "hard",
              "topic": "hashmap"
            }
          ]
        },
        {
          "id": "hashmap-applications",
          "title": "Applications",
          "description": "Real-world applications and problem-solving with hash maps",
          "xpReward": 60,
          "questions": [
            {
              "id": "q45",
              "type": "mcq",
              "question": "Which problem is best solved using a hash map?",
              "options": ["Finding the maximum element", "Checking if array contains duplicates", "Sorting an array", "Finding array length"],
              "correctAnswer": "Checking if array contains duplicates",
              "explanation": "Hash maps excel at membership testing and duplicate detection with O(1) average lookup time.",
              "difficulty": "easy",
              "topic": "hashmap"
            },
            {
              "id": "q46",
              "type": "fillInBlank",
              "question": "To count the frequency of elements in an array, you would use a hash map where keys are elements and values are their _____.",
              "correctAnswer": "counts",
              "explanation": "Frequency counting maps each unique element to how many times it appears in the dataset.",
              "difficulty": "easy", 
              "topic": "hashmap"
            },
            {
              "id": "q47",
              "type": "mcq",
              "question": "What is a common use case for hash maps in caching?",
              "options": ["Storing cache in order", "Fast key-based cache lookup", "Compressing cached data", "Sorting cache entries"],
              "correctAnswer": "Fast key-based cache lookup",
              "explanation": "Hash maps provide O(1) lookup time, making them ideal for caching where fast retrieval by key is essential.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q48",
              "type": "mcq",
              "question": "How would you find the first non-repeating character in a string using hash maps?",
              "options": ["Count frequency, then find first with count=1", "Sort string first", "Use two hash maps", "Check each character individually"],
              "correctAnswer": "Count frequency, then find first with count=1",
              "explanation": "First pass counts frequency of each character, second pass finds the first character with frequency 1.",
              "difficulty": "medium",
              "topic": "hashmap"
            },
            {
              "id": "q49",
              "type": "fillInBlank",
              "question": "In database systems, hash maps are commonly used to implement _____ joins for fast lookups.",
              "correctAnswer": "hash",
              "explanation": "Hash joins use hash maps to build lookup tables for one relation, then probe with the other relation for matches.",
              "difficulty": "hard",
              "topic": "hashmap"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-3",
      "title": "Stacks",
      "description": "LIFO data structure for efficient operations",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "stack-basics",
          "title": "Stack Basics",
          "description": "Understanding LIFO principle and basic operations",
          "xpReward": 55,
          "questions": [
            {
              "id": "q50",
              "type": "mcq",
              "question": "What does LIFO stand for in the context of stacks?",
              "options": ["Last In First Out", "Last In Final Out", "Late In Fast Out", "Large In Full Out"],
              "correctAnswer": "Last In First Out",
              "explanation": "LIFO means the last element added to the stack is the first one to be removed.",
              "difficulty": "easy",
              "topic": "stack"
            },
            {
              "id": "q51",
              "type": "fillInBlank",
              "question": "The operation to add an element to the top of a stack is called _____.",
              "correctAnswer": "push",
              "explanation": "Push operation adds an element to the top of the stack.",
              "difficulty": "easy",
              "topic": "stack"
            },
            {
              "id": "q52",
              "type": "mcq",
              "question": "What happens when you try to pop from an empty stack?",
              "options": ["Returns null", "Stack underflow error", "Returns 0", "Creates new element"],
              "correctAnswer": "Stack underflow error",
              "explanation": "Attempting to pop from an empty stack results in a stack underflow error.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q52a",
              "type": "fillInBlank",
              "question": "The operation to remove and return the top element from a stack is called _____.",
              "correctAnswer": "pop",
              "explanation": "Pop operation removes and returns the element at the top of the stack.",
              "difficulty": "easy",
              "topic": "stack"
            },
            {
              "id": "q52b",
              "type": "mcq",
              "question": "What operation allows you to view the top element without removing it?",
              "options": ["push", "pop", "peek", "size"],
              "correctAnswer": "peek",
              "explanation": "Peek (or top) operation returns the top element without removing it from the stack.",
              "difficulty": "easy",
              "topic": "stack"
            },
            {
              "id": "q52c",
              "type": "mcq",
              "question": "What is the time complexity of push and pop operations on a stack?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
              "correctAnswer": "O(1)",
              "explanation": "Both push and pop operations on a stack are O(1) constant time as they only modify the top element.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q52d",
              "type": "fillInBlank",
              "question": "When a stack exceeds its maximum capacity, it results in a stack _____ error.",
              "correctAnswer": "overflow",
              "explanation": "Stack overflow occurs when trying to push elements beyond the stack's capacity limit.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q52e",
              "type": "mcq",
              "question": "Which of these is NOT a typical stack operation?",
              "options": ["push", "pop", "peek", "sort"],
              "correctAnswer": "sort",
              "explanation": "Stacks don't have a built-in sort operation. Basic operations are push, pop, peek, isEmpty, and size.",
              "difficulty": "easy",
              "topic": "stack"
            }
          ]
        },
        {
          "id": "stack-applications",
          "title": "Stack Applications",
          "description": "Real-world uses of stacks",
          "xpReward": 65,
          "questions": [
            {
              "id": "q55",
              "type": "mcq",
              "question": "Which data structure is best for implementing function call management?",
              "options": ["Queue", "Stack", "Array", "Hash Map"],
              "correctAnswer": "Stack",
              "explanation": "Stacks are perfect for function calls due to LIFO - last called function returns first.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q55a",
              "type": "mcq",
              "question": "What is a call stack used for in programming?",
              "options": ["Storing variables", "Managing function calls and returns", "Sorting data", "Memory allocation"],
              "correctAnswer": "Managing function calls and returns",
              "explanation": "The call stack tracks function calls, local variables, and return addresses using LIFO principle.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q55b",
              "type": "fillInBlank",
              "question": "Stacks are commonly used to check for balanced _____ in expressions.",
              "correctAnswer": "parentheses",
              "explanation": "Stacks are ideal for checking balanced parentheses, brackets, and braces in mathematical expressions.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q55c",
              "type": "mcq",
              "question": "How would you use a stack to evaluate a postfix expression?",
              "options": ["Push operators, pop operands", "Push operands, pop when seeing operators", "Push everything in order", "Use two stacks"],
              "correctAnswer": "Push operands, pop when seeing operators",
              "explanation": "In postfix evaluation, push operands onto stack and when you see an operator, pop required operands, compute, and push result back.",
              "difficulty": "hard",
              "topic": "stack"
            },
            {
              "id": "q55d",
              "type": "mcq",
              "question": "Which application uses stack for tracking history?",
              "options": ["Database indexing", "Web browser back button", "File compression", "Network routing"],
              "correctAnswer": "Web browser back button",
              "explanation": "Browser back button uses a stack to track page history - last visited page is first to return to.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q55e",
              "type": "fillInBlank",
              "question": "Undo operations in text editors are typically implemented using a _____.",
              "correctAnswer": "stack",
              "explanation": "Undo functionality uses a stack to store actions in reverse order - last action is first to be undone.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q55f",
              "type": "mcq",
              "question": "In converting infix to postfix notation, what do you do when encountering an opening parenthesis?",
              "options": ["Ignore it", "Push it onto the stack", "Pop from stack", "Add to output"],
              "correctAnswer": "Push it onto the stack",
              "explanation": "Opening parentheses are pushed onto the stack to mark the beginning of a subexpression.",
              "difficulty": "hard",
              "topic": "stack"
            },
            {
              "id": "q55g",
              "type": "mcq",
              "question": "Which sorting algorithm uses a stack internally?",
              "options": ["Bubble sort", "Merge sort", "Quick sort (recursive)", "Selection sort"],
              "correctAnswer": "Quick sort (recursive)",
              "explanation": "Recursive quick sort uses the call stack to manage recursive calls for partitioning subarrays.",
              "difficulty": "hard",
              "topic": "stack"
            },
            {
              "id": "q55h",
              "type": "fillInBlank",
              "question": "Depth-First Search (DFS) traversal can be implemented using a _____ or recursion.",
              "correctAnswer": "stack",
              "explanation": "DFS uses a stack (explicit or implicit via recursion) to explore as deep as possible before backtracking.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "stack-problems",
              "title": "Stack Problems",
              "description": "Classic coding and interview problems involving stacks",
              "xpReward": 75,
              "questions": [
                {
                  "id": "q55n",
                  "type": "mcq",
                  "question": "Which stack-based approach is used to solve the Next Greater Element problem?",
                  "options": ["Use two stacks", "Use a monotonic stack", "Sort the array", "Use recursion"],
                  "correctAnswer": "Use a monotonic stack",
                  "explanation": "A monotonic stack helps efficiently find the next greater element for each item in a single pass.",
                  "difficulty": "hard",
                  "topic": "stack"
                },
                {
                  "id": "q55o",
                  "type": "mcq",
                  "question": "What is the main idea behind the Min Stack problem?",
                  "options": ["Track only the top element", "Track the minimum value at each push", "Sort the stack after each operation", "Use a queue"],
                  "correctAnswer": "Track the minimum value at each push",
                  "explanation": "A Min Stack keeps track of the minimum value at each push to allow O(1) retrieval of the minimum.",
                  "difficulty": "hard",
                  "topic": "stack"
                },
                {
                  "id": "q55p",
                  "type": "mcq",
                  "question": "Which stack-based algorithm is used to find the largest rectangle in a histogram?",
                  "options": ["Monotonic stack", "DFS", "BFS", "Heap"],
                  "correctAnswer": "Monotonic stack",
                  "explanation": "A monotonic stack is used to efficiently compute the largest rectangle in a histogram in O(n) time.",
                  "difficulty": "hard",
                  "topic": "stack"
                }
              ]
            },
            {
              "id": "stack-parsing",
              "title": "Stack in Parsing and Evaluation",
              "description": "Using stacks for parsing and evaluating expressions",
              "xpReward": 70,
              "questions": [
                {
                  "id": "q55q",
                  "type": "mcq",
                  "question": "Which notation is easiest to evaluate using a stack?",
                  "options": ["Infix", "Prefix", "Postfix (Reverse Polish Notation)", "All are equally easy"],
                  "correctAnswer": "Postfix (Reverse Polish Notation)",
                  "explanation": "Postfix expressions can be evaluated in a single left-to-right pass using a stack.",
                  "difficulty": "medium",
                  "topic": "stack"
                },
                {
                  "id": "q55r",
                  "type": "fillInBlank",
                  "question": "Stacks are used to check for balanced _____ in code and expressions.",
                  "correctAnswer": "parentheses",
                  "explanation": "Stacks are ideal for checking balanced parentheses, brackets, and braces in code and mathematical expressions.",
                  "difficulty": "easy",
                  "topic": "stack"
                },
                {
                  "id": "q55s",
                  "type": "mcq",
                  "question": "What is the main advantage of using a stack for parsing nested structures?",
                  "options": ["It sorts the input", "It allows tracking of open/close pairs", "It speeds up multiplication", "It reduces memory usage"],
                  "correctAnswer": "It allows tracking of open/close pairs",
                  "explanation": "Stacks help track open and close pairs (like parentheses) in nested structures, ensuring correct matching.",
                  "difficulty": "medium",
                  "topic": "stack"
                }
              ]
            },
            {
              "id": "stack-recursion",
              "title": "Stack and Recursion",
              "description": "Understanding the relationship between recursion and the call stack",
              "xpReward": 65,
              "questions": [
                {
                  "id": "q55t",
                  "type": "mcq",
                  "question": "What does each recursive function call create on the call stack?",
                  "options": ["A new thread", "A new stack frame", "A new variable", "A new process"],
                  "correctAnswer": "A new stack frame",
                  "explanation": "Each recursive call creates a new stack frame to store local variables and return address.",
                  "difficulty": "medium",
                  "topic": "stack"
                },
                {
                  "id": "q55u",
                  "type": "mcq",
                  "question": "What happens if recursion goes too deep without a base case?",
                  "options": ["Stack overflow", "Infinite loop", "Program runs faster", "Memory leak"],
                  "correctAnswer": "Stack overflow",
                  "explanation": "Without a base case, recursive calls keep adding stack frames until the stack limit is exceeded, causing a stack overflow.",
                  "difficulty": "medium",
                  "topic": "stack"
                },
                {
                  "id": "q55v",
                  "type": "fillInBlank",
                  "question": "The call stack stores local variables and the _____ address for each function call.",
                  "correctAnswer": "return",
                  "explanation": "The return address tells the program where to continue after a function call completes.",
                  "difficulty": "medium",
                  "topic": "stack"
                }
              ]
            },
            {
              "id": "stack-backtracking",
              "title": "Stack in Backtracking",
              "description": "How stacks are used in backtracking algorithms",
              "xpReward": 70,
              "questions": [
                {
                  "id": "q55w",
                  "type": "mcq",
                  "question": "Which data structure is most commonly used to implement backtracking?",
                  "options": ["Queue", "Stack", "Heap", "Array"],
                  "correctAnswer": "Stack",
                  "explanation": "Backtracking algorithms use a stack to keep track of choices and revert to previous states.",
                  "difficulty": "medium",
                  "topic": "stack"
                },
                {
                  "id": "q55x",
                  "type": "mcq",
                  "question": "In maze solving with backtracking, what does the stack store?",
                  "options": ["All possible paths", "Visited cells", "Current path positions", "Maze size"],
                  "correctAnswer": "Current path positions",
                  "explanation": "The stack stores the current path positions so you can backtrack when hitting a dead end.",
                  "difficulty": "medium",
                  "topic": "stack"
                },
                {
                  "id": "q55y",
                  "type": "fillInBlank",
                  "question": "In the N-Queens problem, the stack is used to keep track of the _____ of queens placed so far.",
                  "correctAnswer": "positions",
                  "explanation": "The stack tracks the positions of queens placed so you can backtrack and try new configurations.",
                  "difficulty": "hard",
                  "topic": "stack"
                }
              ]
            }
          ]
        },
        {
          "id": "stack-implementation",
          "title": "Implementation",
          "description": "Different ways to implement stacks and their trade-offs",
          "xpReward": 70,
          "questions": [
            {
              "id": "q55i",
              "type": "mcq",
              "question": "What is the most common way to implement a stack?",
              "options": ["Using arrays", "Using linked lists", "Using hash tables", "Using trees"],
              "correctAnswer": "Using arrays",
              "explanation": "Arrays are the most common implementation due to their simplicity and O(1) access to the top element.",
              "difficulty": "easy",
              "topic": "stack"
            },
            {
              "id": "q55j",
              "type": "mcq",
              "question": "What is an advantage of implementing a stack using a linked list?",
              "options": ["Faster access", "Dynamic size", "Less memory usage", "Better cache performance"],
              "correctAnswer": "Dynamic size",
              "explanation": "Linked list implementation allows the stack to grow and shrink dynamically without size limitations.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q55k",
              "type": "fillInBlank",
              "question": "In array-based stack implementation, the _____ variable keeps track of the top element's index.",
              "correctAnswer": "top",
              "explanation": "A 'top' pointer/index variable maintains the position of the current top element in the array.",
              "difficulty": "easy",
              "topic": "stack"
            },
            {
              "id": "q55l",
              "type": "mcq",
              "question": "What happens to the space complexity when implementing a stack with a linked list vs array?",
              "options": ["Linked list uses less space", "Array uses less space", "Both use same space", "Depends on implementation"],
              "correctAnswer": "Array uses less space",
              "explanation": "Arrays have less overhead per element, while linked lists need extra memory for storing pointers.",
              "difficulty": "medium",
              "topic": "stack"
            },
            {
              "id": "q55m",
              "type": "mcq",
              "question": "In a linked list implementation of stack, where should new elements be added?",
              "options": ["At the end", "At the beginning", "In the middle", "Anywhere"],
              "correctAnswer": "At the beginning",
              "explanation": "Adding at the beginning (head) of linked list gives O(1) push and pop operations for stack behavior.",
              "difficulty": "medium",
              "topic": "stack"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-4",
      "title": "Queues",
      "description": "FIFO data structure for efficient operations",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "queue-basics",
          "title": "Queue Basics",
          "description": "Understanding FIFO principle and queue operations",
          "xpReward": 60,
          "questions": [
            {
              "id": "q53",
              "type": "mcq",
              "question": "What does FIFO stand for in the context of queues?",
              "options": ["First In First Out", "Fast In Fast Out", "Final In First Out", "First In Final Out"],
              "correctAnswer": "First In First Out",
              "explanation": "FIFO means the first element added to the queue is the first one to be removed.",
              "difficulty": "easy",
              "topic": "queue"
            },
            {
              "id": "q54",
              "type": "fillInBlank",
              "question": "Adding an element to the rear of a queue is called _____ operation.",
              "correctAnswer": "enqueue",
              "explanation": "Enqueue operation adds an element to the rear/back of the queue.",
              "difficulty": "easy",
              "topic": "queue"
            },
            {
              "id": "q54a",
              "type": "fillInBlank",
              "question": "Removing an element from the front of a queue is called _____ operation.",
              "correctAnswer": "dequeue",
              "explanation": "Dequeue operation removes an element from the front of the queue.",
              "difficulty": "easy",
              "topic": "queue"
            }
          ]
        },
        {
          "id": "queue-applications",
          "title": "Queue Applications",
          "description": "Real-world uses of queues",
          "xpReward": 55,
          "questions": [
            {
              "id": "q54b",
              "type": "mcq",
              "question": "Which scenario best demonstrates queue usage?",
              "options": ["Function call management", "Print job scheduling", "Undo operations", "Expression evaluation"],
              "correctAnswer": "Print job scheduling",
              "explanation": "Print queues process jobs in FIFO order - first submitted, first printed.",
              "difficulty": "medium",
              "topic": "queue"
            },
            {
              "id": "q54c",
              "type": "mcq",
              "question": "What type of queue is used in breadth-first search?",
              "options": ["Priority queue", "Simple queue", "Circular queue", "Double-ended queue"],
              "correctAnswer": "Simple queue",
              "explanation": "BFS uses a simple FIFO queue to visit nodes level by level.",
              "difficulty": "medium",
              "topic": "queue"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-5",
      "title": "Trees",
      "description": "Hierarchical data structures and tree algorithms",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "binary-trees",
          "title": "Binary Trees",
          "description": "Understanding tree structure and terminology",
          "xpReward": 70,
          "questions": [
            {
              "id": "q56",
              "type": "fillInBlank",
              "question": "In a binary tree, each node can have at most _____ children.",
              "correctAnswer": "two",
              "explanation": "Binary trees are restricted to having at most two children per node: left and right.",
              "difficulty": "easy",
              "topic": "trees"
            },
            {
              "id": "q57",
              "type": "mcq",
              "question": "What is the root of a tree?",
              "options": ["The last node", "The node with no parent", "The deepest node", "Any leaf node"],
              "correctAnswer": "The node with no parent",
              "explanation": "The root is the topmost node in a tree that has no parent node.",
              "difficulty": "easy",
              "topic": "trees"
            },
            {
              "id": "q57a",
              "type": "fillInBlank",
              "question": "Nodes with no children are called _____ nodes.",
              "correctAnswer": "leaf",
              "explanation": "Leaf nodes are terminal nodes that have no children.",
              "difficulty": "easy",
              "topic": "trees"
            }
          ]
        },
        {
          "id": "tree-traversal",
          "title": "Tree Traversal",
          "description": "Methods for visiting all nodes in a tree",
          "xpReward": 75,
          "questions": [
            {
              "id": "q58",
              "type": "mcq",
              "question": "In which traversal do you visit the root before its children?",
              "options": ["Inorder", "Preorder", "Postorder", "Level order"],
              "correctAnswer": "Preorder",
              "explanation": "Preorder traversal visits root first, then left subtree, then right subtree.",
              "difficulty": "medium",
              "topic": "trees"
            },
            {
              "id": "q58a",
              "type": "mcq",
              "question": "Which traversal visits nodes level by level from top to bottom?",
              "options": ["Inorder", "Preorder", "Postorder", "Level order"],
              "correctAnswer": "Level order",
              "explanation": "Level order traversal uses a queue to visit all nodes at each level before moving to the next level.",
              "difficulty": "medium",
              "topic": "trees"
            },
            {
              "id": "q58b",
              "type": "fillInBlank",
              "question": "Inorder traversal of a binary search tree visits nodes in _____ order.",
              "correctAnswer": "sorted",
              "explanation": "Inorder traversal of a BST visits nodes in ascending sorted order.",
              "difficulty": "medium",
              "topic": "trees"
            }
          ]
        },
        {
          "id": "binary-search-trees",
          "title": "Binary Search Trees",
          "description": "Efficient searching and insertion in trees",
          "xpReward": 80,
          "questions": [
            {
              "id": "q58c",
              "type": "mcq",
              "question": "What is the key property of a binary search tree?",
              "options": ["All nodes have two children", "Left child < parent < right child", "Tree is always balanced", "Maximum height is log n"],
              "correctAnswer": "Left child < parent < right child",
              "explanation": "In a BST, all values in the left subtree are less than the parent, and all values in the right subtree are greater.",
              "difficulty": "medium",
              "topic": "trees"
            },
            {
              "id": "q58d",
              "type": "mcq",
              "question": "What is the average time complexity for search in a balanced BST?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
              "correctAnswer": "O(log n)",
              "explanation": "Balanced BSTs allow elimination of half the search space at each step, resulting in O(log n) search time.",
              "difficulty": "medium",
              "topic": "trees"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-6",
      "title": "Graphs",
      "description": "Network data structures and graph algorithms",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "graph-basics",
          "title": "Graph Basics",
          "description": "Understanding vertices, edges, and graph types",
          "xpReward": 80,
          "questions": [
            {
              "id": "q59",
              "type": "fillInBlank",
              "question": "A graph consists of _____ (nodes) and edges (connections).",
              "correctAnswer": "vertices",
              "explanation": "Graphs are made up of vertices (nodes) connected by edges.",
              "difficulty": "easy",
              "topic": "graphs"
            },
            {
              "id": "q59a",
              "type": "mcq",
              "question": "What is the difference between directed and undirected graphs?",
              "options": ["Directed graphs are faster", "Directed edges have direction, undirected don't", "Undirected graphs use more memory", "No difference"],
              "correctAnswer": "Directed edges have direction, undirected don't",
              "explanation": "Directed graphs have edges with direction (A→B), while undirected graphs have bidirectional connections (A—B).",
              "difficulty": "medium",
              "topic": "graphs"
            },
            {
              "id": "q59b",
              "type": "fillInBlank",
              "question": "The number of edges connected to a vertex is called its _____.",
              "correctAnswer": "degree",
              "explanation": "The degree of a vertex is the number of edges incident to it.",
              "difficulty": "easy",
              "topic": "graphs"
            }
          ]
        },
        {
          "id": "graph-traversal",
          "title": "Graph Traversal",
          "description": "DFS and BFS algorithms for exploring graphs",
          "xpReward": 85,
          "questions": [
            {
              "id": "q59c",
              "type": "mcq",
              "question": "Which data structure is typically used for DFS (Depth-First Search)?",
              "options": ["Queue", "Stack", "Heap", "Hash Map"],
              "correctAnswer": "Stack",
              "explanation": "DFS uses a stack (or recursion which uses the call stack) to explore as deep as possible before backtracking.",
              "difficulty": "medium",
              "topic": "graphs"
            },
            {
              "id": "q59d",
              "type": "mcq",
              "question": "Which data structure is typically used for BFS (Breadth-First Search)?",
              "options": ["Queue", "Stack", "Heap", "Hash Map"],
              "correctAnswer": "Queue",
              "explanation": "BFS uses a queue to explore all neighbors at the current depth before moving to the next depth level.",
              "difficulty": "medium",
              "topic": "graphs"
            },
            {
              "id": "q59e",
              "type": "fillInBlank",
              "question": "BFS finds the _____ path between two vertices in an unweighted graph.",
              "correctAnswer": "shortest",
              "explanation": "BFS naturally finds the shortest path in unweighted graphs by exploring vertices level by level.",
              "difficulty": "medium",
              "topic": "graphs"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-7", 
      "title": "Sorting I",
      "description": "Simple O(n²) sorting algorithms",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "bubble-sort",
          "title": "Bubble Sort",
          "description": "Understanding the simplest sorting algorithm",
          "xpReward": 50,
          "questions": [
            {
              "id": "q60",
              "type": "mcq",
              "question": "What is the time complexity of bubble sort?",
              "options": ["O(n)", "O(n log n)", "O(n²)", "O(log n)"],
              "correctAnswer": "O(n²)",
              "explanation": "Bubble sort has O(n²) time complexity due to nested loops comparing adjacent elements.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q60a",
              "type": "fillInBlank",
              "question": "Bubble sort repeatedly compares _____ elements and swaps them if needed.",
              "correctAnswer": "adjacent",
              "explanation": "Bubble sort compares each pair of adjacent elements and swaps them if they are in wrong order.",
              "difficulty": "easy",
              "topic": "sorting"
            }
          ]
        },
        {
          "id": "selection-sort",
          "title": "Selection Sort",
          "description": "Sorting by repeatedly finding the minimum element",
          "xpReward": 55,
          "questions": [
            {
              "id": "q60b",
              "type": "mcq",
              "question": "How does selection sort work?",
              "options": ["Swaps adjacent elements", "Finds minimum and places it at beginning", "Divides array in half", "Uses a pivot element"],
              "correctAnswer": "Finds minimum and places it at beginning",
              "explanation": "Selection sort repeatedly finds the minimum element from unsorted portion and places it at the beginning.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q60c",
              "type": "mcq",
              "question": "What is the time complexity of selection sort?",
              "options": ["O(n)", "O(n log n)", "O(n²)", "O(log n)"],
              "correctAnswer": "O(n²)",
              "explanation": "Selection sort has O(n²) time complexity as it performs nested loops to find minimum elements.",
              "difficulty": "medium",
              "topic": "sorting"
            }
          ]
        },
        {
          "id": "insertion-sort",
          "title": "Insertion Sort", 
          "description": "Building sorted array one element at a time",
          "xpReward": 60,
          "questions": [
            {
              "id": "q60d",
              "type": "mcq",
              "question": "How does insertion sort build the final sorted array?",
              "options": ["By finding minimum elements", "By inserting each element in its correct position", "By swapping adjacent elements", "By dividing the array"],
              "correctAnswer": "By inserting each element in its correct position",
              "explanation": "Insertion sort builds the sorted array by taking each element and inserting it in the correct position among previously sorted elements.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q60e",
              "type": "fillInBlank",
              "question": "Insertion sort is efficient for _____ datasets.",
              "correctAnswer": "small",
              "explanation": "Insertion sort performs well on small datasets due to its simple implementation and low overhead.",
              "difficulty": "easy",
              "topic": "sorting"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-8",
      "title": "Sorting II",
      "description": "Efficient O(n log n) sorting algorithms",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "merge-sort",
          "title": "Merge Sort",
          "description": "Divide and conquer sorting approach",
          "xpReward": 70,
          "questions": [
            {
              "id": "q61",
              "type": "mcq",
              "question": "What is the time complexity of merge sort?",
              "options": ["O(n)", "O(n log n)", "O(n²)", "O(log n)"],
              "correctAnswer": "O(n log n)",
              "explanation": "Merge sort consistently runs in O(n log n) time using divide and conquer.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q61a",
              "type": "mcq",
              "question": "What is the key principle behind merge sort?",
              "options": ["Bubble elements up", "Divide and conquer", "Find pivot element", "Select minimum"],
              "correctAnswer": "Divide and conquer",
              "explanation": "Merge sort divides the array into smaller subarrays, sorts them, then merges them back together.",
              "difficulty": "medium",
              "topic": "sorting"
            }
          ]
        },
        {
          "id": "quick-sort",
          "title": "Quick Sort",
          "description": "Efficient in-place sorting algorithm",
          "xpReward": 75,
          "questions": [
            {
              "id": "q62",
              "type": "fillInBlank",
              "question": "Quick sort uses a _____ element to partition the array.",
              "correctAnswer": "pivot",
              "explanation": "Quick sort selects a pivot element and partitions the array around it.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q62a",
              "type": "mcq",
              "question": "What is the average time complexity of quick sort?",
              "options": ["O(n)", "O(n log n)", "O(n²)", "O(log n)"],
              "correctAnswer": "O(n log n)",
              "explanation": "Quick sort has average case O(n log n) time complexity with good pivot selection.",
              "difficulty": "medium",
              "topic": "sorting"
            }
          ]
        },
        {
          "id": "heap-sort",
          "title": "Heap Sort",
          "description": "Sorting using heap data structure",
          "xpReward": 80,
          "questions": [
            {
              "id": "q62b",
              "type": "mcq",
              "question": "What data structure does heap sort use?",
              "options": ["Stack", "Queue", "Binary heap", "Hash table"],
              "correctAnswer": "Binary heap",
              "explanation": "Heap sort uses a binary heap to efficiently find and remove the maximum/minimum element.",
              "difficulty": "medium",
              "topic": "sorting"
            },
            {
              "id": "q62c",
              "type": "mcq",
              "question": "What is the time complexity of heap sort?",
              "options": ["O(n)", "O(n log n)", "O(n²)", "O(log n)"],
              "correctAnswer": "O(n log n)",
              "explanation": "Heap sort consistently runs in O(n log n) time for building heap and extracting elements.",
              "difficulty": "medium",
              "topic": "sorting"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-9",
      "title": "Greedy",
      "description": "Making locally optimal choices for global solutions",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "greedy-basics",
          "title": "Basics",
          "description": "Understanding the greedy approach and when to use it",
          "xpReward": 65,
          "questions": [
            {
              "id": "q65",
              "type": "mcq",
              "question": "What is the key principle of greedy algorithms?",
              "options": ["Try all possible solutions", "Make locally optimal choices", "Use dynamic programming", "Divide and conquer"],
              "correctAnswer": "Make locally optimal choices",
              "explanation": "Greedy algorithms make the best local choice at each step, hoping to find a global optimum.",
              "difficulty": "medium",
              "topic": "greedy"
            },
            {
              "id": "q66",
              "type": "fillInBlank",
              "question": "Greedy algorithms don't always guarantee the _____ solution.",
              "correctAnswer": "optimal",
              "explanation": "Greedy algorithms may not always find the globally optimal solution, only locally optimal ones.",
              "difficulty": "medium",
              "topic": "greedy"
            },
            {
              "id": "q67",
              "type": "mcq",
              "question": "What is a key advantage of greedy algorithms?",
              "options": ["Always find optimal solution", "Simple and efficient", "Work for all problems", "Use minimal memory"],
              "correctAnswer": "Simple and efficient",
              "explanation": "Greedy algorithms are typically simple to implement and have good time complexity.",
              "difficulty": "easy",
              "topic": "greedy"
            }
          ]
        },
        {
          "id": "activity-selection",
          "title": "Activity Selection",
          "description": "Classic greedy problem of selecting maximum activities",
          "xpReward": 70,
          "questions": [
            {
              "id": "q68",
              "type": "mcq",
              "question": "In the activity selection problem, what is the greedy choice?",
              "options": ["Select longest activity", "Select activity that starts earliest", "Select activity that finishes earliest", "Select most profitable activity"],
              "correctAnswer": "Select activity that finishes earliest",
              "explanation": "Selecting the activity that finishes earliest leaves maximum room for subsequent activities.",
              "difficulty": "medium",
              "topic": "greedy"
            },
            {
              "id": "q69",
              "type": "fillInBlank",
              "question": "Activity selection problem aims to select maximum number of _____ activities.",
              "correctAnswer": "non-overlapping",
              "explanation": "The goal is to select the maximum number of activities that don't overlap in time.",
              "difficulty": "easy",
              "topic": "greedy"
            }
          ]
        },
        {
          "id": "huffman-coding",
          "title": "Huffman Coding",
          "description": "Optimal prefix-free codes using greedy approach",
          "xpReward": 80,
          "questions": [
            {
              "id": "q70",
              "type": "mcq",
              "question": "What does Huffman coding optimize?",
              "options": ["Memory usage", "Code length based on frequency", "Processing speed", "Security"],
              "correctAnswer": "Code length based on frequency",
              "explanation": "Huffman coding assigns shorter codes to more frequent characters, minimizing total code length.",
              "difficulty": "medium",
              "topic": "greedy"
            },
            {
              "id": "q71",
              "type": "fillInBlank",
              "question": "Huffman coding uses a _____ tree to assign codes to characters.",
              "correctAnswer": "binary",
              "explanation": "Huffman coding builds a binary tree where paths from root to leaves represent character codes.",
              "difficulty": "medium",
              "topic": "greedy"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-10",
      "title": "Dynamic Programming",
      "description": "Optimizing recursive problems with memoization",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "dp-basics",
          "title": "Basics",
          "description": "Understanding overlapping subproblems and optimal substructure",
          "xpReward": 80,
          "questions": [
            {
              "id": "q63",
              "type": "mcq",
              "question": "What are the two key properties of dynamic programming problems?",
              "options": ["Fast and efficient", "Overlapping subproblems and optimal substructure", "Recursive and iterative", "Simple and complex"],
              "correctAnswer": "Overlapping subproblems and optimal substructure",
              "explanation": "DP problems must have overlapping subproblems and optimal substructure to benefit from memoization.",
              "difficulty": "hard",
              "topic": "dp"
            }
          ]
        },
        {
          "id": "fibonacci-dp",
          "title": "Fibonacci DP",
          "description": "Classic example of dynamic programming optimization",
          "xpReward": 60,
          "questions": [
            {
              "id": "q64",
              "type": "fillInBlank",
              "question": "Memoized fibonacci reduces time complexity from O(2^n) to O(_____)",
              "correctAnswer": "n",
              "explanation": "Memoization eliminates redundant calculations, reducing time complexity to linear O(n).",
              "difficulty": "medium",
              "topic": "dp"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-11",
      "title": "Linked Lists",
      "description": "Dynamic linear data structures with pointer-based connections",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "linked-list-basics",
          "title": "Basics",
          "description": "Understanding nodes, pointers, and basic operations",
          "xpReward": 60,
          "questions": [
            {
              "id": "q72",
              "type": "mcq",
              "question": "What are the two main components of a linked list node?",
              "options": ["Data and index", "Data and next pointer", "Value and size", "Key and value"],
              "correctAnswer": "Data and next pointer",
              "explanation": "Each node contains data (the actual value) and a next pointer (reference to the next node).",
              "difficulty": "easy",
              "topic": "linked-lists"
            },
            {
              "id": "q73",
              "type": "fillInBlank",
              "question": "The first node in a linked list is called the _____ node.",
              "correctAnswer": "head",
              "explanation": "The head node is the starting point of the linked list and is referenced by the head pointer.",
              "difficulty": "easy",
              "topic": "linked-lists"
            },
            {
              "id": "q74",
              "type": "mcq",
              "question": "What is the time complexity of inserting at the beginning of a linked list?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
              "correctAnswer": "O(1)",
              "explanation": "Inserting at the beginning only requires updating the head pointer and the new node's next pointer.",
              "difficulty": "medium",
              "topic": "linked-lists"
            }
          ]
        },
        {
          "id": "linked-list-types",
          "title": "Types",
          "description": "Singly, doubly, and circular linked lists",
          "xpReward": 65,
          "questions": [
            {
              "id": "q75",
              "type": "mcq",
              "question": "What additional pointer does a doubly linked list node have?",
              "options": ["Parent pointer", "Previous pointer", "Child pointer", "Root pointer"],
              "correctAnswer": "Previous pointer",
              "explanation": "Doubly linked lists have both next and previous pointers, allowing bidirectional traversal.",
              "difficulty": "medium",
              "topic": "linked-lists"
            },
            {
              "id": "q76",
              "type": "fillInBlank",
              "question": "In a circular linked list, the last node's next pointer points to the _____ node.",
              "correctAnswer": "head",
              "explanation": "Circular linked lists form a loop where the last node points back to the first node.",
              "difficulty": "medium",
              "topic": "linked-lists"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-12",
      "title": "Heaps",
      "description": "Complete binary trees with heap property for priority operations",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "heap-basics",
          "title": "Basics",
          "description": "Understanding heap property and binary heap structure",
          "xpReward": 70,
          "questions": [
            {
              "id": "q77",
              "type": "mcq",
              "question": "What is the heap property for a max heap?",
              "options": ["Parent ≤ children", "Parent ≥ children", "Left child ≤ right child", "All nodes are equal"],
              "correctAnswer": "Parent ≥ children",
              "explanation": "In a max heap, every parent node is greater than or equal to its children.",
              "difficulty": "medium",
              "topic": "heaps"
            },
            {
              "id": "q78",
              "type": "fillInBlank",
              "question": "The time complexity of inserting an element into a binary heap is O(_____)",
              "correctAnswer": "log n",
              "explanation": "Insertion requires bubbling up the element, which takes O(log n) time in the worst case.",
              "difficulty": "medium",
              "topic": "heaps"
            },
            {
              "id": "q79",
              "type": "mcq",
              "question": "What operation extracts the maximum element from a max heap?",
              "options": ["peek", "extract-max", "heapify", "build-heap"],
              "correctAnswer": "extract-max",
              "explanation": "Extract-max removes and returns the maximum element (root) from a max heap.",
              "difficulty": "easy",
              "topic": "heaps"
            }
          ]
        },
        {
          "id": "priority-queues",
          "title": "Priority Queues",
          "description": "Using heaps to implement priority queues",
          "xpReward": 75,
          "questions": [
            {
              "id": "q80",
              "type": "mcq",
              "question": "What data structure is commonly used to implement a priority queue?",
              "options": ["Array", "Stack", "Binary heap", "Hash table"],
              "correctAnswer": "Binary heap",
              "explanation": "Binary heaps provide efficient O(log n) insertion and O(log n) extraction of highest priority elements.",
              "difficulty": "medium",
              "topic": "heaps"
            },
            {
              "id": "q81",
              "type": "fillInBlank",
              "question": "In a priority queue, elements are served based on their _____, not insertion order.",
              "correctAnswer": "priority",
              "explanation": "Priority queues serve elements based on priority level rather than FIFO or LIFO order.",
              "difficulty": "easy",
              "topic": "heaps"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-13",
      "title": "Recursion",
      "description": "Functions that call themselves to solve problems",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "recursion-basics",
          "title": "Basics",
          "description": "Understanding base cases and recursive calls",
          "xpReward": 55,
          "questions": [
            {
              "id": "q82",
              "type": "mcq",
              "question": "What are the two essential components of a recursive function?",
              "options": ["Loop and condition", "Base case and recursive case", "Input and output", "Start and end"],
              "correctAnswer": "Base case and recursive case",
              "explanation": "Every recursive function needs a base case (stopping condition) and a recursive case (calling itself).",
              "difficulty": "medium",
              "topic": "recursion"
            },
            {
              "id": "q83",
              "type": "fillInBlank",
              "question": "The _____ case prevents infinite recursion by providing a stopping condition.",
              "correctAnswer": "base",
              "explanation": "The base case defines when the recursion should stop and return a value without making further recursive calls.",
              "difficulty": "easy",
              "topic": "recursion"
            },
            {
              "id": "q84",
              "type": "mcq",
              "question": "What happens if a recursive function lacks a proper base case?",
              "options": ["It runs faster", "It causes infinite recursion", "It returns null", "It becomes iterative"],
              "correctAnswer": "It causes infinite recursion",
              "explanation": "Without a base case, the function will call itself indefinitely, leading to stack overflow.",
              "difficulty": "medium",
              "topic": "recursion"
            }
          ]
        },
        {
          "id": "recursion-examples",
          "title": "Classic Examples",
          "description": "Factorial, Fibonacci, and tree traversal",
          "xpReward": 65,
          "questions": [
            {
              "id": "q85",
              "type": "mcq",
              "question": "What is the base case for calculating factorial recursively?",
              "options": ["n = 0 or n = 1", "n = 2", "n < 0", "n > 10"],
              "correctAnswer": "n = 0 or n = 1",
              "explanation": "Factorial of 0 and 1 is 1, which serves as the base case for recursive factorial calculation.",
              "difficulty": "easy",
              "topic": "recursion"
            },
            {
              "id": "q86",
              "type": "fillInBlank",
              "question": "Tree traversal algorithms like preorder and inorder are naturally implemented using _____.",
              "correctAnswer": "recursion",
              "explanation": "Tree traversals naturally use recursion to visit nodes in a systematic order.",
              "difficulty": "medium",
              "topic": "recursion"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-14",
      "title": "Searching",
      "description": "Algorithms for finding elements in data structures",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "linear-search",
          "title": "Linear Search",
          "description": "Sequential searching through elements",
          "xpReward": 45,
          "questions": [
            {
              "id": "q87",
              "type": "mcq",
              "question": "What is the time complexity of linear search?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
              "correctAnswer": "O(n)",
              "explanation": "Linear search checks each element sequentially, taking O(n) time in the worst case.",
              "difficulty": "easy",
              "topic": "searching"
            },
            {
              "id": "q88",
              "type": "fillInBlank",
              "question": "Linear search works on both _____ and unsorted arrays.",
              "correctAnswer": "sorted",
              "explanation": "Linear search doesn't require any ordering and works on both sorted and unsorted data.",
              "difficulty": "easy",
              "topic": "searching"
            }
          ]
        },
        {
          "id": "binary-search",
          "title": "Binary Search",
          "description": "Efficient searching in sorted arrays",
          "xpReward": 65,
          "questions": [
            {
              "id": "q89",
              "type": "mcq",
              "question": "What is the prerequisite for binary search?",
              "options": ["Array must be large", "Array must be sorted", "Array must have unique elements", "Array must be numeric"],
              "correctAnswer": "Array must be sorted",
              "explanation": "Binary search requires the array to be sorted to eliminate half the search space at each step.",
              "difficulty": "medium",
              "topic": "searching"
            },
            {
              "id": "q90",
              "type": "mcq",
              "question": "What is the time complexity of binary search?",
              "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
              "correctAnswer": "O(log n)",
              "explanation": "Binary search halves the search space at each step, resulting in O(log n) time complexity.",
              "difficulty": "medium",
              "topic": "searching"
            },
            {
              "id": "q91",
              "type": "fillInBlank",
              "question": "Binary search compares the target with the _____ element to decide which half to search.",
              "correctAnswer": "middle",
              "explanation": "Binary search finds the middle element and compares it with the target to eliminate half the array.",
              "difficulty": "easy",
              "topic": "searching"
            }
          ]
        }
      ]
    },
    {
      "id": "unit-15",
      "title": "Big O Notation",
      "description": "Analyzing algorithm efficiency and complexity",
      "isUnlocked": true,
      "completedLessons": 0,
      "lessons": [
        {
          "id": "time-complexity",
          "title": "Time Complexity",
          "description": "Understanding how algorithms scale with input size",
          "xpReward": 70,
          "questions": [
            {
              "id": "q92",
              "type": "mcq",
              "question": "What does Big O notation describe?",
              "options": ["Best case performance", "Average case performance", "Worst case performance", "Space usage only"],
              "correctAnswer": "Worst case performance",
              "explanation": "Big O notation describes the upper bound or worst-case time complexity of an algorithm.",
              "difficulty": "medium",
              "topic": "complexity"
            },
            {
              "id": "q93",
              "type": "fillInBlank",
              "question": "An algorithm that accesses a single array element has _____ time complexity.",
              "correctAnswer": "O(1)",
              "explanation": "Constant time O(1) means the operation takes the same time regardless of input size.",
              "difficulty": "easy",
              "topic": "complexity"
            },
            {
              "id": "q94",
              "type": "mcq",
              "question": "Which time complexity is better: O(n) or O(log n)?",
              "options": ["O(n)", "O(log n)", "They're the same", "Depends on input"],
              "correctAnswer": "O(log n)",
              "explanation": "O(log n) grows much slower than O(n), making it more efficient for large inputs.",
              "difficulty": "medium",
              "topic": "complexity"
            }
          ]
        },
        {
          "id": "space-complexity",
          "title": "Space Complexity",
          "description": "Analyzing memory usage of algorithms",
          "xpReward": 60,
          "questions": [
            {
              "id": "q95",
              "type": "mcq",
              "question": "What does space complexity measure?",
              "options": ["Execution time", "Memory usage", "Code length", "CPU cycles"],
              "correctAnswer": "Memory usage",
              "explanation": "Space complexity measures how much additional memory an algorithm uses relative to input size.",
              "difficulty": "easy",
              "topic": "complexity"
            },
            {
              "id": "q96",
              "type": "fillInBlank",
              "question": "An algorithm that uses a fixed amount of extra memory has _____ space complexity.",
              "correctAnswer": "O(1)",
              "explanation": "Constant space O(1) means the algorithm uses the same amount of extra memory regardless of input size.",
              "difficulty": "medium",
              "topic": "complexity"
            }
          ]
        }
      ]
    }
  ]
}